<?xml version="1.0"?>
<doc>
  <assembly>
    <name>uLink</name>
  </assembly>
  <members>
    <member name="T:UnityPark.VersionFormat.IStringBuildable">
      <summary>
            An interface for making types easier to build to string format.
            </summary>
    </member>
    <member name="M:UnityPark.VersionFormat.IStringBuildable.BuildString(System.Text.StringBuilder)">
      <summary>
            Gets a StringBuilder from the caller and uses it to append string information about the instance.
            </summary>
      <param name="builder">A StringBuilder instance to append data to.</param>
    </member>
    <member name="T:UnityPark.VersionFormat.StringBuildableUtility">
      <summary>
             Utility class for building strings.
            </summary>
    </member>
    <member name="M:UnityPark.VersionFormat.StringBuildableUtility.BuildFromMember(System.Text.StringBuilder,System.Object,System.String)">
      <summary>
            Helps append a string containing information about a member to a StringBuilder.
            </summary>
      <param name="builder">A StringBuilder to receive the data.</param>
      <param name="value">The value of the member.</param>
      <param name="name">The name of the member.</param>
    </member>
    <member name="T:UnityPark.VersionFormat.VersionAttributes">
      <summary>
            Contains a representation of version information, encoded in the format specific to assembly attributes.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionAttributes.ProductName">
      <summary>
            The content of an AssemblyProductAttribute.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionAttributes.Description">
      <summary>
            The content of an AssemblyDescriptionAttribute.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionAttributes.Company">
      <summary>
            The content of an AssemblyCompanyAttribute.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionAttributes.Copyright">
      <summary>
            The content of an AssemblyCopyrightAttribute.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionAttributes.Config">
      <summary>
            The content of an AssemblyConfigAttribute.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionAttributes.InformationalVersion">
      <summary>
            The content of an AssemblyInformationalVersionAttribute.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionAttributes.FileVersion">
      <summary>
            The content of an AssemblyFileVersionAttribute.
            </summary>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionAttributes.ToParameters">
      <summary>
            Converts the assembly attribute representation into a general VersionParameters representation.
            </summary>
      <returns>A VersionParameters instance containing the encoded information.</returns>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionAttributes.ToString">
      <summary>
            Returns the fully qualified type name of this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionAttributes.BuildString(System.Text.StringBuilder)">
      <summary>
            Gets a StringBuilder from the caller and uses it to append string information about the instance.
            </summary>
      <param name="builder">A StringBuilder instance to append data to.</param>
    </member>
    <member name="T:UnityPark.VersionFormat.VersionBuildType">
      <summary>
             Signifies a type of build.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionBuildType.Stable">
      <summary>
            Stable build, which has been released to the public.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionBuildType.Beta">
      <summary>
            Beta build, which is a preview of the next stable.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionBuildType.Custom">
      <summary>
            Custom build, which might have changes that will not enter into mainline releases.
            </summary>
    </member>
    <member name="T:UnityPark.VersionFormat.VersionFileName">
      <summary>
            Contains a representation of version information, encoded in the format specific for file names.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionFileName.FileName">
      <summary>
            The version information encoded into a string on file name form.
            </summary>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionFileName.ToParameters">
      <summary>
            Converts the file name representation into a general VersionParameters representation.
            </summary>
      <returns>A VersionParameters instance containing the encoded information.</returns>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionFileName.ToString">
      <summary>
            Returns the fully qualified type name of this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionFileName.BuildString(System.Text.StringBuilder)">
      <summary>
            Gets a StringBuilder from the caller and uses it to append string information about the instance.
            </summary>
      <param name="builder">A StringBuilder instance to append data to.</param>
    </member>
    <member name="T:UnityPark.VersionFormat.VersionParameters">
      <summary>
             The most basic representation of version information.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.ProductName">
      <summary>
            The name of the product.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Description">
      <summary>
            The product description.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Company">
      <summary>
            The product company.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Copyright">
      <summary>
            The product copyright.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Config">
      <summary>
            The compilation configuration.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Major">
      <summary>
            The product release major verison.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Minor">
      <summary>
            The product release minor version.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Update">
      <summary>
            The product release update version.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Hotfix">
      <summary>
            The product release hotfix version.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.BuildType">
      <summary>
            The product release build type.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.BuildNumber">
      <summary>
            The product release build number.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.FancyName">
      <summary>
            The product release fancy name.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.IsSource">
      <summary>
            The product release source flag.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Revision">
      <summary>
            The product release version control revision.
            </summary>
    </member>
    <member name="F:UnityPark.VersionFormat.VersionParameters.Date">
      <summary>
            The product release build date.
            </summary>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionParameters.ToAttributes">
      <summary>
            Encodes the version data in assembly attribute form.
            </summary>
      <returns>The version data in assembly attribute form.</returns>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionParameters.ToFileName">
      <summary>
            Encodes the version data in file name form.
            </summary>
      <returns>The version data in file name form.</returns>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionParameters.ToString">
      <summary>
            Returns the fully qualified type name of this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
    </member>
    <member name="M:UnityPark.VersionFormat.VersionParameters.BuildString(System.Text.StringBuilder)">
      <summary>
            Gets a StringBuilder from the caller and uses it to append string information about the instance.
            </summary>
      <param name="builder">A StringBuilder instance to append data to.</param>
    </member>
    <member name="T:UnityPark.VersionFormat.Exceptions.VersionFormatException">
      <summary>
            Identifies problems specific to the parsing and generation of version information.
            </summary>
    </member>
    <member name="M:UnityPark.VersionFormat.Exceptions.VersionFormatException.#ctor(System.String,System.Exception)">
      <summary>
            Creates a new instance of VersionFormatException.
            </summary>
      <param name="message">A message describing the error.</param>
      <param name="innerException">An optional inner exception.</param>
    </member>
    <!-- Badly formed XML comment ignored for member "T:uLink.HashSet`2" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.HashSet`2.System#Collections#Generic#ICollection{T}#Add(`0)" -->
    <member name="T:uLink.PeerData">
      <summary>
            Data structure for holding individual host (server) information.
            </summary>
      <remarks>
            The host list retrieved from a master server uses this class to represent individual servers. 
            See <see cref="M:uLink.MasterServer.PollHostList" /></remarks>
    </member>
    <member name="T:uLink.LocalPeerData">
      <summary>
            Base data structure for holding individual host (server) information, for a LAN server without an external IP address.
            </summary>
      <remarks>
            Host information for servers with and external public address is stored in the subclass <see cref="T:uLink.HostData" />.
            </remarks>
    </member>
    <member name="F:uLink.LocalPeerData.peerType">
      <summary>
            The type of the game (like MyUniqueGameType).
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.peerName">
      <summary>
            The name of the game (like John Doe's Game)
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.passwordProtected">
      <summary>
            Does the server require a password?
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.comment">
      <summary>
            A miscellaneous comment about the server
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.platform">
      <summary>
            Use this string to describe the platform needed for connecting to this game server.
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.timestamp">
      <summary>
            The time when this data (about the host) was collected.
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.internalEndpoint">
      <summary>
            The IP address and port for this host in the local network (LAN). 
            </summary>
    </member>
    <member name="M:uLink.LocalPeerData.IsDefined">
      <summary>
            Returns true if internalEnpoint, gameType and gameName has been set, otherwise false.
            </summary>
    </member>
    <member name="P:uLink.LocalPeerData.internalPort">
      <summary>
            Server private port in the local network (LAN). 
            </summary>
    </member>
    <member name="P:uLink.LocalPeerData.internalIP">
      <summary>
            Server private IP address in the local network (LAN). 
            </summary>
    </member>
    <member name="F:uLink.PeerData.externalEndpoint">
      <summary>
            The public IP address and port for this host on the Internet. 
            </summary>
    </member>
    <member name="F:uLink.PeerData.ping">
      <summary>
            Returns the round trip ping time in milliseconds from the master server to the 
            game server, or if this is a WellKnownHost the ping time is instead meassured 
            between the client and the host.
            </summary>
      <remarks>
            The most usable ping time is for WellKnownHosts since it is meassured between 
            the client and the game server(s). A player is usually looking for a nearby server 
            with a nice low ping time. 
            <para>
            The ping time between the master server and the game server can be useful in some situations.
            How useful it is depends on where servers are hosted. uLink provides this value to be used in 
            any way you want.</para><para>
            If the host needs a proxy this ping time is 
            not correct. Do not use this ping time in the proxy case.  
            </para><para>
            Pingtime between a server and connected players is available via <see cref="M:uLink.Network.GetAveragePing(uLink.NetworkPlayer)" /></para></remarks>
    </member>
    <member name="P:uLink.PeerData.externalPort">
      <summary>
            Server public port, used by clients on the Internet to connect to the server.
            </summary>
    </member>
    <member name="P:uLink.PeerData.externalIP">
      <summary>
            Server public IP address, used by clients on the Internet to connect to the server.
            </summary>
    </member>
    <member name="P:uLink.PeerData.port">
      <summary>
            Server public port, used by clients on the Internet to connect to the server. Same as <see cref="P:uLink.HostData.externalPort" />.
            </summary>
    </member>
    <member name="P:uLink.PeerData.ipAddress">
      <summary>
            Server public IP address, used by clients on the Internet to connect to the server. Same as <see cref="P:uLink.HostData.externalIP" />.
            </summary>
    </member>
    <member name="T:uLink.PeerDataFilter">
      <summary>
            Used to filter the list of peers in a list of peers when using discovery functionality of uLink.
            </summary>
    </member>
    <member name="F:uLink.PeerDataFilter.peerType">
      <summary>
            Type of the peer.
            Can be anything which is logical for your game. combat server, Shop server or whatever.
            </summary>
    </member>
    <member name="F:uLink.PeerDataFilter.peerName">
      <summary>
            Name of the peer
            </summary>
    </member>
    <member name="F:uLink.PeerDataFilter.passwordProtected">
      <summary>
            Is the peer password protected.
            </summary>
    </member>
    <member name="F:uLink.PeerDataFilter.comment">
      <summary>
            The comment of the peer.
            </summary>
    </member>
    <member name="F:uLink.PeerDataFilter.platform">
      <summary>
            The platform that the peer is running on.
            </summary>
    </member>
    <member name="M:uLink.PeerDataFilter.Match(uLink.LocalPeerData)">
      <summary>
            Returns if the provided peer matchs this filter or not.
            </summary>
      <param name="peerData">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.PeerDataFilter.FilterList``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Returns the list of peers from the provided collection, which match this filter.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="unfilteredPeers">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkEndPoint.GetHashCode">
      <summary>
            Returns the hash code for this <see cref="T:uLink.NetworkEndPoint" />.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this <see cref="T:uLink.NetworkEndPoint" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkEndPoint.ToString">
      <summary>
            Returns a formatted string with details on this <see cref="T:uLink.NetworkEndPoint" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkEndPoint.op_Equality(uLink.NetworkEndPoint,uLink.NetworkEndPoint)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkEndPoint" />s are identical
            </summary>
    </member>
    <member name="M:uLink.NetworkEndPoint.op_Inequality(uLink.NetworkEndPoint,uLink.NetworkEndPoint)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkEndPoint" />s are not identical
            </summary>
    </member>
    <member name="M:uLink.NetworkEndPoint.Equals(System.Object)">
      <summary>
            Indicates whether this <see cref="T:uLink.NetworkEndPoint" /> and a specified object are equal.
            </summary>
      <returns>
        <c>true</c> if <paramref name="other" /> and this <see cref="T:uLink.NetworkEndPoint" /> are the same type and represent the same value; otherwise, <c>false</c>.
            </returns>
      <param name="other">Another object to compare to. </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:uLink.NetworkTimeMeasurementFunction">
      <summary>
            This enum represents the different ways which you can use to measure time.
            </summary>
    </member>
    <member name="F:uLink.NetworkTimeMeasurementFunction.Stopwatch">
      <summary>
            This is .NET's StopWatch which uses high performance timers of the CPU most of the times. 
            See MSDN docs for StopWatch for more information.
            </summary>
    </member>
    <member name="F:uLink.NetworkTimeMeasurementFunction.TickCount">
      <summary>
            Uses the lower resolution GetTickCount windows API which provides better results in some situations.
            </summary>
    </member>
    <member name="F:uLink.NetworkTimeMeasurementFunction.DateTime">
      <summary>
            Uses .NET's DateTime class.
            See MSDN for more information on this class.
            </summary>
    </member>
    <member name="P:uLink.NetworkTime.localTime">
      <summary>
            Gets the value of a local smooth monotonic and accurate clock (in seconds).
            </summary>
      <remarks>
            This can for example be compared against NetworkMessageInfo.localTimestamp to determine how long ago a message was sent.
            The clock is monotonic (i.e. no backward leaps), smooth (i.e. no forward leaps), and has greater accuracy than UnityEngine.Time.time (or similar),
            so it can also be used to measure execution time of performance-critical tasks etc.
            </remarks>
    </member>
    <member name="P:uLink.NetworkTime.timeMeasurementFunction">
      <summary>
            Gets or sets the time measurement function for uLink.
            </summary>
      <remarks>
            Usually StopWatch should be the best but sometimes TickCount works better despite the fact that it has a lower resolution.
            </remarks>
    </member>
    <member name="P:uLink.NetworkTime.serverTime">
      <summary>
            Gets the value of a server-synchronized monotonic clock (in seconds).
            </summary>
      <returns>
            If called on a client, the clock will return a monotonic approximate value of the server’s NetworkTime.localTime.
            If called on a server, the clock will return the same exact value as the server’s NetworkTime.localTime.
            If called on a disconnected uLink instance, the clock will return zero.
            </returns>
      <remarks>
            The clock is monotonic (i.e. no backward leaps), but makes no effort to be smooth (i.e. it may leap forward).
            It is deemed to give a more up-to-date estimated value of the remote server clock than NetworkTime.smoothServerTime, but less up-to-date than NetworkTime.rawServerTime.
            The clock can for example be compared against NetworkMessageInfo.serverTimestamp to determine how long ago a message was sent.
            </remarks>
    </member>
    <member name="P:uLink.NetworkTime.smoothServerTime">
      <summary>
            Gets the value of a server-synchronized smooth monotonic clock (in seconds).
            </summary>
      <returns>
            If called on a client, the clock will return a continues approximate value of the server’s NetworkTime.localTime.
            If called on a server, the clock will return the same exact value as the server’s NetworkTime.localTime.
            If called on a disconnected uLink instance, the clock will return zero.
            </returns>
      <remarks>
            The clock is monotonic (i.e. no backward leaps) and smooth (i.e. no forward leaps).
            However, it is deemed to give the least up-to-date estimated value of the remote server clock than NetworkTime.serverTime or NetworkTime.rawServerTime.
            </remarks>
    </member>
    <member name="P:uLink.NetworkTime.rawServerTime">
      <summary>
            Gets the value of a server-synchronized up-to-date clock (in seconds).
            </summary>
      <returns>
            If called on a client, the clock will return a latest approximate value of the server’s NetworkTime.localTime.
            If called on a server, the clock will return the same exact value as the server’s NetworkTime.localTime.
            If called on a disconnected uLink instance, the clock will return zero.
            </returns>
      <remarks>
            The clock makes no effort to be monotonic (i.e. it may leap backwards), or smooth (i.e. it may leap forwards).
            However, it is deemed to give the most up-to-date estimated value of the remote server clock,
            compared to both NetworkTime.serverTime and NetworkTime.smoothServerTime.
            The clock can for example be compared against NetworkMessageInfo.rawServerTimestamp to determine how long ago a message was sent.
            </remarks>
    </member>
    <member name="P:uLink.NetworkTime.isServerTimeAvailable">
      <summary>
            Indicates whether the server clock is available or not.
            </summary>
      <returns>
            Returns true if called on a connected (or disconnecting) client or on a initialized server, otherwise returns false.
            </returns>
      <remarks>
            If the server clock is not available, then all server time values will return zero.
            </remarks>
    </member>
    <member name="T:uLink.NetworkViewData">
      <summary>
            The whole data which a <see cref="T:uLink.NetworkView" /> needs to fully initialize itself can be stored in
            an instance of this class.
            This is mostly used in Instantiator methods which should initialize and create the network aware object.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.viewID">
      <summary>
            ViewID of the NetworkView.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.owner">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> which owns the NetworkView in question.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.group">
      <summary>
            The <see cref="T:uLink.NetworkGroup" /> which the NetworkView belongs to.
            You usually use ints instead of NetworkGroups and an implicit casts exists between the types.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.authFlags">
      <summary>
            The Network related settings which is used by Pikko Server.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.isInstantiatedRemotely">
      <summary>
            Is the NetworkView instantiated on a remote machine or locally.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.proxyPrefab">
      <summary>
            The prefab used for proxy role in the NetworkView.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.ownerPrefab">
      <summary>
            The prefab used for the owner role in this NetworkView.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.serverPrefab">
      <summary>
            The prefab used for server role in this NetworkView.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.cellAuthPrefab">
      <summary>
            The prefab on the cell server which has authority on the object.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.cellProxyPrefab">
      <summary>
            The prefab used for cell servers which have a proxy of the object and don't have authority over it.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewData.initialData">
      <summary>
            The initial data sent in the <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> call which resulted in creation of this NetworkView.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewData.#ctor(uLink.NetworkViewID,uLink.NetworkPlayer,uLink.NetworkGroup,uLink.NetworkAuthFlags,System.Boolean,System.String,System.String,System.String,System.String,System.String,uLink.BitStream)">
      <summary>
            Creates a NetworkViewData object with the provided arguments.
            </summary>
      <param name="viewID">
      </param>
      <param name="owner">
      </param>
      <param name="group">
      </param>
      <param name="authFlags">
      </param>
      <param name="isInstantiatedRemotely">
      </param>
      <param name="proxyPrefab">
      </param>
      <param name="ownerPrefab">
      </param>
      <param name="serverPrefab">
      </param>
      <param name="cellAuthPrefab">
      </param>
      <param name="cellProxyPrefab">
      </param>
      <param name="initialData">
      </param>
    </member>
    <member name="M:uLink.NetworkViewData.SetupNetworkView(uLink.NetworkViewBase)">
      <summary>
            Sets a NetworkView up with this data.
            </summary>
      <param name="nv">
      </param>
    </member>
    <member name="T:uLink.NetworkAuthFlags">
      <summary>
            Used for network settings in Pikko Server.
            </summary>
    </member>
    <member name="F:uLink.NetworkAuthFlags.None">
      <summary>
            None of the flags are set.
            </summary>
    </member>
    <member name="F:uLink.NetworkAuthFlags.DontHandoverInPikkoServer">
      <summary>
            Only available on cell servers; means the automatic handover by the mast algorithm should be disabled.
            </summary>
    </member>
    <member name="T:uLink.NetworkReference`1">
      <summary>
            You can use this struct to hold reference to a networked object based on it's viewID. It's specially useful if the object
            can move between servers and/or if you use Pikko Server, so there is a chance that object goes out of access and comes back.
            </summary>
      <typeparam name="TComponent">This should be the type of the component in the object which you are interested in.
            If you for example work more with the object's Renderer, it should be Renderer. 
            This component will be stored in the <see cref="P:uLink.NetworkReference`1.component" /> property of the object.</typeparam>
    </member>
    <member name="F:uLink.NetworkReference`1.viewID">
      <summary>
            The <see cref="T:uLink.NetworkViewID" /> of the object that we are referencing.
            </summary>
    </member>
    <member name="M:uLink.NetworkReference`1.GetComponent``1">
      <summary>
            Calls the GetComponent method of unity on the referenced object.
            </summary>
      <typeparam name="T">The type of the component which we want to get.</typeparam>
      <returns>The component if found, otherwise null</returns>
    </member>
    <member name="M:uLink.NetworkReference`1.GetComponentInChildren``1">
      <summary>
            Returns the result of a GetComponentInChildren call on the referenced object.
            </summary>
      <typeparam name="T">Type of the component that we are interested in.</typeparam>
      <returns>The component if found, otherwise null</returns>
    </member>
    <member name="M:uLink.NetworkReference`1.#ctor(`0)">
      <summary>
            Creates a NetworkReference instance with the provided component's <see cref="T:uLink.NetworkView" /> as referenced object.
            </summary>
      <param name="component">The component that we want to reference its NetworkView and use it our <see cref="P:uLink.NetworkReference`1.component" /> property</param>
    </member>
    <member name="M:uLink.NetworkReference`1.#ctor(uLink.NetworkView)">
      <summary>
            Creates a NetworkReference instance with the provided <see cref="T:uLink.NetworkView" /> as referenced object.
            The <see cref="P:uLink.NetworkReference`1.component" /> property will be null.
            </summary>
      <param name="networkView">The NetworkView that we want to reference it as a networked object.</param>
    </member>
    <member name="M:uLink.NetworkReference`1.#ctor(uLink.NetworkViewID)">
      <summary>
            Create a NetworkReference instance which points to the object owning the provided <see cref="T:uLink.NetworkViewID" />
            The <see cref="P:uLink.NetworkReference`1.component" /> property will be null.
            </summary>
      <param name="viewID">ViewID of the object that we want to set our reference to it.</param>
    </member>
    <member name="M:uLink.NetworkReference`1.op_Equality(uLink.NetworkReference{`0},uLink.NetworkReference{`0})">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkReference" />s are identical
            </summary>
    </member>
    <member name="M:uLink.NetworkReference`1.op_Inequality(uLink.NetworkReference{`0},uLink.NetworkReference{`0})">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkReference" />s are not identical
            </summary>
    </member>
    <member name="M:uLink.NetworkReference`1.GetHashCode">
      <summary>
            Returns the hash code for this <see cref="T:uLink.NetworkReference" />.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this <see cref="T:uLink.NetworkReference" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkReference`1.Equals(System.Object)">
      <summary>
            Indicates whether this <see cref="T:uLink.NetworkReference" /> and a specified object are equal.
            </summary>
      <returns>
        <c>true</c> if <paramref name="other" /> and this <see cref="T:uLink.NetworkReference" /> are the same type and represent the same value; otherwise, <c>false</c>.
            </returns>
      <param name="other">Another object to compare to. </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkReference`1.CompareTo(uLink.NetworkReference{`0})">
      <summary>
            Compares this instance with another specified <see cref="T:uLink.NetworkViewID" /> object and indicates
            whether this instance precedes, follows, or appears in the same position
            in the sort order as the specified <see cref="T:uLink.NetworkViewID" />.
            </summary>
      <param name="other">The other <see cref="T:uLink.NetworkViewID" />.</param>
      <returns>
            A 32-bit signed integer that indicates whether this instance precedes, follows,
            or appears in the same position in the sort order as the value parameter.
            </returns>
    </member>
    <member name="M:uLink.NetworkReference`1.ToString">
      <summary>
            Returns a formatted string with details on this <see cref="T:uLink.NetworkReference" />.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:uLink.NetworkReference`1.networkView">
      <summary>
            The <see cref="T:uLink.NetworkView" /> that this reference is pointing to. The object might be destroyed or moved to another server.
            </summary>
    </member>
    <member name="P:uLink.NetworkReference`1.exists">
      <summary>
            Returns wether the networked object that we are referencing to exists or not.
            </summary>
    </member>
    <member name="P:uLink.NetworkReference`1.component">
      <summary>
            Returns the component in the referenced networked object which we are interested in and provided it's type as generic parameter.
            </summary>
      <example>
            For example if we have a NetworkReference&lt;Transform&gt; then the component property will return its Transform.
            </example>
    </member>
    <member name="P:uLink.NetworkReference`1.gameObject">
      <summary>
            Returns the Game Object that our referenced object is pointing to.
            </summary>
    </member>
    <member name="P:uLink.NetworkReference`1.transform">
      <summary>
            Returns the transform of the referenced object.
            </summary>
    </member>
    <member name="T:uLink.NetworkReference">
      <summary>
             You can use this struct to hold reference to a networked object based on it's viewID. It's specially useful if the object
             can move between servers and/or if you use Pikko Server, so there is a chance that object goes out of access and comes back.
             </summary>
      <remarks>The generic version is prefered whenever possible.</remarks>
    </member>
    <member name="F:uLink.NetworkReference.viewID">
      <summary>
            The <see cref="T:uLink.NetworkViewID" /> of the object that we hold a reference to.
            </summary>
    </member>
    <member name="M:uLink.NetworkReference.GetComponent``1">
      <summary>
            Calls GetComponent on the object that we are referencing.
            </summary>
      <typeparam name="T">Type of the component that we want to get.</typeparam>
      <returns>The component if found, otherwise null</returns>
    </member>
    <member name="M:uLink.NetworkReference.GetComponentInChildren``1">
      <summary>
            Calls a GetComponentInChildren in the gameObject that we are referencing.
            </summary>
      <typeparam name="T">Type of the component that we want to get.</typeparam>
      <returns>The component if found, otherwise null</returns>
    </member>
    <member name="M:uLink.NetworkReference.#ctor(uLink.NetworkView)">
      <summary>
            Creates a NetworkReference object.
            </summary>
      <param name="networkView">The NetworkView that we want to reference.</param>
    </member>
    <member name="M:uLink.NetworkReference.#ctor(uLink.NetworkViewID)">
      <summary>
            Creates a NetworkReference object.
            </summary>
      <param name="viewID">ViewID of the <see cref="T:uLink.NetworkView" /> that we want to reference.</param>
    </member>
    <member name="M:uLink.NetworkReference.op_Equality(uLink.NetworkReference,uLink.NetworkReference)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkReference" />s are identical
            </summary>
    </member>
    <member name="M:uLink.NetworkReference.op_Inequality(uLink.NetworkReference,uLink.NetworkReference)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkReference" />s are not identical
            </summary>
    </member>
    <member name="M:uLink.NetworkReference.GetHashCode">
      <summary>
            Returns the hash code for this <see cref="T:uLink.NetworkReference" />.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this <see cref="T:uLink.NetworkReference" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkReference.Equals(System.Object)">
      <summary>
            Indicates whether this <see cref="T:uLink.NetworkReference" /> and a specified object are equal.
            </summary>
      <returns>
        <c>true</c> if <paramref name="other" /> and this <see cref="T:uLink.NetworkReference" /> are the same type and represent the same value; otherwise, <c>false</c>.
            </returns>
      <param name="other">Another object to compare to. </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkReference.CompareTo(uLink.NetworkReference)">
      <summary>
            Compares this instance with another specified <see cref="T:uLink.NetworkViewID" /> object and indicates
            whether this instance precedes, follows, or appears in the same position
            in the sort order as the specified <see cref="T:uLink.NetworkViewID" />.
            </summary>
      <param name="other">The other <see cref="T:uLink.NetworkViewID" />.</param>
      <returns>
            A 32-bit signed integer that indicates whether this instance precedes, follows,
            or appears in the same position in the sort order as the value parameter.
            </returns>
    </member>
    <member name="M:uLink.NetworkReference.ToString">
      <summary>
            Returns a formatted string with details on this <see cref="T:uLink.NetworkReference" />.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:uLink.NetworkReference.networkView">
      <summary>
            The <see cref="T:uLink.NetworkView" /> component of the networked object which we hold reference to.
            </summary>
    </member>
    <member name="P:uLink.NetworkReference.exists">
      <summary>
            Returns if this networked object still exists or not. The object might be destroyed or moved to another server.
            </summary>
    </member>
    <member name="P:uLink.NetworkReference.gameObject">
      <summary>
            The GameObject of the object that we reference to.
            </summary>
    </member>
    <member name="P:uLink.NetworkReference.transform">
      <summary>
            The Transform component of the object that we are referencing to.
            </summary>
    </member>
    <member name="T:uLink.NetworkUtility">
      <summary>
            Utility class for handling hostnames and IP addresses.
            </summary>
    </member>
    <member name="M:uLink.NetworkUtility.ResolveAddress(System.String)">
      <summary>
            Tries to resolve and creates an IP address from a string.
            </summary>
      <param name="ipOrHost">The IP address/computer name</param>
      <returns>The created IP address if successful, null otherwise.</returns>
    </member>
    <member name="M:uLink.NetworkUtility.ResolveEndPoint(System.String,System.Int32)">
      <summary>
            Tries to resolve an IP address with it's port from a string.
            </summary>
      <param name="ipOrHostInclPort">IP address with port separated by : as usual.</param>
      <param name="defaultPort">The default port. If the port is not resolvable, this will be used.</param>
      <returns>The IP address if resolved, null otherwise.</returns>
    </member>
    <member name="M:uLink.NetworkUtility.ResolveAddress(System.String[])">
      <summary>
            Resolves a set of IP addresses.
            </summary>
      <param name="ipOrHosts">The array of IP addresses in string</param>
      <returns>The array of resolved IPAddress instances,
            The returned array always have the length of the provided argument, any element should be
            checked for validity.</returns>
    </member>
    <member name="M:uLink.NetworkUtility.ResolveEndPoint(System.String[],System.Int32)">
      <summary>
            Tries to resolve a set of IP addresses with ports.
            </summary>
      <param name="ipOrHostInclPort">The array of IPs and ports separated with : as usual.</param>
      <param name="defaultPort">The default port if the port can not be resolved.</param>
      <returns>An array in length of the provided argument array.
            Each element should be checked for validity.</returns>
    </member>
    <member name="M:uLink.NetworkUtility.ResolveEndPoint(System.Collections.Generic.KeyValuePair{System.String,System.Int32}[])">
      <summary>
            Tries to resolve a set of IP addresses and ports.
            Works just like <see cref="M:uLink.NetworkUtility.ResolveEndPoint(System.String[],System.Int32)" />
            just uses different kinds of arguments.
            </summary>
      <param name="ipOrHostInclOrDefaultPort">The pairs of string addresses and default ports for each address.</param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkUtility.GetLocalAddresses">
      <summary>
            Gets my local IP address (not necessarily external) and subnet mask
            </summary>
    </member>
    <member name="M:uLink.NetworkUtility.IsPublicAddress(uLink.NetworkEndPoint)">
      <summary>
            Returns true if the NetworkEndPoint supplied is a public IP address
            </summary>
      <remarks>
            An IP address is considered public if the IP number is valid and falls outside any of the IP address ranges reserved for private uses by Internet standards groups.
            Private IP addresses are typically used on local networks including home, school and business LANs including airports and hotels.
            </remarks>
    </member>
    <member name="M:uLink.NetworkUtility.IsPublicAddress(System.Net.IPAddress)">
      <summary>
            Returns true if the IPAddress supplied is a public IP address
            </summary>
      <remarks>
            An IP address is considered public if the IP number is valid and falls outside any of the IP address ranges reserved for private uses by Internet standards groups.
            Private IP addresses are typically used on local networks including home, school and business LANs including airports and hotels.
            </remarks>
    </member>
    <member name="M:uLink.NetworkUtility.IsLoopbackAddress(uLink.NetworkEndPoint)">
      <summary>
            Is the address loop back address (address of the local machine).
            </summary>
      <param name="endpoint">
      </param>
      <returns>
        <c>true</c> if the address is for the local machine, <c>false</c> otherwise.</returns>
      <remarks>You can connect to your machine (yourself) using the loop back address.
            It's denoted using 127.0.0.1 or localhost usually.</remarks>
    </member>
    <member name="M:uLink.NetworkUtility.IsLoopbackAddress(System.Net.IPAddress)">
      <summary>
            Is the provided IP address, the loop back address (address of the local machine)
            </summary>
      <param name="ipAddress">
      </param>
      <returns>
      </returns>
      <remarks>You can connect to your machine (yourself) using the loop back address.
            It's denoted using 127.0.0.1 or localhost usually.</remarks>
    </member>
    <member name="M:uLink.NetworkUtility.IsPortAvailable(System.Int32)">
      <summary>
            Returns wether the port is available for binding to/opening.
            </summary>
      <param name="port">
      </param>
      <returns>
        <c>true</c> if no one else opend the port and you can listen to it, <c>false</c> otherwise.</returns>
    </member>
    <member name="M:uLink.NetworkUtility.FindAvailablePort">
      <summary>
            Finds an available port for openning and returns it.
            </summary>
      <returns>A port which is not used by any one and can be used.</returns>
    </member>
    <member name="M:uLink.NetworkUtility.FindAvailablePort(System.Int32,System.Int32)">
      <summary>
            Finds an available port between the range provided.
            </summary>
      <param name="startPort">The starting port range</param>
      <param name="endPort">The ending port range</param>
      <returns>The port number if found, -1 otherwise.</returns>
    </member>
    <member name="M:uLink.NetworkUtility.FindAvailablePort(System.Int32[])">
      <summary>
            Tries to find an available port between the ports in the array.
            </summary>
      <param name="ports">The array of ports which we hope to find an available port between them.</param>
      <returns>The available port number, -1 if no available port found.</returns>
    </member>
    <member name="M:uLink.NetworkUtility.GetStatusString(uLink.NetworkPeerType,uLink.NetworkStatus)">
      <summary>
            Returns a string representing the type of the peer and network status that the peer is in.
            </summary>
      <param name="peerType">
      </param>
      <param name="status">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkUtility.GetErrorString(uLink.NetworkConnectionError)">
      <summary>
            Returns a string representing a <see cref="T:uLink.NetworkConnectionError" /></summary>
      <param name="error">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:uLink.NetworkLog">
      <summary>
             Class for configuring uLink logging.
             </summary>
      <remarks>
             The best way to get started with logging in uLink is to use the Editor menu: uLink - Edit Settings. 
             There it is possible to configure logging level per category and use the generated output to debug most problems.
             By default the log messages are written to the Unity console window in the editor or the log file output_log.txt when 
             running a build outside the editor.
             <para>
             Use this class to go one step further and control the log settings in your own code. Also use it to 
             replace the 4 public Writers with your own faster implementations: 
             <see cref="F:uLink.NetworkLog.errorWriter" />, <see cref="F:uLink.NetworkLog.warningWriter" />, <see cref="F:uLink.NetworkLog.infoWriter" />, <see cref="F:uLink.NetworkLog.debugWriter" /> 
             with your own implementations it is possible to log events to 
             screen or file(s) or database or whatever you like. 
             </para><para>
             Finally, it is possible to add your own logging categories like “Trading”, “Cheating attempts” or “Level loding” 
             and set the log level individually for these categories.
             </para></remarks>
      <example> 
             This example shows how to create and use your own log categories:
             <code>
             using UnityEngine;
             using System.Collections;
             public class CustomLog : MonoBehaviour 
             {
                //Define your own log categories like this
                public const uLink.NetworkLogFlags CHEAT_ATTEMPTS = uLink.NetworkLogFlags.UserDefined1;
                public const uLink.NetworkLogFlags TRADE_EVENT = uLink.NetworkLogFlags.UserDefined2;
                public const uLink.NetworkLogFlags LEVEL_LOAD_EVENT = uLink.NetworkLogFlags.UserDefined3;
            
                void Start()
                {
                    //Set the log level for cheat attempts to the highest = Debug    
                    uLink.NetworkLog.SetLevel(CHEAT_ATTEMPTS, uLink.NetworkLogLevel.Debug);
            
                    //Do some debug logging
                    for (int i = 1; i != 5; i++)
                    {
                        uLink.NetworkLog.Debug(CHEAT_ATTEMPTS, "Detected cheat attempt nr ", i, " in the demo code.");
                    }
                }
             }
             </code></example>
    </member>
    <member name="F:uLink.NetworkLog.defaultErrorWriter">
      <summary>
            The default method which used for error logs.
            </summary>
    </member>
    <member name="F:uLink.NetworkLog.defaultWarningWriter">
      <summary>
            The default method for writing warning logss.
            </summary>
    </member>
    <member name="F:uLink.NetworkLog.defaultInfoWriter">
      <summary>
            The default method for writing info logs.
            </summary>
    </member>
    <member name="F:uLink.NetworkLog.defaultDebugWriter">
      <summary>
            The default method for writing debug logs.
            </summary>
    </member>
    <member name="F:uLink.NetworkLog.errorWriter">
      <summary>
            The delegate writing error messages. Default implementation send output to the Editor console / output_log.txt file. 
            </summary>
      <remarks>Look at <see cref="T:uLink.NetworkLog.Writer" /> for code example replacing the default Writer.</remarks>
    </member>
    <member name="F:uLink.NetworkLog.warningWriter">
      <summary>
            The delegate writing warning messages. Default implementation send output to the Editor console / output_log.txt file. 
            </summary>
      <remarks>Look at <see cref="T:uLink.NetworkLog.Writer" /> for code example replacing the default Writer.</remarks>
    </member>
    <member name="F:uLink.NetworkLog.infoWriter">
      <summary>
            The delegate writing info messages. Default implementation send output to the Editor console / output_log.txt file. 
            </summary>
      <remarks>Look at <see cref="T:uLink.NetworkLog.Writer" /> for code example replacing the default Writer.</remarks>
    </member>
    <member name="F:uLink.NetworkLog.debugWriter">
      <summary>
            The delegate writing debug messages. Default implementation send output to the Editor console / output_log.txt file. 
            </summary>
      <remarks>Look at <see cref="T:uLink.NetworkLog.Writer" /> for code example replacing the default Writer.</remarks>
    </member>
    <member name="F:uLink.NetworkLog.minLevel">
      <summary>
            The minimum level for all logging categories. This can be overruled by setting a detailed log level for an individual category to a higher log level via <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" />.
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkLogLevel.Warning" /></value>
    </member>
    <member name="M:uLink.NetworkLog.GetPrefs">
      <summary>
            Gets the NetworkLog properties from <see cref="T:uLink.NetworkPrefs" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkLog.SetPrefs">
      <summary>
            Sets the NetworkLog properties in <see cref="T:uLink.NetworkPrefs" />.
            </summary>
      <remarks>
            The method can't update the saved values in the persistent <see cref="F:uLink.NetworkPrefs.resourcePath" /> file,
            because that assumes the file is editable (i.e. the running project isn't built) and would require file I/O permission.
            Calling this will only update the values in memory.
            </remarks>
    </member>
    <member name="M:uLink.NetworkLog.Debug(uLink.NetworkLogFlags,System.Object[])">
      <summary>
            Sends a log message to the delegate <see cref="F:uLink.NetworkLog.debugWriter" /> if the <see cref="F:uLink.NetworkLogLevel.Debug" /> log level for the specifed categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
      <param name="flags">The categories this log message belongs to</param>
      <param name="args">The objects that are to be concatenated to a log message if the debug log level for the flags is set</param>
      <example>Example code for writing a message like "The server has now received 88 Fire RPCs from player Paul55".
            <code>
            uLink.NetworkLog.Debug(uLink.NetworkLogFlags.Server, "The server has now received ", numberOfFireRPCs, " Fire RPCs from player ", playerName);
            </code></example>
      <remarks>Please note that it is important to NOT use string concatenation with + to compose the log message. 
            Instead send the objects individually just like the example code provided here. 
            Otherwise you will lose performance. The concatenation would be executed even if the log level for the flags are 
            turned off, and that is a waste of CPU resources.</remarks>
    </member>
    <member name="M:uLink.NetworkLog.Info(uLink.NetworkLogFlags,System.Object[])">
      <summary>
            Sends a log message to the delegate <see cref="F:uLink.NetworkLog.infoWriter" /> if the <see cref="F:uLink.NetworkLogLevel.Info" /> log level for the specifed categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
      <param name="flags">The categories this log message belongs to</param>
      <param name="args">The objects that are to be concatenated to a log message if the info log level for the flags is set</param>
      <example>Example code for writing a message like "The server has now received 88 Fire RPCs from player Paul55".
            <code>
            uLink.NetworkLog.Info(uLink.NetworkLogFlags.Server, "The server has now received ", numberOfFireRPCs, " Fire RPCs from player ", playerName);
            </code></example>
      <remarks>Please note that it is important NOT to use string concatenation with + to compose a nice log message. 
            Instead send the arguments individually just like the example code provided here. 
            Otherwise you will lose performance. The concatenation would be executed even if the logging 
            is turned off, and that is a waste of CPU resources.</remarks>
    </member>
    <member name="M:uLink.NetworkLog.Warning(uLink.NetworkLogFlags,System.Object[])">
      <summary>
            Sends a log message to the delegate <see cref="F:uLink.NetworkLog.warningWriter" /> if the <see cref="F:uLink.NetworkLogLevel.Warning" /> log level for the specifed categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
      <param name="flags">The categories this log message belongs to</param>
      <param name="args">The objects that are to be concatenated to a log message if the info log level for the flags is set</param>
      <example>Example code for writing a message like "The server has now received 88 Fire RPCs from player Paul55".
            <code>
            uLink.NetworkLog.Warning(uLink.NetworkLogFlags.Server, "The server has now received ", numberOfFireRPCs, " Fire RPCs from player ", playerName);
            </code></example>
      <remarks>Please note that it is important NOT to use string concatenation with + to compose a nice log message. 
            Instead send the arguments individually just like the example code provided here. 
            Otherwise you will lose performance. The concatenation would be executed even if the logging 
            is turned off, and that is a waste of CPU resources.</remarks>
    </member>
    <member name="M:uLink.NetworkLog.Error(uLink.NetworkLogFlags,System.Object[])">
      <summary>
            Sends a log message to the delegate <see cref="F:uLink.NetworkLog.errorWriter" /> if the <see cref="F:uLink.NetworkLogLevel.Error" /> log level for the specifed categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
      <param name="flags">The categories this log message belongs to</param>
      <param name="args">The objects that are to be concatenated to a log message if the info log level for the flags is set</param>
      <example>Example code for writing a message like "The server received an illegal Fire RPCs from player Paul55".
            <code>
            uLink.NetworkLog.Error(uLink.NetworkLogFlags.Server, "The server received an illegal Fire RPCs from player ", playerName);
            </code></example>
      <remarks>Please note that it is important NOT to use string concatenation with + to compose a nice log message. 
            Instead send the arguments individually just like the example code provided here. 
            Otherwise you will lose performance. The concatenation would be executed even if the logging 
            is turned off, and that is a waste of CPU resources.</remarks>
    </member>
    <member name="M:uLink.NetworkLog.HasLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)">
      <summary>
            Returns true if the the categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)">
      <summary>
            Sets a detailed logging level for the specified categories (flags). If the categories (flags) is set to a lower log level than <see cref="F:uLink.NetworkLog.minLevel" /> then <see cref="F:uLink.NetworkLog.minLevel" /> overrules the detailed log level when logging.
            </summary>
    </member>
    <member name="M:uLink.NetworkLog.GetMaxLevel(uLink.NetworkLogFlags)">
      <summary>
            Gets the highest detailed log level configured for any of the log categories (flags), where 
            <see cref="F:uLink.NetworkLogLevel.Off" /> is the lowest and <see cref="F:uLink.NetworkLogLevel.Debug" /> is the highest.
            </summary>
    </member>
    <member name="M:uLink.NetworkLog.GetMinLevel(uLink.NetworkLogFlags)">
      <summary>
            Gets the lowest detailed log level configured for any of the log categories (flags), where 
            <see cref="F:uLink.NetworkLogLevel.Off" /> is the lowest and <see cref="F:uLink.NetworkLogLevel.Debug" /> is the highest.
            </summary>
    </member>
    <member name="M:uLink.NetworkLog.IsDebugLevel(uLink.NetworkLogFlags)">
      <summary>
            Is the category in debug level enabled? 
            </summary>
      <param name="flags">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkLog.IsInfoLevel(uLink.NetworkLogFlags)">
      <summary>
            Is the category in info level?
            </summary>
      <param name="flags">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkLog.IsWarningLevel(uLink.NetworkLogFlags)">
      <summary>
            Is the category in warning level?
            </summary>
      <param name="flags">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkLog.IsErrorLevel(uLink.NetworkLogFlags)">
      <summary>
            Is the category in error level?
            </summary>
      <param name="flags">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:uLink.NetworkLog.errorFlags">
      <summary>
            Gets or sets the log categories for the <see cref="F:uLink.NetworkLog.errorWriter" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkLog.warningFlags">
      <summary>
            Gets or sets the log categories for the <see cref="F:uLink.NetworkLog.warningWriter" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkLog.infoFlags">
      <summary>
            Gets or sets the log categories for the <see cref="F:uLink.NetworkLog.infoWriter" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkLog.debugFlags">
      <summary>
            Gets or sets the log categories for the <see cref="F:uLink.NetworkLog.debugWriter" />.
            </summary>
    </member>
    <member name="T:uLink.NetworkLog.Writer">
      <summary>
            Implement one or several new delegates if there is a need to replace the default Writers in this class. 
            </summary>
      <example>
            In your own implementation you can choose another destination for log messages. 
            This example code shows how to send log messages to a file.
            <code>
            using UnityEngine;
            using System.Collections;
            using System.IO;
            
            public class CustomFileLog : MonoBehaviour 
            {
                public string logFileName = @"c:\temp\MyLog.txt";
            
                void Start()
                {
                    //This code replaces the default debugWriter with a new delegate
                    uLink.NetworkLog.debugWriter = delegate(uLink.NetworkLogFlags flags, object[] args) 
                    {
                        string line = System.DateTime.Now + ", " + uLink.NetworkLogUtility.ToString(args) + "\r\n";
                        File.AppendAllText(logFileName, line); 
                    };
            
                    //Set the level to Debug for the category uLink.NetworkLogFlags.Server
                    uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags.Server, uLink.NetworkLogLevel.Debug);
            
                    //Do some debug logging to the file
                    for (int i = 1; i != 5; i++)
                    {
                        uLink.NetworkLog.Debug(uLink.NetworkLogFlags.Server, "Hello ", i, " from demo code.");
                    }
                }
            }
            </code></example>
    </member>
    <member name="T:uLink.NetworkP2PConfig">
      <summary>
            Enables configuration of low-level network parameters, like connection timeouts, inactivity timeouts, ping frequency
            and MTU (Maximum Transmission Unit). See <see cref="P:uLink.Network.config" />. 
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PConfig.maximumTransmissionUnit">
      <summary>
            Gets or sets how many data bytes that can maximally be sent using a single UDP packet.
            This can be set independently for the client and the server.
            Only modify this if you know what you are doing. 
            The default value 1400 has been carefully chosen for optimal speed and 
            throughput in most link layers in IP networks. 
            The value 1400 will ensure that UDP packets with uLink traffic (data and all headders) fit into one single 
            ethernet frame (1500 max) and thus the packet loss risk will be minimal for every UDP packet.
            Ethernet is a very common link layer in modern IP networks.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PConfig.timeBetweenPings">
      <summary>
            Gets or sets the number of seconds between pings.
            This can be set independently for the client and the server.
            Default value is 3 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PConfig.timeoutDelay">
      <summary>
            Gets or sets the time in seconds before a connection times out when no network packets are received from remote host.
            This can be set independently for the client and the server. Default value is 30 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PConfig.handshakeRetriesMaxCount">
      <summary>
            Gets or sets the maximum number of re-attempts to connect to the remote host before giving up.
            This only has meaning for the client, or the connecting peer. Default value is 5 attempts.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PConfig.handshakeRetryDelay">
      <summary>
            Gets or sets the number of seconds between handshake attempts.
            This only has meaning for the client, or the connecting peer.
            Default value is 2.5 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PConfig.allowInternalUnconnectedMessages">
      <summary>
            If set to true, you can use the discovery feature to broadcast messages on LAN to find
            other peers, If set to false, discovery will not work but DOS/D-DOS attacks can not use this capability
            to make a lot of traffic on the local network.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PConfig.batchSendAtEndOfFrame">
      <summary>
            Determines whether uLink should queue all outgoing messages until the end of frame.
            </summary>
      <remarks>
            Batching lets uLink do more optimizations such as fitting multiple messages in a single packet,
            if they are not too big. There will be a slight CPU and bandwidth cost for turning off batching,
            how much depends on the amount and type of messages.
            But one benefit of disabling it, is that you then know the message has been sent after <see cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
            has returned and CPU profiling of RPCs is more accurate, in Unity's Profiler. 
            </remarks>
    </member>
    <member name="T:uLink.NetworkGroup">
      <summary>
            This class represents a network groups.
            Groups allow you to filter messages which a player receives or not.
            You can have network aware objects in specific groups and then only players which are members of the group
            will receive state sync and RPCs from the object. Also based on group settings, you can make network aware objects
            of a group to only appear in the players in the group.
            </summary>
      <remarks> You usually use int numbers to represent a group.
            See the manual page for groups for more information.
            </remarks>
    </member>
    <member name="F:uLink.NetworkGroup.unassigned">
      <summary>
            Represents an special network group which all players are always part of.
            If you set the group of an object as 0 in <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />, the object has no groups
            or it's group value is unassigned.
            </summary>
    </member>
    <member name="F:uLink.NetworkGroup.max">
      <summary>
            Maximum <see cref="P:uLink.NetworkGroup.id" /> value a assigned group can have.
            </summary>
    </member>
    <member name="F:uLink.NetworkGroup.min">
      <summary>
            Minimum <see cref="P:uLink.NetworkGroup.id" /> value a assigned group can have.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:uLink.NetworkGroup" /> struct.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.SetFlags(uLink.NetworkGroupFlags)">
      <summary>
            Sets the settings of the group.
            </summary>
      <param name="flags">The settings of the group as a set of flags.</param>
    </member>
    <member name="M:uLink.NetworkGroup.GetFlags">
      <summary>
            Gets a group's settings.
            </summary>
      <returns>A <see cref="T:uLink.NetworkGroupFlags" /> representing the group settings.</returns>
    </member>
    <member name="M:uLink.NetworkGroup.op_Equality(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkGroup" />s are identical
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_Inequality(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkGroup" />s are not identical
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_GreaterThanOrEqual(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkGroup" /> is greater than or equal to the right <see cref="T:uLink.NetworkGroup" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_LessThanOrEqual(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkGroup" /> is less than or equal to the right <see cref="T:uLink.NetworkGroup" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_GreaterThan(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkGroup" /> is greater than the right <see cref="T:uLink.NetworkGroup" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_LessThan(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkGroup" /> is less than the right <see cref="T:uLink.NetworkGroup" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.GetHashCode">
      <summary>
            Returns the hash code for this <see cref="T:uLink.NetworkGroup" />.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this <see cref="T:uLink.NetworkGroup" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkGroup.Equals(System.Object)">
      <summary>
            Indicates whether this <see cref="T:uLink.NetworkViewID" /> and a specified object are equal.
            </summary>
      <returns>
        <c>true</c> if <paramref name="other" /> and this <see cref="T:uLink.NetworkGroup" /> are the same type and represent the same value; otherwise, <c>false</c>.
            </returns>
      <param name="other">Another object to compare to. </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkGroup.CompareTo(uLink.NetworkGroup)">
      <summary>
            Compares this instance with another specified <see cref="T:uLink.NetworkGroup" /> object and indicates
            whether this instance precedes, follows, or appears in the same position
            in the sort order as the specified <see cref="T:uLink.NetworkGroup" />.
            </summary>
      <param name="other">The other <see cref="T:uLink.NetworkGroup" />.</param>
      <returns>
            A 32-bit signed integer that indicates whether this instance precedes, follows,
            or appears in the same position in the sort order as the value parameter.
            </returns>
    </member>
    <member name="M:uLink.NetworkGroup.ToString">
      <summary>
            Returns a formatted string with details on this <see cref="T:uLink.NetworkGroup" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:uLink.NetworkGroup.id">
      <summary>
            This is the unique ID number for this network group.
            </summary>
      <remarks>
            You usually use this value instead of a NetworkGroup struct. 
            </remarks>
    </member>
    <member name="T:uLink.NetworkP2PSpace">
      <summary>
            The frame of reference for positions and rotations when handing objects over is specified by this.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PSpace.World">
      <summary>
            World space should be used. 
            So the positions and rotations provided by unity as world space values will be used directly.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PSpace.NetworkP2P">
      <summary>
            The positions and rotations will be interpreted as if the object with <see cref="F:uLink.NetworkP2PSpace.NetworkP2P" /> attached was the origin.
            </summary>
    </member>
    <member name="T:uLink.NetworkP2PHandoverInstance">
      <summary>
            We use this to carry over information about a handover.
            </summary>
      <remarks>Read more about handovers in the peer to peer section of the manual.
            <para>
            You mostly use this class when working with handover API and events.
            </para></remarks>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.position">
      <summary>
            The Position of the object being handed over.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.rotation">
      <summary>
            The rotation of the object being handed over.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.relativeTo">
      <summary>
            The space origin (frame of reference) which the object position and rotation will be calculated based on it.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.remoteViewID">
      <summary>
            The view id of the object being handed over.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.group">
      <summary>
            The <see cref="T:uLink.NetworkGroup" /> of the object being handed over.
            You usually use this as an int.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.authFlags">
      <summary>
            The network auth flags used for the object.
            This is used for handovers in Pikko Server for now.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.isInstantiatedRemotely">
      <summary>
            Is the object instantiated remotely or we are the caller of its instantiate call.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.proxyPrefab">
      <summary>
            Name of the prefab which is used at proxy role for the object being handed over.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.ownerPrefab">
      <summary>
            Name of the prefab which is used at owner role for the object being handed over.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.serverPrefab">
      <summary>
            Name of the prefab which is used at server role for the object being handed over.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.cellAuthPrefab">
      <summary>
            Name of the prefab which is used at cell authority role for the object being handed over.
            </summary>
      <remarks>This is used with cell servers of Pikko Server.</remarks>
    </member>
    <member name="F:uLink.NetworkP2PHandoverInstance.cellProxyPrefab">
      <summary>
            Name of the prefab which is used at cell proxy role for the object being handed over.
            </summary>
      <remarks>This is used with cell servers of Pikko server.</remarks>
    </member>
    <member name="M:uLink.NetworkP2PHandoverInstance.#ctor">
      <summary>
            Creates and initializes a new instance of NetworkP2PHandoverInstance.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PHandoverInstance.#ctor(uLink.NetworkViewBase)">
      <summary>
            Creates and initializes a new instance of NetworkP2PHandoverInstance.
            </summary>
      <param name="networkView">The network view to use for the object being handovered.</param>
    </member>
    <member name="M:uLink.NetworkP2PHandoverInstance.#ctor(uLink.NetworkViewBase,uLink.NetworkP2PBase)">
      <summary>
            Creates and initializes a new instance of NetworkP2PHandoverInstance.
            </summary>
      <param name="networkView">The network view to use for the object being handovered.</param>
      <param name="p2p">The NetworkP2P component used for handing this object over.</param>
    </member>
    <member name="M:uLink.NetworkP2PHandoverInstance.#ctor(uLink.NetworkViewBase,uLink.NetworkP2PBase,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
            Creates and initializes a new instance of NetworkP2PHandoverInstance.
            </summary>
      <param name="networkView">The network view to use for the object being handovered.</param>
      <param name="p2p">The NetworkP2P component used for handing this object over.</param>
      <param name="offsetPos">Offset position of the object compared to the <c>p2p</c> which is handing it over.</param>
      <param name="offsetRot">Offset rotation of the object compared to the <c>p2p</c> which is handing it over.</param>
    </member>
    <member name="M:uLink.NetworkP2PHandoverInstance.#ctor(uLink.NetworkViewBase,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkP2PSpace)">
      <summary>
            Creates and initializes a new instance of NetworkP2PHandoverInstance.
            </summary>
      <param name="networkView">The network view to use for the object being handovered.</param>
      <param name="position">Position of the object being handovered.</param>
      <param name="rotation">Rotation to use for the object being handovered.</param>
      <param name="relativeTo">The space that position and rotation should be relative to.</param>
    </member>
    <member name="M:uLink.NetworkP2PHandoverInstance.DontInstantiateOnConnected">
      <summary>
            This will cause the object to not be instantiated when the object owner connected to the new server which the object
            is handovered to.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PHandoverInstance.InstantiateNow(uLink.NetworkPlayer)">
      <summary>
            Instantiates the handovered object with the provided network player as owner.
            </summary>
      <param name="player">The player which should own the object.</param>
    </member>
    <member name="P:uLink.NetworkP2PHandoverInstance.networkP2P">
      <summary>
            Returns the <see cref="T:uLink.NetworkP2P" /> which is handing this object over.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PHandoverInstance.networkView">
      <summary>
            Gets or sets the <see cref="T:uLink.NetworkView" /> of the object being handed over.
            </summary>
    </member>
    <member name="T:uLink.SerializedAssetBundle">
      <summary>
            This class represents a serialized asset bundle which you can send over the network.
            This is used internally in uLink but also made public because its functionality can be useful for users as well.
            </summary>
    </member>
    <member name="F:uLink.SerializedAssetBundle.download">
      <summary>
            The WWW instance which is downloading our asset bundle.
            </summary>
    </member>
    <member name="M:uLink.SerializedAssetBundle.#ctor(System.String)">
      <summary>
            Creates an instance of SerializedAssetBundle class and tries to download an asset bundle from the
            provided URL.
            </summary>
      <param name="url">The url to download the asset bundle from</param>
      <remarks>
            This overload of the constructor simply instantiates a WWW instance so it doesn't use cache.
            If you want to use caching then use <see cref="!:SerializedAssetBundle(UnityEngine.WWWW,System.Int32)" /></remarks>
    </member>
    <member name="M:uLink.SerializedAssetBundle.#ctor(System.String,System.Int32)">
      <summary>
            Creates an instance of SerializedAssetBundle and tries to download or get the asset bundle
            from the cache.
            </summary>
      <param name="url">The url which the asset bundle is stored in.</param>
      <param name="version">Version of the asset bundle.</param>
      <remarks>
            Read Unity's documentation on caching of asset bundles and WWW.LoadFromCacheOrDownload method.
            </remarks>
    </member>
    <member name="M:uLink.SerializedAssetBundle.#ctor(UnityEngine.WWW)">
      <summary>
            Creates an instance of SerializedAssetBundle and stores
            the provided WWW instance as the source of the asset bundle.
            </summary>
      <param name="download">The WWW instance which is downloading the asset bundle or contains it.</param>
    </member>
    <member name="M:uLink.SerializedAssetBundle.WaitForDownload">
      <summary>
            Returns the WWW instance in the class to wait for it until it finishes its job.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.SerializedAssetBundle.WaitForCreateRequest">
      <summary>
            Returns a request object which you can wait on it until Unity creates
            the asset bundle from the stored bytes.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.SerializedAssetBundle.#ctor(System.Byte[])">
      <summary>
            Creates an instance of SerializedAssetBundle from the bytes provided.
            </summary>
      <param name="bytes">The byte array containing the asset bundle.</param>
            M<remarks>
            You might want to use this in multiple situations. 
            You can store the bundle in a database as a byte array (BLOB object), you might download encoded bundle and decode it
            to a byte array and ...
            <para>
            Specially you might be interested in using Riak (uGameDB) for storing your bundles in a key value pair
            instead of a regular file system. It can handle a great amount of traffic because the data is mostly read only
            and you can use multiple nodes. However using storage services like Amazon S3 also can be interesting if you
            want to use the caching feature easily.
            </para></remarks></member>
    <member name="P:uLink.SerializedAssetBundle.assetBundle">
      <summary>
            The asset bundle that this class holds.
            </summary>
    </member>
    <member name="P:uLink.SerializedAssetBundle.createRequest">
      <summary>
            Tries to create a request for creating an asset bundle from the bytes stored in this class on memory.
            The bytes can be downloaded or sent by you based on the constructor you use to create an instance
            of this class.
            </summary>
    </member>
    <member name="P:uLink.SerializedAssetBundle.bytes">
      <summary>
            Returns the asset bundle's raw bytes stored in this instance.
            </summary>
    </member>
    <member name="T:uLink.NetworkPrefs">
      <summary>
            Class used by the uLink to read settings (which can be edited in the uLink editor menu).
            </summary>
      <remarks>
            The class can't save/edit any values in the actual persistent <see cref="F:uLink.NetworkPrefs.resourcePath" /> file,
            because that assumes the file is editable (i.e. the running project isn't built) and would require file I/O permission.
            Calling any Set methods in the class, will only update the values in memory.
            </remarks>
    </member>
    <member name="F:uLink.NetworkPrefs.resourcePath">
      <summary>
            The resource path used by the class to load the persistent file, in which the values are stored.
            </summary>
    </member>
    <member name="M:uLink.NetworkPrefs.ToConfigString">
      <summary>
            Returns a network configuration file as a string based on the current configuration.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkPrefs.Reload">
      <summary>
            Reloads the values from the persistent <see cref="F:uLink.NetworkPrefs.resourcePath" /> file.
            </summary>
    </member>
    <member name="M:uLink.NetworkPrefs.DeleteAll">
      <summary>
            Deletes all loaded values in NetworkPrefs.
            </summary>
    </member>
    <member name="M:uLink.NetworkPrefs.HasKey(System.String)">
      <summary>
            Returns if a key exists or not.
            </summary>
      <param name="key">The key which you want to see if exists or not.</param>
      <returns>If the key exists or not.</returns>
    </member>
    <member name="M:uLink.NetworkPrefs.DeleteKey(System.String)">
      <summary>
            Deletes the key if exists.
            </summary>
      <param name="key">The key which you want to delete.</param>
      <returns>
        <c>true</c> if the key existed and it could delete it, <c>false</c> if the key doesn't exist.</returns>
    </member>
    <member name="M:uLink.NetworkPrefs.GetString(System.String)">
      <summary>
            Gets the value of a key as a string.
            </summary>
      <param name="key">The key to get the value of.</param>
      <returns>The value of the key, empty string if the key doesn't exist.</returns>
    </member>
    <member name="M:uLink.NetworkPrefs.GetString(System.String,System.String)">
      <summary>
            Returns the value of a key as a string.
            </summary>
      <param name="key">
      </param>
      <param name="defaultValue">
      </param>
      <returns>The value of the key if exists, otherwise the default value.</returns>
    </member>
    <member name="M:uLink.NetworkPrefs.SetString(System.String,System.String)">
      <summary>
            Sets the value of a key as a string.
            </summary>
      <param name="key">The key to set its value.</param>
      <param name="value">The value to set.</param>
    </member>
    <member name="M:uLink.NetworkPrefs.TryGetString(System.String,System.String@)">
      <summary>
            Tries to get the value of a key as a string.
            </summary>
      <param name="key">The key to get its value.</param>
      <param name="value">The variable which will contain the value if the key exists.</param>
      <returns>
        <c>true</c> if the key exists, <c>false</c> otherwise.</returns>
    </member>
    <member name="M:uLink.NetworkPrefs.Get(System.String,System.String)">
      <summary>
            Returns the value of a key as a string.
            </summary>
      <param name="key">
      </param>
      <param name="defaultValue">
      </param>
      <returns>The value of the key if exists, otherwise the default value.</returns>
    </member>
    <member name="M:uLink.NetworkPrefs.TryGet(System.String,System.String@)">
      <summary>
            Tries to get the value of a key as a string.
            </summary>
      <param name="key">The key to get its value.</param>
      <param name="value">The variable which will contain the value if the key exists.</param>
      <returns>
        <c>true</c> if the key exists, <c>false</c> otherwise.</returns>
    </member>
    <member name="M:uLink.NetworkPrefs.Set(System.String,System.String)">
      <summary>
            Sets the value of a key as a string.
            </summary>
      <param name="key">The key to set its value.</param>
      <param name="value">The value to set.</param>
    </member>
    <member name="T:uLink.NetworkInstantiateArgs">
      <summary>
            This struct contains the values that are sent to instantiators for instantiating a network aware object.
            </summary>
      <remarks>
            See <see cref="T:uLink.NetworkInstantiator" /> and <see cref="T:uLink.NetworkInstantiatorUtility" /> and <see cref="F:uLink.NetworkView.instantiator" /></remarks>
    </member>
    <member name="F:uLink.NetworkInstantiateArgs.position">
      <summary>
            Position of the object to be instantiated.
            </summary>
    </member>
    <member name="F:uLink.NetworkInstantiateArgs.rotation">
      <summary>
            Rotation of the object to be instantiated
            </summary>
    </member>
    <member name="F:uLink.NetworkInstantiateArgs.data">
      <summary>
            All network related data like ViewID, owner, prefab name and ... which you need to instantiate the object.
            </summary>
    </member>
    <member name="M:uLink.NetworkInstantiateArgs.#ctor(UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkViewID,uLink.NetworkPlayer,uLink.NetworkGroup,System.String,System.String,System.String,System.String,System.String,uLink.NetworkAuthFlags,System.Boolean,uLink.BitStream)">
      <summary>
            Creates and initializes a new instance of NetworkInstantiateArgs.
            </summary>
      <param name="position">
      </param>
      <param name="rotation">
      </param>
      <param name="viewID">
      </param>
      <param name="owner">
      </param>
      <param name="group">
      </param>
      <param name="proxyPrefab">
      </param>
      <param name="ownerPrefab">
      </param>
      <param name="serverPrefab">
      </param>
      <param name="cellAuthPrefab">
      </param>
      <param name="cellProxyPrefab">
      </param>
      <param name="authFlags">
      </param>
      <param name="isInstantiatedRemotely">
      </param>
      <param name="initialData">
      </param>
    </member>
    <member name="M:uLink.NetworkInstantiateArgs.SetupNetworkView(uLink.NetworkViewBase)">
      <summary>
            Sets up a NetworkView with the info in this instance of NetworkInstantiateArgs.
            </summary>
      <param name="nv">The NetworkView that we want to setup.</param>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.viewID">
      <summary>
            ViewID of the object to be instantiated.
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.owner">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> who owns the object.
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.group">
      <summary>
            The group that this object is a member of.
            UnAssigned/0 means the object is in no group.
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.authFlags">
      <summary>
            The network settings of the object about Pikko Server handovers and ...
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.isInstantiatedRemotely">
      <summary>
            Is this object instantiated remotely or this player is the caller of it's <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /></summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.proxyPrefab">
      <summary>
            The prefab which is used for proxy role for this object.
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.ownerPrefab">
      <summary>
            The prefab which is used for owner role for this object.
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.serverPrefab">
      <summary>
            The prefab which will be used on the server for this object.
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.cellAuthPrefab">
      <summary>
            The prefab which is used on the cell server which has authority on this object.
            Used for Pikko Server only.
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.cellProxyPrefab">
      <summary>
            The prefab which is used on cell servers other than the one which has authority on the object.
            Used for Pikko Server only.
            </summary>
    </member>
    <member name="P:uLink.NetworkInstantiateArgs.initialData">
      <summary>
            The initial data sent in the Instantiate call.
            </summary>
    </member>
    <member name="T:uLink.EnterLicenseKey">
      <summary>
            This component can be used for entering the uLink license key in your game server.
            The key should not be known in clients and should not be in any of the executables which clients have access to, 
            no matter if it's a windows exe, android apk or a web player .unity3d file.
            </summary>
      <remarks>
            If you are using a trial version, you need a license key for releasing your game and you should buy the license from MuchDifferent.
            </remarks>
    </member>
    <member name="T:uLink.MonoBehaviour">
      <summary>
            Base class to inherit from when you do C# scripts that need to access
            the neworkView for a GameObject. 
            </summary>
      <remarks>It is very convenient to write C# scripts that have access to the property with
            the name networkView. To use this functionality, make your script class extend 
            uLink.MonoBehavior instead of using the MonoBehaviour included in Unity. In addition,
            the two properties networkP2P and role will be accessible. Also transform and gameObject properties will cache their results and will be faster than Unity's ones.</remarks>
    </member>
    <member name="P:uLink.MonoBehaviour.gameObject">
      <summary>
            Gets the GameObject fast without calling native code.
            </summary>
    </member>
    <member name="P:uLink.MonoBehaviour.transform">
      <summary>
            Gets the transform fast without a lookup and without calling native code.
            </summary>
    </member>
    <member name="P:uLink.MonoBehaviour.networkView">
      <summary>
            Gets the network view fast without a lookup and without calling native code.
            </summary>
    </member>
    <member name="P:uLink.MonoBehaviour.networkP2P">
      <summary>
            Gets the networkP2P fast without a lookup and without calling native code.
            </summary>
    </member>
    <member name="P:uLink.MonoBehaviour.role">
      <summary>
            Gets the role this peer/host has for this GameObject.
            </summary>
    </member>
    <member name="F:uLink.EnterLicenseKey.licenseKey">
      <summary>
            The License key that you want to use for your game server.
            </summary>
    </member>
    <member name="T:uLink.PikkoServer">
      <summary>
            The central class in uLink for PikkoServer operations.
            </summary>
    </member>
    <member name="F:uLink.PikkoServer.connectToPikkoServer">
      <summary>
            This option has been deprecated and will be removed in the future.
            </summary>
    </member>
    <member name="M:uLink.PikkoServer.TriggerHandover(uLink.NetworkView,uLink.NetworkPlayer)">
      <summary>
            Requests PikkoServer to asynchronously carry out a handover as if the mast algorithm had decided it.
            For this operation to have any effect, NetworkAuthFlags.DontHandoverInPikkoServer must be set.
            On failure PikkoServer will silently reject the request.
            </summary>
      <param name="nv">The NetworkView of the object to be handed over.</param>
      <param name="targetCell">The cell server the object should be handed over to.</param>
    </member>
    <member name="M:uLink.PikkoServer.TriggerHandover(uLink.NetworkViewID,uLink.NetworkPlayer)">
      <summary>
            Requests PikkoServer to asynchronously carry out a handover as if the mast algorithm had decided it.
            For this operation to have any effect, NetworkAuthFlags.DontHandoverInPikkoServer must be set.
            On failure PikkoServer will silently reject the request.
            </summary>
      <param name="viewID">The NetworkViewID of the object to be handed over.</param>
      <param name="targetCell">The cell server the object should be handed over to.</param>
    </member>
    <member name="P:uLink.PikkoServer.cellPosition">
      <summary>
            Gets the position of this cell server in the mast algorithm. (Updated only if PikkoServer has been configured to do so.)
            </summary>
    </member>
    <member name="T:uLink.ServerAuthentication">
      <summary>
            This component can be used for initializing security on the client and server.
            </summary>
    </member>
    <member name="F:uLink.ServerAuthentication.privateKey">
      <summary>
            The RSA private key for the server.
            </summary>
    </member>
    <member name="F:uLink.ServerAuthentication.publicKey">
      <summary>
            The RSA public key for the clients.
            </summary>
    </member>
    <member name="F:uLink.ServerAuthentication.initializeSecurity">
      <summary>
            Should the security be automatically initialized by this component?
            </summary>
    </member>
    <member name="T:uLink.NetworkInstantiatorUtility">
      <summary>
            This class has some lower level utility methods used in <see cref="o:uLink.Network.Instantiate" /> and
            <see cref="o:uLink.Network.Destroy" /> and <see cref="T:uLink.NetworkInstantiator" /> class.
            </summary>
    </member>
    <member name="M:uLink.NetworkInstantiatorUtility.Instantiate(uLink.NetworkView,uLink.NetworkInstantiateArgs)">
      <summary>
            This is the default method which is called for instantiation.
            </summary>
      <param name="prefab">
      </param>
      <param name="args">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkInstantiatorUtility.BroadcastOnNetworkInstantiate(uLink.NetworkView,uLink.NetworkMessageInfo)">
      <summary>
            Broadcasts a uLink_OnNetworkInstantiate message. This is used by
            <see cref="o:uLink.Network.Instantiate" />'s default instantiator to broadcast the message.
            </summary>
      <param name="networkView">The NetworkView that you want to broadcast the message for</param>
      <param name="info">
      </param>
    </member>
    <member name="M:uLink.NetworkInstantiatorUtility.BroadcastOnNetworkInstantiate(uLink.NetworkView,System.String,uLink.NetworkMessageInfo)">
      <summary>
            Broadcasts a uLink_OnNetworkInstantiate message. This is used by
            <see cref="o:uLink.Network.Instantiate" />'s default instantiator to broadcast the message.
            </summary>
      <param name="networkView">The NetworkView that you want to broadcast the message for</param>
      <param name="message">
      </param>
      <param name="info">
      </param>
    </member>
    <member name="M:uLink.NetworkInstantiatorUtility.Destroy(uLink.NetworkView)">
      <summary>
            Destroys the prefab of a networkView. This is the default method when you call <see cref="M:uLink.Network.Destroy(uLink.NetworkView)" />
            and uLink wants to destroy the prefab.
            </summary>
      <param name="networkView">
      </param>
    </member>
    <member name="M:uLink.NetworkInstantiatorUtility.GetComponentsInChildren``1(UnityEngine.Transform)">
      <summary>
            This function is a replacement for Unity's regular GetComponentsInChildren, which also works on prefabs.
            </summary>
    </member>
    <member name="M:uLink.NetworkInstantiatorUtility.SetActiveRecursively(UnityEngine.Transform,System.Boolean)">
      <summary>
            This function is a replacement for Unity's regular SetActiveRecursively, which also works on prefabs.
            </summary>
    </member>
    <member name="T:uLink.LocalHostData">
      <summary>
            Base data structure for holding individual host (server) information, for a LAN server without an external IP address.
            </summary>
      <remarks>
            Host information for servers with and external public address is stored in the subclass <see cref="T:uLink.HostData" />.
            </remarks>
    </member>
    <member name="F:uLink.LocalHostData.gameType">
      <summary>
            The type of the game (like MyUniqueGameType).
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.gameName">
      <summary>
            The name of the game (like John Doe's Game)
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.gameMode">
      <summary>
            Use this string to describe the mode this game server is running (deathmatch, free for all..)
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.gameLevel">
      <summary>
            Use this string to describe the game level for the server.
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.connectedPlayers">
      <summary>
            Currently connected number of players
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.playerLimit">
      <summary>
            The maximum number of players that is allowed on this server.
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.passwordProtected">
      <summary>
            Does the server require a password?
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.dedicatedServer">
      <summary>
            Is the server dedicated or hosted by a player?
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.useNat">
      <summary>
            Does this server require NAT punchthrough?
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.useProxy">
      <summary>
            Does this server require that clients connect via a proxy?
            </summary>
      <remarks>
            Read more about the proxy server in the Master Server and Proxy manual chapter.
            </remarks>
    </member>
    <member name="F:uLink.LocalHostData.comment">
      <summary>
            A miscellaneous comment about the server
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.platform">
      <summary>
            Use this string to describe the platform needed for connecting to this game server.
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.timestamp">
      <summary>
            The time when this data (about the host) was collected.
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.internalEndpoint">
      <summary>
            The IP address and port for this host in the local network (LAN). 
            </summary>
    </member>
    <member name="M:uLink.LocalHostData.IsDefined">
      <summary>
            Returns true if internalEnpoint, gameType and gameName has been set, otherwise false.
            </summary>
    </member>
    <member name="P:uLink.LocalHostData.internalPort">
      <summary>
            Server private port in the local network (LAN). 
            </summary>
    </member>
    <member name="P:uLink.LocalHostData.internalIP">
      <summary>
            Server private IP address in the local network (LAN). 
            </summary>
    </member>
    <member name="P:uLink.LocalHostData.port">
      <summary>
            Server private port in the local network (LAN). Same as <see cref="P:uLink.LocalHostData.internalPort" />.
            </summary>
    </member>
    <member name="P:uLink.LocalHostData.ipAddress">
      <summary>
            Server private IP address in the local network (LAN). Same as <see cref="P:uLink.LocalHostData.internalIP" />.
            </summary>
    </member>
    <member name="T:uLink.HostDataFilter">
      <summary>
            Used to filter the list of servers in a MasterServer.
            </summary>
    </member>
    <member name="T:uLink.HostDataFilter.RelationFlags">
      <summary>
            To set conditions like "connected players must be more than 0 players" or "player limit less or equal to 10". 
            </summary>
    </member>
    <member name="T:uLink.HostDataFilter.Relation">
      <summary>
            Defines relation conditions.
            </summary>
    </member>
    <member name="T:uLink.HostData">
      <summary>
            Data structure for holding individual host (server) information.
            </summary>
      <remarks>
            The host list retrieved from a master server uses this class to represent individual servers. 
            See <see cref="M:uLink.MasterServer.PollHostList" /></remarks>
    </member>
    <member name="F:uLink.HostData.externalEndpoint">
      <summary>
            The public IP address and port for this host on the Internet. 
            </summary>
    </member>
    <member name="F:uLink.HostData.ping">
      <summary>
            Returns the round trip ping time in milliseconds from the master server to the 
            game server, or if this is a WellKnownHost the ping time is instead meassured 
            between the client and the host.
            </summary>
      <remarks>
            The most usable ping time is for WellKnownHosts since it is meassured between 
            the client and the game server(s). A player is usually looking for a nearby server 
            with a nice low ping time. 
            <para>
            The ping time between the master server and the game server can be useful in some situations.
            How useful it is depends on where servers are hosted. uLink provides this value to be used in 
            any way you want.</para><para>
            If the host needs a proxy this ping time is 
            not correct. Do not use this ping time in the proxy case.  
            </para><para>
            Pingtime between a server and connected players is available via <see cref="M:uLink.Network.GetAveragePing(uLink.NetworkPlayer)" /></para></remarks>
    </member>
    <member name="P:uLink.HostData.externalPort">
      <summary>
            Server public port, used by clients on the Internet to connect to the server.
            </summary>
    </member>
    <member name="P:uLink.HostData.externalIP">
      <summary>
            Server public IP address, used by clients on the Internet to connect to the server.
            </summary>
    </member>
    <member name="P:uLink.HostData.port">
      <summary>
            Server public port, used by clients on the Internet to connect to the server. Same as <see cref="P:uLink.HostData.externalPort" />.
            </summary>
    </member>
    <member name="P:uLink.HostData.ipAddress">
      <summary>
            Server public IP address, used by clients on the Internet to connect to the server. Same as <see cref="P:uLink.HostData.externalIP" />.
            </summary>
    </member>
    <member name="P:uLink.HostData.ip">
      <summary>
            Server IP address
            </summary>
    </member>
    <member name="P:uLink.HostData.guid">
      <summary>
            Use HostData.externalEndpoint.ToString() instead
            </summary>
    </member>
    <member name="T:uLink.NetworkLogUtility">
      <summary>
            Utility class for composing log messages.
            </summary>
    </member>
    <member name="M:uLink.NetworkLogUtility.AddToString``1(uLink.NetworkLogUtility.ToString)">
      <summary>
            Adds a method for creating a string representation from objects of the specified type.
            </summary>
      <typeparam name="T">The type that we want to make strings from objects of it.</typeparam>
      <param name="toString">The method which creates the string using the provided object.</param>
    </member>
    <member name="M:uLink.NetworkLogUtility.AddToString(System.RuntimeTypeHandle,uLink.NetworkLogUtility.ToString)">
      <summary>
            Adds a method for creating a string representation from objects of the specified type handle.
            </summary>
      <param name="typeHandle">Handle of the type which you want to suply the string creation method for.</param>
      <param name="toString">The method which can create string representations of the type.</param>
      <remarks>Take a look at RuntimeTypeHandle documentation on MSDN for more information.</remarks>
    </member>
    <member name="M:uLink.NetworkLogUtility.RemoveToString(System.RuntimeTypeHandle)">
      <summary>
            Removes the method for string creation for the provided type handle.
            </summary>
      <param name="typeHandle">The handle for the type that you want to remove its method.</param>
    </member>
    <member name="M:uLink.NetworkLogUtility.ObjectToString(System.Object)">
      <summary>
            Returns the string representation of the provided object.
            </summary>
      <param name="obj">The instance that you want to get its string representation.</param>
      <returns>If the object is not null, string representing the object, otherwise null.</returns>
      <remarks>
            The method first tries to find a registered method for the type of the object and call it, if unsuccessful it
            calls Object.ToString on it. 
            If the provided object is null, null is returned.
            </remarks>
    </member>
    <member name="M:uLink.NetworkLogUtility.ObjectsToString(System.Object[])">
      <summary>
            Returns a single string containing all of the strings representing the objects in the array.
            </summary>
      <param name="objs">An array of objects which you want their string representation.</param>
      <returns>A string containing the string representation of all array elements.</returns>
    </member>
    <member name="M:uLink.NetworkLogUtility.FindObjectOfType``1(System.Object[])">
      <summary>
            Returns the first object which has the type <c>T</c> or is derived from it from the whole array of provided <c>objs</c>.
            </summary>
      <typeparam name="T">The type that you want to return an object which is of its kind.</typeparam>
      <param name="objs">The array of objects which you want to search and only get one of its objects
            which have the specified type.</param>
      <returns>An instance from the objects which is of type <c>T</c> if any, otherwise null</returns>
      <remarks>The method uses the C# <c>is</c> operator to find if an object is of the type or not and does a linear search.
            The operation is O(N) where N is the number of elements in the array.</remarks>
    </member>
    <member name="T:uLink.NetworkLogUtility.ToString">
      <summary>
            This is the delegate that you should conform to when writing methods to create string representation of types for logging.
            </summary>
      <param name="obj">This is the instance that you should create a representation of.</param>
      <returns>
      </returns>
    </member>
    <member name="T:uLink.NetworkInstantiator">
      <summary>
            A registry for instantiators for prefabs. 
            </summary>
      <remarks>
            Most common usage of this class is to use the methods <see cref="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject)" />
            to register prefabs downloaded in an asset bundle before they can be instantiated by calling
            <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>.
            <para>
            The methods here are also used by the utility script uLinkInstantiatePool.cs to make
            it possible to configure a pool of network-instantiated game objects without having to change 
            any code at all.
            </para><para>
            The <see cref="F:uLink.NetworkView.instantiator" /> also references the instantiator of the prefab which the network view is attached to.
            It can be used to customize the instantiation and destruction of gameObjects
            when you call <see cref="o:uLink.Network.Instantiate" /> and <see cref="M:uLink.Network.Destroy(uLink.NetworkView)" />.
            For example if you want to first run an animation and then destroy the object
            you can create a custom destroyer.
            The utility script, OverrideNetworkDestroy can be used also to easily do custom stuff when an object is destroyed
            on the network.
            </para></remarks>
    </member>
    <member name="F:uLink.NetworkInstantiator.creator">
      <summary>
            This is the method which is called when a client receives an RPC sent by <see cref="o:uLink.Network.Instantiate" /> 
            to instantiate a prefab as a network aware object. You can change this to your own method to customize the process.
            </summary>
      <remarks>
            This field is usually accessed for each network aware object using <see cref="F:uLink.NetworkView.instantiator" />.
            </remarks>
      <example>See the utility script OverrideNetworkDestroy for an example.
            </example>
    </member>
    <member name="F:uLink.NetworkInstantiator.destroyer">
      <summary>
            This is the method which is called when a client receives an RPC sent by <see cref="M:uLink.Network.Destroy(uLink.NetworkView)" /> 
            to destroy a prefab as a network aware object. You can change this to your own method to customize the process.
            </summary>
      <remarks>
            This field is usually accessed for each network aware object using <see cref="F:uLink.NetworkView.instantiator" />.
            </remarks>
      <example>See the utility script OverrideNetworkDestroy for an example.
            You can call the default behaviour <see cref="F:uLink.NetworkInstantiator.defaultDestroyer" /> at the end of your custom method as well.
            </example>
    </member>
    <member name="F:uLink.NetworkInstantiator.defaultDestroyer">
      <summary>
            The default method for destroying network aware objects. This is the method which is called by default if you
            don't change the <see cref="F:uLink.NetworkInstantiator.destroyer" /> delegate.
            This simply destroys the object.
            </summary>
    </member>
    <member name="M:uLink.NetworkInstantiator.AddAssetBundle(UnityEngine.AssetBundle)">
      <summary>
            Registers all prefabs in the asset bundle that does have a NetworkView component.   
            This makes sure they can be instantiated later with 
            <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see></summary>
      <param name="assetBundle">The asset bundle that you want to register its prefabs.</param>
      <remarks>
            This is a convenience method that calls <see cref="O:uLink.NetworkInstantiator.AddPrefab" />
            for all prefabs in the asset bundle that has a network view component.
            <para>
            It is common for developers to minimize the download time for the Unity game at startup by putting
            some prefabs in asset bundles and then download the asset bundles when needed in the game. 
            We recommend writing code that downloads the asset bundle, loads the prefabs, registers them with this method, 
            and finally makes the calls to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>. 
            If it is an authoritative server the call to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            has to be done on the server.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.AddAssetBundle(UnityEngine.AssetBundle,System.Boolean)">
      <summary>
            Registers all prefabs in the asset bundle that does have a NetworkView component.   
            This makes sure they can be instantiated later with 
            <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see></summary>
      <param name="assetBundle">The asset bundle that you want to register its prefabs.</param>
      <param name="replaceIfExists">if <c>true</c> then prefabs with the same name will be replaced by the new ones in the asset bundle.</param>
      <remarks>
            This is a convenience method that calls <see cref="O:uLink.NetworkInstantiator.AddPrefab" />
            for all prefabs in the asset bundle that has a network view component.
            <para>
            It is common for developers to minimize the download time for the Unity game at startup by putting
            some prefabs in asset bundles and then download the asset bundles when needed in the game. 
            We recommend writing code that downloads the asset bundle, loads the prefabs, registers them with this method, 
            and finally makes the calls to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>. 
            If it is an authoritative server the call to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            has to be done on the server.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject)">
      <summary>
            Registers a prefab to make sure it can be instantiated 
            later with <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            by creating and adding a default instantiator for the specified gameobject. 
            </summary>
      <remarks>
            With this uLink feature it is possible to register prefabs 
            that are located anywhere in the project. 
            The old uLink restriction that all prefabs must reside in the Resources folder is overruled.
            Place the prefab in any folder in the project, but remember to call this method on all 
            clients and the server before calling <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>.
            <para>
            When the server is authoritative, registration on the clients usually includes the prefab for 
            proxies and the owner. Registration on the server includes only the prefab for the creator.
            Keep in mind that registering prefabs using this method means you have a reference
            to the object so the object will be built with your scene.
            So don't waste memory by referencing all prefabs in both clients and servers (at production time).
            </para><para>
            There is also a convenient utility script called uLinkRegisterPrefabs that calls this method for you.
            Read more about that script in the uLink manual chapter for instantiating objects.
            </para><para>
            It is common for developers to minimize the download time for the Unity game at startup by putting
            some prefabs in assert bundles and then download the asset bundles when needed in the game. 
            We recommend writing code that downloads the asset bundle, loads the prefabs, registers them with 
            <see cref="O:uLink.NetworkInstantiator.AddAssetBundle" />, 
            and finally makes the calls to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>.
            If it is an authoritative server the call to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            has to be done on the server.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject,System.Boolean)">
      <summary>
            Registers a prefab to make sure it can be instantiated 
            later with <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            by creating and adding a default instantiator for the specified gameobject.  
            Read remarks <see cref="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject)">here</see></summary>
    </member>
    <member name="M:uLink.NetworkInstantiator.Add(System.String,uLink.NetworkInstantiator.Creator,uLink.NetworkInstantiator.Destroyer)">
      <summary>
            Creates a prefab instantiator with custom methods for instantiation and destruction.
            </summary>
      <param name="prefabName">Name of the prefab to instantiate</param>
      <param name="creator">The method which should be called for prefab creation</param>
      <param name="destroyer">The method which should be called for prefab destruction</param>
      <remarks>
            The reference to the prefab itself is not sent to you at creation time so either you need to load it from
            resources folder or find it by some other way.
            This method can be used in creative ways but it's very advanced and you should only use it when you really need it.
            You can for example find the player's pet based on database values and instantiate the correct pet when an
            instantiate call with pet as prefab is cone. Keep in mind that you should not do slow operations here.
            Read the value from database in some other time (e.g. login time) and store it somewhere.
            </remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.Add(System.String,uLink.NetworkInstantiator.Creator,uLink.NetworkInstantiator.Destroyer,System.Boolean)">
      <summary>
            Creates a prefab instantiator with custom methods for instantiation and destruction.
            </summary>
      <param name="prefabName">Name of the prefab to instantiate</param>
      <param name="creator">The method which should be called for prefab creation</param>
      <param name="destroyer">The method which should be called for prefab destruction</param>
      <param name="replaceIfExists">If set to <c>true</c> then if a prefab with the same name exists, it will be replaced, otherwise an error log will be printed.</param>
      <remarks>
            The reference to the prefab itself is not sent to you at creation time so either you need to load it from
            resources folder or find it by some other way.
            This method can be used in creative ways but it's very advanced and you should only use it when you really need it.
            You can for example find the player's pet based on database values and instantiate the correct pet when an
            instantiate call with pet as prefab is cone. Keep in mind that you should not do slow operations here.
            Read the value from database in some other time (e.g. login time) and store it somewhere.
            </remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.Remove(System.String)">
      <summary>
            Removes a instantiator. If this instantiator was added by <see cref="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject)" />
            and the specific gameobject is not placed in a Resources-folder then that gameobject can no longer be used
            with <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>.
            </summary>
      <remarks>
            It is nice to be able to remove all references to a prefab to make it possible 
            to unload it and reduce memory footprint in the Unity player. This can for example
            be used in a web player when switching from one scene to another or when switching from 
            one game mode to another. Read more in the Unity manual about garbage collection and 
            unloading prefabs. 
            </remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.RemoveAll">
      <summary>
            Removes all instantiators. See also <see cref="M:uLink.NetworkInstantiator.Remove(System.String)" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkInstantiator.Find(System.String)">
      <summary>
            Used internally by uLink when executing Network.Instantiate, but it is also public to make it easier to debug problems with NetworkInstantiator.
            It finds and returns the Instantiator for the prefab with the name provided,
            </summary>
    </member>
    <member name="M:uLink.NetworkInstantiator.CreateDefaultCreator(System.String)">
      <summary>
            Creates the default <see cref="T:uLink.NetworkInstantiator.Creator" /> for the prefab and returns it.
            </summary>
      <param name="prefabName">Name of the prefab that you want to create a creator for.</param>
      <returns>The creator method.</returns>
    </member>
    <member name="M:uLink.NetworkInstantiator.CreateDefaultCreator(UnityEngine.GameObject)">
      <summary>
            Creates the default <see cref="T:uLink.NetworkInstantiator.Creator" /> for the prefab and returns it.
            </summary>
      <param name="prefab">The prefab that you want to create a creator for.</param>
      <returns>The creator method.</returns>
    </member>
    <member name="T:uLink.NetworkInstantiator.Creator">
      <summary>
            Signature for creator methods, Creators are used to Instantiate objects when you receive an instantiation RPC
            on the network.
            </summary>
    </member>
    <member name="T:uLink.NetworkInstantiator.Destroyer">
      <summary>
            Signature for destroyer methods, Destroyer methods are used to destroy
            objects when you receive a destruction RPC on the network.
            </summary>
    </member>
    <member name="T:uLink.NetworkAddressInfo">
      <summary>
            Represents an IP address plus mask
            </summary>
    </member>
    <member name="F:uLink.NetworkAddressInfo.ipAddress">
      <summary>
            The IP address that we represent.
            </summary>
    </member>
    <member name="F:uLink.NetworkAddressInfo.mask">
      <summary>
            subnet mask of the IP address.
            </summary>
    </member>
    <member name="M:uLink.NetworkAddressInfo.#ctor(System.Net.IPAddress,System.Net.IPAddress)">
      <summary>
            Creates a NetworkAddressInfo object with the provided address.
            </summary>
      <param name="ipAddress">
      </param>
      <param name="mask">
      </param>
    </member>
    <member name="M:uLink.NetworkAddressInfo.HasSameSubnet(uLink.NetworkEndPoint)">
      <summary>
            Returns if we are in the same subnet with the provided end point.
            </summary>
      <param name="endpoint">The end point that we want to compare ourself to</param>
      <returns>True if we are in the same subnet, otherwise false.</returns>
    </member>
    <member name="M:uLink.NetworkAddressInfo.HasSameSubnet(System.Net.IPAddress)">
      <summary>
            Returns if the other IP address has the same subnet (based on IP classes).
            </summary>
      <param name="remote">The remote IP address that we want to compare to ourself.</param>
      <returns>true if the other IP is in the same class that we are, otherwise false.</returns>
    </member>
    <member name="T:uLink.NetworkConfig">
      <summary>
            Enables configuration of low-level network parameters, like connection timeouts, inactivity timeouts, ping frequency
            and MTU (Maximum Transmission Unit). See <see cref="P:uLink.Network.config" />. 
            </summary>
    </member>
    <member name="M:uLink.NetworkConfig.GetPrefs">
      <summary>
            Gets the NetworkConfig properties from <see cref="T:uLink.NetworkPrefs" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkConfig.SetPrefs">
      <summary>
            Sets the NetworkConfig properties in <see cref="T:uLink.NetworkPrefs" />.
            </summary>
      <remarks>
            The method can't update the saved values in the persistent <see cref="F:uLink.NetworkPrefs.resourcePath" /> file,
            because that assumes the file is editable (i.e. the running project isn't built) and would require file I/O permission.
            Calling this will only update the values in memory.
            </remarks>
    </member>
    <member name="P:uLink.NetworkConfig.maximumTransmissionUnit">
      <summary>
            Gets or sets how many data bytes that can maximally be sent using a single UDP packet.
            This can be set independently for the client and the server.
            Only modify this if you know what you are doing. 
            The default value 1400 has been carefully chosen for optimal speed and 
            throughput in most link layers in IP networks. 
            The value 1400 will ensure that UDP packets with uLink traffic (data and all headders) fit into one single 
            ethernet frame (1500 max) and thus the packet loss risk will be minimal for every UDP packet.
            Ethernet is a very common link layer in modern IP networks.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.timeBetweenPings">
      <summary>
            Gets or sets the number of seconds between pings.
            This can be set independently for the client and the server.
            Default value is 3 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.timeoutDelay">
      <summary>
            Gets or sets the time in seconds before a connection times out when no network packets are received from remote host.
            This can be set independently for the client and the server. Default value is 30 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.handshakeRetriesMaxCount">
      <summary>
            Gets or sets the maximum number of re-attempts to connect to the remote host before giving up.
            This only has meaning for the client, or the connecting peer. Default value is 5 attempts.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.handshakeRetryDelay">
      <summary>
            Gets or sets the number of seconds between handshake attempts.
            This only has meaning for the client, or the connecting peer.
            Default value is 2.5 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.allowInternalUnconnectedMessages">
      <summary>
            If you set this to false, broadcast messages inside the network will not be allowed and features like discovery
            of local peers or servers in the local network will not work.
            If your game doesn't use these features, you might turn these off to prevent security issues in DOS/D-DOS attacks.
            Default value is true.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.batchSendAtEndOfFrame">
      <summary>
            Determines whether uLink should queue all outgoing messages until the end of frame.
            </summary>
      <remarks>
            Batching lets uLink do more optimizations such as fitting multiple messages in a single packet,
            if they are not too big. There will be a slight CPU and bandwidth cost for turning off batching,
            how much depends on the amount and type of messages.
            But one benefit of disabling it, is that you then know the message has been sent after <see cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
            has returned and CPU profiling of RPCs is more accurate, in Unity's Profiler. 
            </remarks>
    </member>
    <member name="T:uLink.NetworkVersionBuild">
      <summary>
            This enum shows what version of uLink build you have.
            </summary>
    </member>
    <member name="F:uLink.NetworkVersionBuild.Alpha">
      <summary>
            It's an Alpha build. It's not stable.
            </summary>
    </member>
    <member name="F:uLink.NetworkVersionBuild.Beta">
      <summary>
            This is a Beta and more stable than Alpha. This is waht we use before stable release.
            </summary>
    </member>
    <member name="F:uLink.NetworkVersionBuild.Stable">
      <summary>
            This is an stable released version. Good for production.
            </summary>
    </member>
    <member name="F:uLink.NetworkVersionBuild.Custom">
      <summary>
            This is a custom build prepared for you. This might have a quick hot fix, a specific feature or ...
            </summary>
    </member>
    <member name="T:uLink.NetworkVersion">
      <summary>
            The version of uLink.
            </summary>
    </member>
    <member name="T:uLink.NetworkEmulation">
      <summary>
            Emulates network problems like lost packets, duplicate packets and latency 
            fluctuations. See <see cref="P:uLink.Network.emulation" />. 
            </summary>
    </member>
    <member name="M:uLink.NetworkEmulation.GetPrefs">
      <summary>
            Gets the emulation properties from <see cref="T:uLink.NetworkPrefs" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkEmulation.SetPrefs">
      <summary>
            Sets the emulation properties in <see cref="T:uLink.NetworkPrefs" />.
            </summary>
      <remarks>
            The method can't update the saved values in the persistent <see cref="F:uLink.NetworkPrefs.resourcePath" /> file,
            because that assumes the file is editable (i.e. the running project isn't built) and would require file I/O permission.
            Calling this will only update the values in memory.
            </remarks>
    </member>
    <member name="P:uLink.NetworkEmulation.maxBandwidth">
      <summary>
            Gets or sets the maximum emulated bandwidth when sending from this peer.
            </summary>
    </member>
    <member name="P:uLink.NetworkEmulation.chanceOfLoss">
      <summary>
            This is a float which simulates lost UDP packets when sending from this peer.
            </summary>
      <remarks>A value of 0 will disable this feature, 
            a value of 0.5 will make half of your sent packets disappear, chosen randomly. Note that 
            one UDP packet may contain several uLink messages (RPCs and statesyncs) - this is the amount 
            of UDP packets lost. 
            </remarks>
    </member>
    <member name="P:uLink.NetworkEmulation.chanceOfDuplicates">
      <summary>
            Dictates the chance that a packet will be duplicated at the destination, when sent from this peer. 
            </summary>
      <remarks>
            0 means no packets will be duplicated, 0.5 means that on average, every other packet will be duplicated. 
            </remarks>
    </member>
    <member name="P:uLink.NetworkEmulation.minLatency">
      <summary>
            Gets or sets the minimum emulated one-way latency addition for packets in seconds (not milliseconds)
            </summary>
      <remarks>
            This value and <see cref="P:uLink.NetworkEmulation.maxLatency" /> work on top of the actual network delay and the total delay will be: 
            Actual one way latency + <see cref="P:uLink.NetworkEmulation.minLatency" /> + (randomly per packet 0 to <see cref="P:uLink.NetworkEmulation.maxLatency" /> seconds) 
            when sending from this peer
            </remarks>
    </member>
    <member name="P:uLink.NetworkEmulation.maxLatency">
      <summary>
            Gets or sets the maximum emulated one-way latency addition for packets in seconds (not milliseconds)
            </summary>
      <remarks>
            This value and <see cref="P:uLink.NetworkEmulation.minLatency" /> work on top of the actual network delay and the total delay will be: 
            Actual one way latency + <see cref="P:uLink.NetworkEmulation.minLatency" /> + (randomly per packet 0 to <see cref="P:uLink.NetworkEmulation.maxLatency" /> seconds) 
            when sending from this peer
            </remarks>
    </member>
    <member name="T:uLink.NetworkP2PMessageInfo">
      <summary>
            A class containing some extra information about the sender of this network P2P message.
            </summary>
      <remarks>You should declare a parameter of this type at the end of your 
            RPC's parameter list to get this information.</remarks>
      <example>
        <code>
            [RPC]
            void P2PRPCSample(string normalParam,NetworkP2PMessageInfo info)
            {
            	//use the info parameter here to get more info about the sender and flags of the message.
            }
            </code>
      </example>
    </member>
    <member name="F:uLink.NetworkP2PMessageInfo.sender">
      <summary>
            The <see cref="T:uLink.NetworkPeer" /> who sent the message.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PMessageInfo.flags">
      <summary>
            The flags used when sending this message.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PMessageInfo.networkP2P">
      <summary>
            The <see cref="T:uLink.NetworkP2P" /> this message was sent from.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PMessageInfo.#ctor(uLink.NetworkPeer,uLink.NetworkFlags,uLink.NetworkP2P)">
      <summary>
            Initializes a NetworkP2PMessageInfo. 
            You should not need to use this in most situations.
            Don't use it unless you really know what you are doing.
            </summary>
      <param name="sender">
      </param>
      <param name="flags">
      </param>
      <param name="networkP2P">
      </param>
    </member>
    <member name="T:uLink.NetworkStatistics">
      <summary>
            Read live network statistics for one <see cref="T:uLink.NetworkPlayer" />. Available via <see cref="P:uLink.NetworkPlayer.statistics" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.bytesSentPerSecond">
      <summary>
            Gets bytesSentPerSecond.
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.bytesReceivedPerSecond">
      <summary>
            Gets bytesReceivedPerSecond
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.userBytesSentPerSecond">
      <summary>
            Gets userBytesSentPerSecond
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.userBytesReceivedPerSecond">
      <summary>
            Gets userBytesReceivedPerSecond
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.bytesSent">
      <summary>
            Gets bytesSent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.bytesReceived">
      <summary>
            Gets bytesReceived
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.userBytesSent">
      <summary>
            Gets userBytesSent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.userBytesReceived">
      <summary>
            Gets userBytesReceived 
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.packetsSent">
      <summary>
            Gets packetsSent 
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.packetsReceived">
      <summary>
            Gets packetsReceived 
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesSent">
      <summary>
            Gets messagesSent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesReceived">
      <summary>
            Gets messagesReceived
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesResent">
      <summary>
            Gets messagesResent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesStored">
      <summary>
            Gets messagesStored
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesUnsent">
      <summary>
            Gets messagesUnsent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesWithheld">
      <summary>
            Gets messagesWithheld
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messageDuplicatesRejected">
      <summary>
            Gets messageDuplicatesRejected
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messageSequencesRejected">
      <summary>
            Gets messageSequencesRejected
            </summary>
    </member>
    <member name="T:uLink.NetworkBufferedRPC">
      <summary>
            Represents a buffered message. 
            </summary>
      <remarks>
            Buffered messages is a uLink tool that can be used to give newly connected players all 
            the important RPCs they need to join a game that is already running.
            Read more about when to use this class in 
            uLink.Network.<see cref="!:uLink.Network.uLink_OnPreBufferedRPCs" /> 
            and the manual chapter about RPCs.
            </remarks>
    </member>
    <member name="M:uLink.NetworkBufferedRPC.DontExecuteOnConnected">
      <summary>
            Disable automatic execution before invoking uLink_ConnectedToServer().
            </summary>
      <remarks>Call this if you want to control the execution of buffered RPCs in clients.
            They can be executed at a later time by using the <see cref="M:uLink.NetworkBufferedRPC.ExecuteNow" /> or simply ignored. Also, 
            take at look at the documentation for the callback <see cref="!:uLink.Network.uLink_OnPreBufferedRPCs" /></remarks>
    </member>
    <member name="M:uLink.NetworkBufferedRPC.ExecuteNow">
      <summary>
            Executes the RPC. 
            </summary>
      <remarks>
            This will also call <see cref="M:uLink.NetworkBufferedRPC.DontExecuteOnConnected" /></remarks>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.sender">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> who sent the buffered message.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.localTimestamp">
      <summary>
            The local timestamp when the buffered message was first sent, similar to <see cref="F:uLink.NetworkMessageInfo.localTimestamp" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.serverTimestamp">
      <summary>
            The server timestamp when the buffered message was first sent, similar to <see cref="F:uLink.NetworkMessageInfo.serverTimestamp" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.rawServerTimestamp">
      <summary>
            The raw server timestamp when the buffered message was first sent, similar to <see cref="F:uLink.NetworkMessageInfo.rawServerTimestamp" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.elapsedTimeSinceSent">
      <summary>
            Calculates the relative time (in seconds) since the message was sent.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.viewID">
      <summary>
            Gets the <see cref="T:uLink.NetworkViewID" /> for this buffered message.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.flags">
      <summary>
            The network flags that was used when this buffered message was sent.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.rpcName">
      <summary>
            Gets the name of this buffered RPC.
            </summary>
      <value>The name as a string. If it is an internal Instantiate or StateSync RPC, this call will return an empty string. 
            See <see cref="P:uLink.NetworkBufferedRPC.isInstantiate" />.</value>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.isInstantiate">
      <summary>
            Gets a value indicating whether this buffered message is a uLink internal instantiate RPC.
            </summary>
      <value>
        <c>true</c> if this is Instantiate; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.isStateSync">
      <summary>
            Gets a value indicating whether this buffered message is a StateSync message.
            </summary>
      <value>
        <c>true</c> if this is StateSync; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.isRPC">
      <summary>
            Gets a value indicating whether this buffered message is a user-defined RPC.
            </summary>
      <value>
        <c>true</c> if this is RPC; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:uLink.NetworkPlayer">
      <summary>
            This struct represents a client/player or the server.
            </summary>
      <remarks>The server is always represented by the static field 
            <see cref="F:uLink.NetworkPlayer.server" /></remarks>
    </member>
    <member name="F:uLink.NetworkPlayer.unassigned">
      <summary>
            Returned when calling uLink.Network.<see cref="P:uLink.Network.player" /> before the network has been initialized.
            See <see cref="O:uLink.Network.InitializeServer" /> and <see cref="!:uLink.Network.Connect(System.Net.NetworkEndPoint)" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.server">
      <summary>
            Represents the special network player for the server.
            Returned when calling uLink.Network.<see cref="P:uLink.Network.player" /> on the server
            or when calling itself on any client or the server.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.minClient">
      <summary>
            Minimum <see cref="F:uLink.NetworkPlayer.id" /> value a assigned client can have.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.maxClient">
      <summary>
            Maximum <see cref="F:uLink.NetworkPlayer.id" /> value a assigned client can have.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.minCellServer">
      <summary>
            Minimum <see cref="F:uLink.NetworkPlayer.id" /> value a assigned cellserver can have.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.maxCellServer">
      <summary>
            Maximum <see cref="F:uLink.NetworkPlayer.id" /> value a assigned cellserver can have.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.id">
      <summary>
            Gets the unique id number for this player.
            </summary>
    </member>
    <member name="M:uLink.NetworkPlayer.SetLocalData(System.Object)">
      <summary>
            Sets the local data for this player.
            </summary>
      <remarks>See <see cref="P:uLink.NetworkPlayer.localData" /> for more information.</remarks>
      <param name="localData">
      </param>
    </member>
    <member name="M:uLink.NetworkPlayer.GetLocalData">
      <summary>
            Gets the local data for the player.
            </summary>
      <remarks>See <see cref="P:uLink.NetworkPlayer.localData" /> for more information.</remarks>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkPlayer.GetLocalData``1">
      <summary>
            Returns the local data of the player casted to the specified type parameter.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkPlayer.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:uLink.NetworkPlayer" /> struct.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isUnassigned">
      <summary>
            Gets a value indicating whether this instance is unassigned.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isServer">
      <summary>
            Gets a value indicating whether this instance is the server.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isClient">
      <summary>
            Gets a value indicating whether this instance is a client.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isCellServer">
      <summary>
            Gets a value indicating whether this instance is a cellserver.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isServerOrCellServer">
      <summary>
            Gets a value indicating whether this instance is the server or a cellserver.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isCellProxies">
      <summary>
            Gets a value indicating whether this instance represents cell proxies.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isConnected">
      <summary>
            Gets a value indicating whether this instance is connected to the network.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.securityStatus">
      <summary>
            Gets a value indicating the security status of this player.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.hasSecurity">
      <summary>
            Gets a value indicating whether this player has security turned on.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.statistics">
      <summary>
            Gets the <see cref="T:uLink.NetworkStatistics" /> for this player, which can be used to get connection statistics, bandwidth, packet counts etc.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.lastPing">
      <summary>
            Gets last ping time for a player in milliseconds.
            In the client you should only call <c>uLink.NetworkPlayer.server.lastPing</c> because the only available target 
            is the server. In the server you can check the ping time for any connected player.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.averagePing">
      <summary>
            Gets average ping time for this player in milliseconds.
            </summary>
      <returns>Average ping time for a player in milliseconds. If target is unknown or not connected, then returns -1.</returns>
      <remarks>Calculates the average of the last few pings, making this a moving average.
            In the client you should only call <c>uLink.NetworkPlayer.server.averagePing</c> because the only available target 
            is the server. In the server you can check the ping time for any connected player.
            </remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.loginData">
      <summary>
            Gets the loginData sent by the player when the player connected.
            </summary>
      <remarks>
            Use this to get the loginData for any player on the server. When a player connects, the player can send extra 
            parameters in the <see cref="M:uLink.Network.Connect(uLink.HostData,System.String,System.Object[])" /> method 
            arguments. These parameter will be stored in the client and sent from the client. These parameters are received by 
            the server as loginData and stored in the server for the complete game 
            session (until the player disconnects) and can be retrieved this way on the server. 
            In a client the only available login data is your own loginData, sent using the 
            one of the <see cref="M:uLink.Network.Connect(uLink.HostData,System.String,System.Object[])" /> methods.
            </remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.endpoint">
      <summary>
            Returns the <see cref="!:System.Net.NetworkEndPoint" /> for this <see cref="T:uLink.NetworkPlayer" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.ipAddress">
      <summary>
            Gets the ip address for this NetworkPlayer.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.port">
      <summary>
            Gets the UDP port for this NetworkPlayer.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.externalEndpoint">
      <summary>
            Gets the external IP address of the player.
            </summary>
      <remarks>For clients behind NAT, this is usually the IP address of the firewall which client is using to 
            connect to the network.</remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.externalIP">
      <summary>
            Gets the external IP for this NetworkPlayer.
            </summary>
      <remarks>The external IP for a client is usually the IP for the NAT-capable firewall/router this client 
            is placed behind.</remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.externalPort">
      <summary>
            Gets the external port for this NetworkPlayer.
            </summary>
      <remarks>The external port for a client is usually the port chosen by 
            the NAT-capable firewall/router this client is placed behind.</remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.internalEndpoint">
      <summary>
            The internal IP end point of the player.
            </summary>
      <remarks>In clients behind NAT, This is the end point that the firewall/router uses to connect to the player's machine.</remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.internalIP">
      <summary>
            Returns the internal IP address of the player.
            </summary>
      <remarks>In clients behind NAT, This is the end point that the firewall/router uses to connect to the player's machine.</remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.internalPort">
      <summary>
            Returns the internal port of the player.
            </summary>
      <remarks>In clients behind NAT, This is the end point that the firewall/router uses to connect to the player's machine.</remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.guid">
      <summary>
            Gets a unique ID for this player.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.localData">
      <summary>
            Gets or sets the localData, data that is not sent over the network.
            </summary>
      <remarks>
            Use this to store any kind of data for this player, data that should be stored locally only.
            This data will never be sent over the network. 
            Usually this is used on the server side for storing things per player. This could be 
            things like original spawn point, login time, cached data from the database, and whatever you like.
            The alternative is to set up one or several Dictionaries on the server for 
            storing data per player.
            </remarks>
    </member>
    <member name="T:uLink.NetworkPlayerApprovalStatus">
      <summary>
            The different states which a player can have regarding being approved or not.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApprovalStatus.AutoApproving">
      <summary>
            The player is being automatically approved.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApprovalStatus.Approved">
      <summary>
            The player is approvved.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApprovalStatus.Waiting">
      <summary>
            The player is waiting because server is doing a time consuming work to know if the player should
            be approved or not. This might be loading stuff from database or getting information from a web service or ...
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApprovalStatus.Denied">
      <summary>
            The player is denied.
            </summary>
    </member>
    <member name="T:uLink.NetworkPlayerApproval">
      <summary>
            The request data sent from a client wanting to connect to a server.
            </summary>
      <remarks>
            This is used in <see cref="!:uLink.Network.uLink_OnPlayerApproval" /> for approving or denying a player.
            </remarks>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.loginData">
      <summary>
            The Bitstream containing the loginData sent from the client.
            Usually you use this to see if the client should be approved or not.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.info">
      <summary>
            You can see the time stamp of the sent message and see in the flags, wether the message is encrypted or not.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.localData">
      <summary>
            Set value for <see cref="P:uLink.NetworkPlayer.localData" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.handoverInstances">
      <summary>
            If the client has been handed over from a another server, then instances are the player's handover prefabs set by that server, otherwise empty.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.handoverData">
      <summary>
            If the client has been handed over from a another server, then handoverData can be set by that server, otherwise null.
            </summary>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.Approve(System.Object[])">
      <summary>
            Approves the client. A connection response will be sent internally by uLink to the client.
            </summary>
      <param name="approvalData">The approval data that will be delivered to the client.</param>
      <exception cref="T:System.ArgumentNullException">when approvalData is null or one of the arguments is null.</exception>
      <remarks>You can use approval data to send level number, team info or any other information to the client.</remarks>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.AssignManualPlayerID(System.Int32)">
      <summary>
            Assigns a custom unique player ID to this player instead of using the
            unique player ID that uLink would have provided automatically.
            </summary>
      <remarks>The main purpose of using this function would be to set the
            player ID to the same player ID you have in a persistent storage
            like a database. If your player IDs are integers and they are
            limited to the same range  as the uLink internal protocol (which is
            1 to <see cref="F:System.UInt16.MaxValue" /> - 1) it is very convenient to use
            these IDs from the database directly as playerIDs in uLink. 0 is
            reserved for unassigned clients and <see cref="F:System.UInt16.MaxValue" /> is
            reserved for representing the server. If you have another data type
            or a bigger integer range for unique player IDs in your database 
            this feature can not be used. Instead you have to store the database
            userID in one of the player's game objects on the server.
            </remarks>
      <exception cref="T:uLink.NetworkException">If trying to assign a manual playerID during a P2P handover.</exception>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.Wait">
      <summary>
            Change approval status of the player to waiting.
            This should be called if you want to do a time consuming operation like connecting to web services or loading
            data from data bases to decide on the player's approval.
            </summary>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.Deny">
      <summary>
            Denies the player to connect and sends a reason code to the client.
            The reason sent will be <see cref="F:uLink.NetworkConnectionError.ApprovalDenied" /></summary>
      <remarks>The player will get the reason in callback <see cref="!:uLink.Network.uLink_OnFailedToConnect" /></remarks>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.Deny(uLink.NetworkConnectionError)">
      <summary>
            Denies the player to connect and sends a reason code to the client.
            </summary>
      <param name="reason">The reason for not being granted a connection the player will get as a parameter in the 
            callback <see cref="!:uLink.Network.uLink_OnFailedToConnect" /></param>
    </member>
    <member name="P:uLink.NetworkPlayerApproval.endpoint">
      <summary>
            The IP address of the client.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayerApproval.ipAddress">
      <summary>
            A string representation of the IP address of the client.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayerApproval.port">
      <summary>
            The port number of the client.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayerApproval.status">
      <summary>
            Gets or sets the status of the approval process for the client.
            Setting this is like calling the relevant methods.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayerApproval.isAutoApproving">
      <summary>
            Is the player being automatically approved?
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayerApproval.isApproved">
      <summary>
            Is the player approved?
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayerApproval.isWaiting">
      <summary>
            Is the player waiting?
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayerApproval.isDenied">
      <summary>
            Is the player denied?
            </summary>
    </member>
    <member name="T:uLink.NetworkViewID">
      <summary>
            The NetworkViewID is a unique identifier for a network view instance in a multiplayer game.
            </summary>
      <remarks>
            It is important that this is unique for every network aware object across all connected peers, or 
            else RPCs and statesyncs can be sent to the wrong object. 
            </remarks>
    </member>
    <member name="F:uLink.NetworkViewID.unassigned">
      <summary>
            Represents an invalid network view ID.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewID.minManual">
      <summary>
            The minimum allowed ID which can be set manually for an object.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewID.maxManual">
      <summary>
            Maximum allowd ID which can be assigned manually to an object.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewID.allocator">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> who allocated the <see cref="T:uLink.NetworkView" />.
            </summary>
      <remarks>This can be someone other than owner. As an example, server might allocate the NetworkView for a client.</remarks>
    </member>
    <member name="M:uLink.NetworkViewID.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:uLink.NetworkViewID" /> struct.
            </summary>
      <remarks>Never use this unless you know what you are doing. New instances should be created automatically by uLink.
            For example when calling the uLink.Network.
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />
            function</remarks>
    </member>
    <member name="M:uLink.NetworkViewID.#ctor(System.Int32,uLink.NetworkPlayer)">
      <summary>
            Initializes a new instance of the <see cref="T:uLink.NetworkViewID" /> struct.
            </summary>
      <remarks>Never use this unless you know what you are doing. New instances should be created automatically by uLink.
            For example when calling the uLink.Network.
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />
            function</remarks>
    </member>
    <member name="M:uLink.NetworkViewID.op_Equality(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkViewID" />s are identical
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_Inequality(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkViewID" />s are not identical
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_GreaterThanOrEqual(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkViewID" /> is greater than or equal to the right <see cref="T:uLink.NetworkViewID" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_LessThanOrEqual(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkViewID" /> is less than or equal to the right <see cref="T:uLink.NetworkViewID" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_GreaterThan(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkViewID" /> is greater than the right <see cref="T:uLink.NetworkViewID" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_LessThan(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkViewID" /> is less than the right <see cref="T:uLink.NetworkViewID" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.GetHashCode">
      <summary>
            Returns the hash code for this <see cref="T:uLink.NetworkViewID" />.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this <see cref="T:uLink.NetworkViewID" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkViewID.Equals(System.Object)">
      <summary>
            Indicates whether this <see cref="T:uLink.NetworkViewID" /> and a specified object are equal.
            </summary>
      <returns>
        <c>true</c> if <paramref name="other" /> and this <see cref="T:uLink.NetworkViewID" /> are the same type and represent the same value; otherwise, <c>false</c>.
            </returns>
      <param name="other">Another object to compare to. </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkViewID.CompareTo(uLink.NetworkViewID)">
      <summary>
            Compares this instance with another specified <see cref="T:uLink.NetworkViewID" /> object and indicates
            whether this instance precedes, follows, or appears in the same position
            in the sort order as the specified <see cref="T:uLink.NetworkViewID" />.
            </summary>
      <param name="other">The other <see cref="T:uLink.NetworkViewID" />.</param>
      <returns>
            A 32-bit signed integer that indicates whether this instance precedes, follows,
            or appears in the same position in the sort order as the value parameter.
            </returns>
    </member>
    <member name="M:uLink.NetworkViewID.ToString">
      <summary>
            Returns a formatted string with details on this <see cref="T:uLink.NetworkViewID" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:uLink.NetworkViewID.id">
      <summary>
            This is the unique ID number for this networkView.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewID.isUnassigned">
      <summary>
            Gets a value indicating whether this instance is server.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewID.owner">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> who owns the <see cref="T:uLink.NetworkView" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewID.isMine">
      <summary>
            Gets a value indicating whether the <see cref="T:uLink.NetworkView" /> was instantiated by me.
            </summary>
      <value>
        <c>true</c> if instantiated by me/owned by me; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:uLink.NetworkViewID.isCellAuthority">
      <summary>
            Am i the cell server that has authority over this object.
            </summary>
      <value>
        <c>true</c> if i am the cell server which has authority over the object which this ViewID is for, <c>false</c> otherwise</value>
      <remarks>
            This is used for Pikko server.
            Read the Pikko server manual for more information.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewID.isManual">
      <summary>
            Gets a value indicating whether this <see cref="T:uLink.NetworkView" /> was set in the Unity editor and (and the value is lower than than Network.maxManualViewIDs)
            </summary>
    </member>
    <member name="P:uLink.NetworkViewID.isAllocated">
      <summary>
            Gets a value indicating whether this <see cref="T:uLink.NetworkView" /> was allocated at runtime (and the value is higher than Network.maxManualViewIDs)
            </summary>
    </member>
    <member name="T:uLink.NetworkStartEvent">
      <summary>
            The available types of network start events. See <see cref="!:uLink.Network.uLink_OnPreStartNetwork" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkStartEvent.MasterServer">
      <summary>
            A master server connection is about to be initialized
            </summary>
    </member>
    <member name="F:uLink.NetworkStartEvent.Server">
      <summary>
            The game server is about to be initialized
            </summary>
    </member>
    <member name="F:uLink.NetworkStartEvent.Client">
      <summary>
            A client is about to be initialized
            </summary>
    </member>
    <member name="F:uLink.NetworkStartEvent.CellServer">
      <summary>
            A cell server is about to be initialized
            </summary>
    </member>
    <member name="T:uLink.NetworkStatus">
      <summary>
            The available network statuses. See <see cref="P:uLink.Network.status" />. See also <see cref="P:uLink.Network.peerType" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkStatus.Disconnected">
      <summary>
            This peer is disconnected
            </summary>
    </member>
    <member name="F:uLink.NetworkStatus.Connecting">
      <summary>
            This peer is connecting
            </summary>
    </member>
    <member name="F:uLink.NetworkStatus.Connected">
      <summary>
            This peer is connected
            </summary>
    </member>
    <member name="F:uLink.NetworkStatus.Disconnecting">
      <summary>
            This peer is disconnecting
            </summary>
    </member>
    <member name="T:uLink.NetworkLogLevel">
      <summary>
            The available log levels that can be set for minimum uLink logging and also can be set per log category.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Off">
      <summary>
            Logs nothing.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Error">
      <summary>
            Logs errors only
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Warning">
      <summary>
            Logs warnings and errors.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Info">
      <summary>
            Logs info messages, warnings and errors.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Debug">
      <summary>
            Logs debug messages, info messages, warnings and errors. The most detailed log level available.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Informational">
      <summary>
            Deprecated, please use NetworkLogLevel.Info instead
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Full">
      <summary>
            Deprecated, please use NetworkLogLevel.Debug instead
            </summary>
    </member>
    <member name="T:uLink.NetworkLogFlags">
      <summary>
            The different log categories available in uLink. Read more in <see cref="T:uLink.NetworkLog" />.
            </summary>
    </member>
    <member name="T:uLink.NetworkRole">
      <summary>
            The role of a peer/host for a network aware object (created with <see cref="O:uLink.Network.Instantiate" />).
            </summary>
      <remarks>Read more in the manual about the three roles for network aware objects.</remarks>
    </member>
    <member name="F:uLink.NetworkRole.Disconnected">
      <summary>
            The peer/host is disconnected from the network.
            </summary>
    </member>
    <member name="F:uLink.NetworkRole.Proxy">
      <summary>
            This peer/host has a proxy of this network aware object.
            </summary>
    </member>
    <member name="F:uLink.NetworkRole.Owner">
      <summary>
            This peer/host is the owner of this network aware object.
            </summary>
    </member>
    <member name="F:uLink.NetworkRole.Creator">
      <summary>
            This peer/host is the creator of this network aware object.
            </summary>
    </member>
    <member name="T:uLink.NetworkFlags">
      <summary>
            Used to control how RPCs will be handled by uLink.
            </summary>
      <remarks>Turn on one or many the these bit flags to make uLink handle
            the RPC exactly the way you want it. The buffer flag argument will overrule
            the buffer setting that the <see cref="T:uLink.RPCMode" /> argument in the
            <see cref="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])" /> function 
            usually  controls. If they are conflicting, uLink  log a warning.</remarks>
    </member>
    <member name="F:uLink.NetworkFlags.Normal">
      <summary>
            This is the base value. The RPC will be reliable, buffered, encrypted, typesafe and include a timestamp.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.Unreliable">
      <summary>
            The RPC is sent over an unreliable network channel in uLink. Default is OFF.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.Unbuffered">
      <summary>
            The RPC is not stored in the RPC buffer on the server. This flag
            overrules the <see cref="T:uLink.RPCMode" /> buffer setting. Default Value is OFF.
            </summary>
      <value>
      </value>
    </member>
    <member name="F:uLink.NetworkFlags.Unencrypted">
      <summary>
            The RPC is never encrypted, even if security is turned on. Default value is OFF.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.NoTimestamp">
      <summary>
            The RPC has no timestamp (to save bandwidth). Default value is OFF.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.TypeUnsafe">
      <summary>
            The types of the arguments in the RPC will not be checked when this RPC is received. Default value is OFF.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.NoCulling">
      <summary>
            The RPC is not to be culled due to Scope or Group (except when the NetworkView is hidden). Default value is OFF.
            </summary>
    </member>
    <member name="T:uLink.NetworkStateSynchronization">
      <summary>
            The supported state synchronization modes for network aware objects in uLink
            </summary>
    </member>
    <member name="F:uLink.NetworkStateSynchronization.Off">
      <summary>
            This NetworkView will not send any statesync traffic
            </summary>
    </member>
    <member name="F:uLink.NetworkStateSynchronization.Unreliable">
      <summary>
            The statesync traffic will be unreliable (uses least server side resources, but some packets can be lost in the network).
            </summary>
    </member>
    <member name="F:uLink.NetworkStateSynchronization.Reliable">
      <summary>
            The statesync traffic will be reliable (all packets will arrive at destination).
            </summary>
    </member>
    <member name="F:uLink.NetworkStateSynchronization.ReliableDeltaCompressed">
      <summary>
            The statesync traffic will be reliable and delta compressed (to save bandwidth).
            </summary>
    </member>
    <member name="T:uLink.NetworkSecurable">
      <summary>
            The available choices for property "Securable" in a uLink.NetworkView component. 
            </summary>
    </member>
    <member name="F:uLink.NetworkSecurable.None">
      <summary>
             Secure nothing
            </summary>
    </member>
    <member name="F:uLink.NetworkSecurable.OnlyRPCs">
      <summary>
            Secure only RPCs which will be sent by this network aware object
            </summary>
    </member>
    <member name="F:uLink.NetworkSecurable.OnlyStateSynchronization">
      <summary>
            Secure only state synchronization for this network aware object
            </summary>
    </member>
    <member name="F:uLink.NetworkSecurable.Both">
      <summary>
            Secure both RPCs and state synchronization for this network aware object
            </summary>
    </member>
    <member name="T:uLink.NetworkDisconnection">
      <summary>
            The available reasons for a disconnection event in uLink. 
            </summary>
      <remarks>See uLink.Network.<see cref="!:uLink.Network.uLink_OnDisconnectedFromServer" /></remarks>
    </member>
    <member name="F:uLink.NetworkDisconnection.LostConnection">
      <summary>
            The client lost its connection to server.
            </summary>
    </member>
    <member name="F:uLink.NetworkDisconnection.Disconnected">
      <summary>
            The client disconnected from server.
            </summary>
    </member>
    <member name="F:uLink.NetworkDisconnection.Redirecting">
      <summary>
            The client disconnected from its already connected server to connect to another server.
            </summary>
    </member>
    <member name="T:uLink.PeerMode">
      <summary>
            The available modes for sending RPCs in a peer-to-peer network.
            </summary>
      <remarks>see <see cref="T:uLink.NetworkP2P" /></remarks>
    </member>
    <member name="F:uLink.PeerMode.Others">
      <summary>
            Send the RPC to all peers except myself.
            </summary>
    </member>
    <member name="F:uLink.PeerMode.All">
      <summary>
            Send the RPC to all peers including myself.
            </summary>
    </member>
    <member name="T:uLink.RPCMode">
      <summary>
            Indicates how a RPC should be treated by uLink.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.Server">
      <summary>
            The RPC will only be sent to the server. This is the only allowed RPCMode in clients when the server is authoritative.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.Others">
      <summary>
            The RPC will be sent to every connected peer and I will not get the RPC myself.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.All">
      <summary>
            The RPC will be sent to every connected peer, including myself.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.Owner">
      <summary>
            The RPC will only be sent to the owner of the network aware object.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.Buffered">
      <summary>
            The RPC will only be added to RPC buffer, which is sent to new players when their connection is established.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.OthersBuffered">
      <summary>
            The RPC will be sent to every connected peer and I will not get the RPC myself. The server will also buffer this RPC.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.AllBuffered">
      <summary>
            The RPC will be sent to every connected peer, including myself. The server will also buffer this RPC.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.OthersExceptOwner">
      <summary>
            The RPC will be sent to every connected peer, but not to myself and not to the owner of the network aware object.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.AllExceptOwner">
      <summary>
            The RPC will be sent to every connected peer, but not to the owner of the network aware object.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.OthersExceptOwnerBuffered">
      <summary>
            The RPC will sent to every connected peer except me and owner of the network aware object. The server will also buffer this RPC.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.AllExceptOwnerBuffered">
      <summary>
            The RPC will sent to every connected peer except owner, including myself. The server will also buffer this RPC.
            </summary>
    </member>
    <member name="T:uLink.NetworkPeerType">
      <summary>
            A peer can be only one of these types. See <see cref="P:uLink.Network.peerType" />. See also <see cref="P:uLink.Network.status" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkPeerType.Disconnected">
      <summary>
            The peer is disconnected
            </summary>
    </member>
    <member name="F:uLink.NetworkPeerType.Server">
      <summary>
            The peer is a server
            </summary>
    </member>
    <member name="F:uLink.NetworkPeerType.Client">
      <summary>
            The peer is a client
            </summary>
    </member>
    <member name="F:uLink.NetworkPeerType.CellServer">
      <summary>
            This peer is a cell server
            </summary>
    </member>
    <member name="T:uLink.NetworkConnectionError">
      <summary>
            The available connection errors in uLink.
            </summary>
      <remarks>Use the value UserDefined1 for signaling your own custom error situation to the client.
            Send this error code from the server code you write for the the callback 
            <see cref="!:uLink.Network.uLink_OnPlayerApproval" />.
            If you need more custom error codes, just add the integers 1, 2, 3 and so on to the user defined value.
            </remarks>
      <example>
            Define your own error codes like this in a script the server and the clients can both access.
            <code>
            public int MyErrorCode1 = uLink.NetworkConnectionError.UserDefined1;
            public int MyErrorCode2 = uLink.NetworkConnectionError.UserDefined1 + 1;
            public int MyErrorCode3 = uLink.NetworkConnectionError.UserDefined1 + 2;
            </code></example>
    </member>
    <member name="F:uLink.NetworkConnectionError.AlreadyConnectedToAnotherServer">
      <summary>
            The client is already connected to another server. uLink client can only connect to one uLink server at the same time.
            </summary>
    </member>
    <member name="F:uLink.NetworkConnectionError.NoError">
      <summary>
            It means no error is returned but you should wait for <see cref="!:uLink.Network.uLink.OnConnectedToServer" />
            to see if the connection was successful or not, the connection might time out and fails later on.
            </summary>
    </member>
    <member name="F:uLink.NetworkConnectionError.TooManyConnectedPlayers">
      <summary>
            The server has the most number of clients which it can have (the max
            number of clients is set when initializing the server), so it can not accept new players.
            </summary>
    </member>
    <member name="F:uLink.NetworkConnectionError.RSAPublicKeyMismatch">
      <summary>
            The public key of the client doesn't match with the private key of the server.
            See the manual chapter for security for more information.
            </summary>
    </member>
    <member name="F:uLink.NetworkConnectionError.InvalidPassword">
      <summary>
            The password sent by the client is different from what server expects as incoming password.
            </summary>
    </member>
    <member name="F:uLink.NetworkConnectionError.IncompatibleVersions">
      <summary>
            Client and server use different incompatible uLink versions.
            </summary>
    </member>
    <member name="F:uLink.NetworkConnectionError.IsAuthoritativeServer">
      <summary>
            Server is authoritative but client did not set <see cref="P:uLink.Network.isAuthoritativeServer" /> to <c>true</c>.
            </summary>
    </member>
    <member name="F:uLink.NetworkConnectionError.ApprovalDenied">
      <summary>
            Server did not approve the client. However you don't have to use this value as the reason when denying.
            </summary>
    </member>
    <member name="F:uLink.NetworkConnectionError.UserDefined1">
      <summary>
            This can be used for any user defined purpose. You can use UserDefined + X where X is a positive number
            to have more user defined values.
            </summary>
    </member>
    <member name="T:uLink.ConnectionTesterStatus">
      <summary>
            The available return values when testing a network connection's NAT
            capabilities.
            </summary>
      <remarks>
            See <see cref="O:uLink.Network.TestConnection" />
            and <see cref="M:uLink.Network.TestConnectionNAT" />.
            </remarks>
    </member>
    <member name="T:uLink.MasterServerEvent">
      <summary>
            The available response codes when communicating with a stand-alone <see cref="T:uLink.MasterServer" />.
            </summary>
    </member>
    <member name="F:uLink.MasterServerEvent.RegistrationSucceeded">
      <summary>
            Registration of the server in master server has been done successfully.
            </summary>
    </member>
    <member name="F:uLink.MasterServerEvent.HostListReceived">
      <summary>
            Host list received after <see cref="M:uLink.MasterServer.PollHostList" /> was invoked in client. 
            </summary>
    </member>
    <member name="F:uLink.MasterServerEvent.LocalHostDiscovered">
      <summary>
            Local host discovered after <see cref="M:uLink.MasterServer.DiscoverLocalHosts(System.String,System.Int32)" /> was invoked in client.
            </summary>
    </member>
    <member name="F:uLink.MasterServerEvent.KnownHostDataReceived">
      <summary>
            Known host data received after <see cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" /> was invoked in client.
            </summary>
    </member>
    <member name="F:uLink.MasterServerEvent.RegistrationFailedNoProxy">
      <summary>
            MasterServer is not running as proxy server but the game server requires a proxy server.
            </summary>
      <remarks>
            See MasterServer manual page for more information.
            </remarks>
    </member>
    <member name="T:uLink.NetworkP2PEvent">
      <summary>
            The event name inside <see cref="!:uLink.NetworkP2P.uLink_OnPeerEvent" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PEvent.LocalPeerDiscovered">
      <summary>
            local peers discovered after <see cref="M:uLink.NetworkP2PBase.DiscoverLocalPeers(System.String,System.Int32)" /> was invoked.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PEvent.KnownPeerDataReceived">
      <summary>
            Local peers data received after <see cref="M:uLink.NetworkP2PBase.RequestKnownPeerData(System.String,System.Int32)" /> was invoked. 
            </summary>
    </member>
    <member name="T:uLink.NetworkGroupFlags">
      <summary>
            These are the network group settings which can be set per group.
            </summary>
    </member>
    <member name="F:uLink.NetworkGroupFlags.None">
      <summary>
            None of the flags are not set.
            </summary>
    </member>
    <member name="F:uLink.NetworkGroupFlags.AddNewPlayers">
      <summary>
            Add new players to group automatically when they connect to server
            </summary>
    </member>
    <member name="F:uLink.NetworkGroupFlags.HideGameObjects">
      <summary>
            If set, GameObjects that belong to group will be destroyed in players which are not 
            a member of this group and will be instantiated in the players as soon as they become
            member.
            </summary>
    </member>
    <member name="T:uLink.BitStreamTypeCode">
      <summary>
            The data types uLink can Serialize. Read more about this in the manual section for data types and serialization.
            </summary>
    </member>
    <member name="T:uLink.NetworkPeer">
      <summary>
            Represents one peer/host i a peer-to-peer network.
            </summary>
      <remarks>There are some similarities between NetworkPeer and <see cref="T:uLink.NetworkPlayer" /> in client server
            networks. for example you can use a peer reference to send RPCs to the specific peer, just 
            like what you can do with network players in client server setups.</remarks>
    </member>
    <member name="F:uLink.NetworkPeer.unassigned">
      <summary>
            Represents a peer which is not initialized yet.
            </summary>
    </member>
    <member name="M:uLink.NetworkPeer.#ctor(System.Int32)">
      <summary>
            Initializes a peer.
            </summary>
      <param name="localPort">The port that we should listen to.</param>
    </member>
    <member name="M:uLink.NetworkPeer.#ctor(System.String,System.Int32)">
      <summary>
            Initializes a peer.
            </summary>
      <param name="hostnameOrIP">Host name or IP address of the peer.</param>
      <param name="port">The port that peer should listen to.</param>
    </member>
    <member name="M:uLink.NetworkPeer.#ctor(System.Net.IPAddress,System.Int32)">
      <summary>
            Initializes a peer.
            </summary>
      <param name="ip">IP address of the peer.</param>
      <param name="port">The port that the peer should listen to.</param>
    </member>
    <member name="P:uLink.NetworkPeer.ipAddress">
      <summary>
            Returns the IP address of the peer as a string.
            </summary>
      <remarks>If not initialized yet, <see cref="F:uLink.NetworkPeer.unassigned" />'s IP will be returned.</remarks>
    </member>
    <member name="P:uLink.NetworkPeer.port">
      <summary>
            Returns the port of the peer.
            </summary>
      <remarks>If not initialized yet, <see cref="F:uLink.NetworkPeer.unassigned" />'s port will be returned.</remarks>
    </member>
    <member name="T:uLink.NetworkViewBase">
      <summary>
            Abstract base class for the class <see cref="T:uLink.NetworkView" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewBase.stateSynchronization">
      <summary>
            The kind of state synchronization used for this object.
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkStateSynchronization.Unreliable" />.</value>
      <remarks>Read more in the uLink manual under the State Synchronization section. 
            The <see cref="P:uLink.Network.sendRate" /> can be used to configure the sending frequency 
            for state synchronization.</remarks>
    </member>
    <member name="F:uLink.NetworkViewBase.securable">
      <summary>
            Specifies the possibility to encrypt RPC traffic or statesync traffic or both.
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkSecurable.Both" />.</value>
      <remarks>Read the manual section on secure communication for more information.</remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetManualViewID(System.Int32)">
      <summary>
            Assigns the manual view ID for a GameObject.
            </summary>
      <remarks>This method can be used if the game programmer did not set the manualViewID for a 
            Game Object. The normal situation is that the game programmer places a GameObject in the Unity 
            editor's hierarchy view. After that, the programmer adds the component uLink.NetworkView and assigns 
            a manual view ID for that component. The programmers chooses a unique number like 1, 2, 3, etc.
            The maximum number is dictated by <see cref="P:uLink.Network.maxManualViewIDs" />.
            This function performs exactly the same thing, it makes it possible to write a script that sets 
            the manual view IDs for many GameObjects in a scene. 
            In addition: Several overloaded versions of the method <see cref="O:uLink.Network.Instantiate" />
            do the assignement of view IDs automatically. uLink uses viewIDs above the limit 
            <see cref="P:uLink.Network.maxManualViewIDs" /> for these automatic assignments. In some special situations 
            it can be handy to allocate a manual viewID first and then send this viewID as one of the arguments to 
            the uLink.Network.Instantiate method that accepts a viewID as one of the arguments.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetInitialData(System.Object[])">
      <summary>
            Sets the initial data for this network aware object.
            </summary>
      <remarks>Only use this function if you are working with custom allocation of viewIDs and needs to set
            the initial data for a network aware object. Normally, the initial data can be specified in the call to 
            one of the 
            <see cref="O:uLink.Network.Instantiate" /> 
            functions. Never use this function unless 
            you know what you are doing and you are working with custom allocation of viewIDs at runtime 
            (<see cref="O:uLink.Network.AllocateViewID" />).
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkPlayer)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The viewID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="owner">Will become the owner of this object</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkPlayer,uLink.NetworkGroup)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The viewID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="owner">Will become the owner of this object</param>
      <param name="group">Will become the group of this object. Default value is unassigned.</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkPlayer,uLink.NetworkGroup,System.Boolean)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The viewID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="owner">Will become the owner of this object</param>
      <param name="group">Will become the group of this object. Default value is unassigned.</param>
      <param name="isInstantiatedRemotely">Will let uLink know this object has been instantiated remotely. Default value is false.</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkMessageInfo)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The view ID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="info">The sender of <see cref="T:uLink.NetworkMessageInfo" />
            will become the owner and the creator for this object</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
      <example>
            Can be used when instantiating NPCs in MMO games.
            This method is usually called in all clients after receiving the viewID from the server via some 
            RPC call. Then the clients will become aware that the server has the owner and creater role for 
            this NPC Game Object.
            </example>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkMessageInfo,uLink.NetworkGroup)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The view ID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="info">The sender of <see cref="T:uLink.NetworkMessageInfo" />
            will become the owner and the creator for this object</param>
      <param name="group">The group which this NetworkView will belong to</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
      <example>
            Can be used when instantiating NPCs in an MMO game.
            This method is usually called in all clients after receiving the viewID from the server via some 
            RPC call. Then the clients will become aware that the server has the owner and creater role for 
            this NPC Game Object.
            </example>
    </member>
    <member name="M:uLink.NetworkViewBase.SetUnassignedViewID">
      <summary>
            Removes the assigned viewID from this NetworkView.
            </summary>
      <remarks>
            Be aware that the viewID is still allocated. The next logical next is usually a call to <see cref="M:uLink.Network.DeallocateViewID(uLink.NetworkViewID)" />.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.AllocateViewID">
      <summary>
            Allocates one free viewID and sets it to this NetworkView. 
            </summary>
      <remarks>
            Only for advanced users. Works like <see cref="O:uLink.Network.AllocateViewID" />, but 
            in addition it sets the viewID to this NetworkView and the owner and 
            creator will become this <see cref="T:uLink.NetworkPlayer" />.
            <para>
            Can only be called in an authoritative server or in authoritative clients.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.DeallocateViewID">
      <summary>
            Returns an unused viewID to the pool of unused IDs. Can only be called on the same peer as the viewID was allocated.
            </summary>
      <remarks>
            Works like <see cref="M:uLink.Network.DeallocateViewID(uLink.NetworkViewID)" /><para>
            Can only be called in an authoritative server or in authoritative clients.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetChildren(uLink.NetworkViewBase[])">
      <summary>
            Sets the provided arguments as children of this NetworkView.
            </summary>
      <param name="children">The network views that we want to make our children.</param>
      <returns>If the operation was successful or not.</returns>
    </member>
    <member name="M:uLink.NetworkViewBase.GetChild(System.Int32)">
      <summary>
            Returns a child of the network view.
            </summary>
      <param name="childIndex">Index of the child.</param>
      <returns>The child if could be found, An exception could be thrown if you send an invalid index (System.OutOfRangeException).</returns>
    </member>
    <member name="M:uLink.NetworkViewBase.SetScope(uLink.NetworkPlayer,System.Boolean)">
      <summary>
            Sets the scope of a player against this network view.
            </summary>
      <param name="target">The player that we want to set its scope against ourself.</param>
      <param name="relevancy">if <c>true</c> the plyaer receives our RPCs and state
            syncs, otherwise not.</param>
      <returns>The effective relevancy of this network view for the target.</returns>
      <remarks>
            The player will not receive RPCs nd state syncs but the object will exists in the player's machine.
            A feature like the hide game objects feature in network groups doesn't exists here.
            You should use that feature for situations which require it and probably use scope for area of interest management and ....
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.GetScope(uLink.NetworkPlayer)">
      <summary>
            Gets the scope of a player gainst this network view.
            </summary>
      <param name="target">The player that we	want to see our relevancy against.</param>
      <returns>The relevancy of this network view against the player. if <c>true</c>
            then the player will receive RPCs and state syncs for the network view, otherwise not.</returns>
      <remarks>
            The player will not receive RPCs nd state syncs but the object will exists in the player's machine.
            A feature like the hide game objects feature in network groups doesn't exists here.
            You should use that feature for situations which require it and probably use scope for area of interest management and ....
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.ResetScope">
      <summary>
            The scope for all players will be set to true against this network view.
            Everyone will receive our state syncs and RPCs.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.proxyPrefab">
      <summary>
            The prefab name used to find the proxy prefab.
            </summary>
      <remarks>
            This is only used during handover.
            <see cref="O:uLink.Network.Instantiate" /> automatically assigns this value during instantiation, so you don't have to worry about it.
            But if you have instantiated the object yourself and want to be able to handover it you will have to set this to the prefab name which uLink can use to find the proxy prefab.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.ownerPrefab">
      <summary>
            The prefab name used to find the owner prefab.
            </summary>
      <remarks>
            This is only used during handover.
            <see cref="O:uLink.Network.Instantiate" /> automatically assigns this value during instantiation, so you don't have to worry about it.
            But if you have instantiated the object yourself and want to be able to handover it you will have to set this to the prefab name which uLink can use to find the owner prefab.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.serverPrefab">
      <summary>
            The prefab name used to find the server prefab.
            </summary>
      <remarks>
            This is only used during handover.
            <see cref="O:uLink.Network.Instantiate" /> automatically assigns this value during instantiation, so you don't have to worry about it.
            But if you have instantiated the object yourself and want to be able to handover it you will have to set this to the prefab name which uLink can use to find the authority prefab.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.cellAuthPrefab">
      <summary>
            The prefab name used to find the cell server auth prefab.
            </summary>
      <remarks>
            This is only used during handover.
            <see cref="O:uLink.Network.Instantiate" /> automatically assigns this value during instantiation, so you don't have to worry about it.
            But if you have instantiated the object yourself and want to be able to handover it you will have to set this to the prefab name which uLink can use to find the authority prefab.
            <para>
            This is used on Pikko server for the cell server which has authority over the networked object.
            </para></remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.cellProxyPrefab">
      <summary>
            The prefab name used to find the cell server proxy prefab.
            </summary>
      <remarks>
            This is only used during handover.
            <see cref="O:uLink.Network.Instantiate" /> automatically assigns this value during instantiation, so you don't have to worry about it.
            But if you have instantiated the object yourself and want to be able to handover it you will have to set this to the prefab name which uLink can use to find the authority prefab.
            <para>
            This is used on Pikko server for the cell servers which have the proxy role for the networked object.
            </para></remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.owner">
      <summary>
            Gets the owner for this network aware object.
            </summary>
      <remarks>Read more in the uLink manual about the three roles for network aware objects.</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.isMine">
      <summary>
            Gets a value indicating whether this instance is mine (and then I have the owner role).
            </summary>
      <value>
        <c>true</c> if this instance is mine; otherwise, <c>false</c>.</value>
      <remarks>Read more in the uLink manual about the three roles for objects created 
            with <see cref="O:uLink.Network.Instantiate" />.</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.isOwner">
      <summary>
            Gets a value indicating whether the current NetworkPlayer is the owner this object. Same as <see cref="P:uLink.NetworkViewBase.isMine" />.
            </summary>
      <value>
        <c>true</c> if this instance is mine; otherwise, <c>false</c>.</value>
      <remarks>Read more in the uLink manual about the three roles for objects created 
            with <see cref="O:uLink.Network.Instantiate" />.</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.isProxy">
      <summary>
            Gets a value indicating whether this instance of the network aware object is a normal uLink proxy.
            </summary>
      <remarks>
            This value being true implies the object does not have <see cref="O:uLink.NetworkViewBase.isAuthority" /> set to true.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.isCellAuthority">
      <summary>
            Indicates whether the current NetworkPlayer is the cell server authority of this object (in a PikkoServer) system.
            </summary>
      <remarks>
            A cell server authority is allowed to and responsible for mutating the state of this object.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.isCellProxy">
      <summary>
            Indicates whether this object is a cell server proxy for the current NetworkPlayer (in a PikkoServer) system.
            </summary>
      <remarks>
            A cell server proxy provides a representation of the network object on other cell servers than the one holding the authority.
            The object's state should only be mutated by the cell server authority, and mirrored on this proxy to the extent desireable.
            This value being true implies the object does not have <see cref="O:uLink.NetworkViewBase.isCellAuthority" /> set to true.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.authority">
      <summary>
            Gets the authoritative player over this object.
            </summary>
      <value>
        <see cref="F:uLink.NetworkPlayer.server" /> if authoritative server is enabled; otherwise, same as <see cref="P:uLink.NetworkViewBase.owner" />.</value>
      <remarks>Read more in the uLink manual about the three roles for network aware objects.</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.isAuthority">
      <summary>
            Gets a value indicating whether this instance of the network aware object has authority.
            </summary>
      <value>
        <c>true</c> if authoritative server is enabled and the instance is on the server; otherwise, same as <see cref="P:uLink.NetworkViewBase.isOwner" />.</value>
    </member>
    <member name="P:uLink.NetworkViewBase.localPrefab">
      <summary>
            Gets a prefab used to instantiate this local object.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.initialData">
      <summary>
            Gets or sets the <see cref="T:uLink.BitStream" /> for initial data for 
            this network aware object.
            </summary>
      <remarks>The initial data can be specified in the call to one of the
            <see cref="O:uLink.Network.Instantiate" /> methods. 
            After that, the initialData can be retrieved via this
            property. Never set this property manually unless you know what you
            are doing and you are working with custom allocation of viewIDs at
            runtime (<see cref="O:uLink.Network.AllocateViewID" />).
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.childIndex">
      <summary> 
            Gets the child index for this NetworkView. (When multiple NetworkViews per game object is used)
            </summary>
      <remarks>
            Avoid using multiple NetworkViews for game objects instantiated with <see cref="O:uLink.Network.Instantiate" />.
            Read more about multiple NetworkViews in the Network Views manual chapter.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.childCount">
      <summary>
            Returns the number of NetworkViews which are children of the object which has this NetworkView attached.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.parent">
      <summary>
            The NetworkVIew which is the parent of this one.
            </summary>
      <remarks>GameObjects with NetworkViews can have childs which have network views as well.
            Then RPCs sent to the parent will be sent to them as well and they share their ViewID with their parent.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.root">
      <summary>
            The NetworkView which is the root of the hierarchy of this NetworkView.
            </summary>
      <remarks>If this is the root, the result will be equal to this</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.viewID">
      <summary>
            Gets the view ID for this network aware object.
            </summary>
      <remarks>
            The set-property is obsolete, use <see cref="O:uLink.NetworkViewBase.SetViewID" /> or <see cref="M:uLink.NetworkViewBase.SetManualViewID(System.Int32)" /> instead.
            This is only for backward compatibility with Unity's built-in networking. The owner and creator will be set to NetworkPlayer.server which may not be desired.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.group">
      <summary>
            The RPC communication group used by this NetworkView.
            </summary>
      <remarks>players which are not in this group, will not receive state syncs and RPCs from the NetworkView</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.authFlags">
      <summary>
            Get or set a bitwise combination of flags that control various options such as handover enabling.
            Only possible to use if the local player is the authority of this NetworkView.
            See the <see cref="T:uLink.NetworkAuthFlags" /> enum for more info.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.isInstantiatedRemotely">
      <summary>
            Indicates if the NetworkView instantiated remotely or not.
            If we are the caller of Instantiaate or allocator of this NetworkView, it will return false.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.position">
      <summary>
            Gets the position for this Network View.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.rotation">
      <summary>
            Gets the rotation for this Network View.
            </summary>
    </member>
    <member name="T:uLink.NetworkP2PHandoverFlags">
      <summary>
            For setting <see cref="M:uLink.NetworkP2P.Handover(UnityEngine.Object,uLink.NetworkPeer,uLink.NetworkP2PHandoverFlags,System.Object[])" /> mode.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverFlags.Normal">
      <summary>
            This is the normal mode which destroys the object in its current node and instantiates it in the other node and also redirects its owner to it.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverFlags.DontDestroyOriginal">
      <summary>
            If set, the object in the original/current node is not destroyed.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PHandoverFlags.DontRedirectOwner">
      <summary>
            If set, the owner <see cref="T:uLink.NetworkPlayer" /> will not be redirected to the new node.
            </summary>
    </member>
    <member name="T:uLink.NetworkP2PBase">
      <summary>
            Abstract base class for the class <see cref="T:uLink.NetworkP2P" />. 
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PBase.comment">
      <summary>
            The comment field for this NetworkP2P,
            This field can be used for anything you want and is returned in the peer info when you use
            <see cref="M:uLink.NetworkP2PBase.DiscoverLocalPeers(System.String,System.Int32)" /></summary>
    </member>
    <member name="F:uLink.NetworkP2PBase.incomingPassword">
      <summary>
            Set this string to use a password check for incoming P2P connections. 
            </summary>
      <remarks>
            Default value for incomingPassword is an empty string. Then there is no password check when som other peer
            tries to connect to this peer. But if this string is set, the password must be provided in 
            the connection request to this peer.</remarks>
    </member>
    <member name="F:uLink.NetworkP2PBase.lastError">
      <summary>
            Gets the last returned <see cref="T:uLink.NetworkConnectionError" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.#ctor">
      <summary>
            Creates a new instance of the class.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.InverseTransform(UnityEngine.Vector3@,UnityEngine.Quaternion@)">
      <summary>
            Transforms the provided position and rotation from world space to local space.
            </summary>
      <param name="pos">The position to apply the transformation on.</param>
      <param name="rot">The rotation to apply the transformation on.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.Transform(UnityEngine.Vector3@,UnityEngine.Quaternion@)">
      <summary>
            Transforms a position and rotation from local space to world space.
            </summary>
      <param name="pos">The position to apply the transformation on.</param>
      <param name="rot">The rotation to apply the transformation on.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.GetStatus(uLink.NetworkPeer)">
      <summary>
            Gets the <see cref="T:uLink.NetworkStatus" /> of a remote node connected to this peer.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.GetAveragePing(uLink.NetworkPeer)">
      <summary>
            Gets the average ping time between the target peer and ourself.
            </summary>
      <param name="target">The peer that we want to know the average ping between it and ourself.</param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkP2PBase.GetLastPing(uLink.NetworkPeer)">
      <summary>
            Gets the last ping between us and the target.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkP2PBase.GetStatistics(uLink.NetworkPeer)">
      <summary>
            Gets the <see cref="T:uLink.NetworkStatistics" /> for a remote node connected to this peer, which can be used to get connection statistics, bandwidth, packet counts etc.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.Connect(uLink.NetworkPeer,System.String)">
      <summary>
            Tries to connect to another peer.
            </summary>
      <param name="target">The peer that we want to connect to.</param>
      <param name="incomingPassword">The password that the other peer expect us to send.</param>
      <remarks>It's only required to use this overload with password if <see cref="!:uLink.NetworkP2P.incommingPassword" /> is set in the target peer.</remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.CloseConnection(uLink.NetworkPeer,System.Boolean)">
      <summary>
            Closes the connection to a remote node.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.CloseConnection(uLink.NetworkPeer,System.Boolean,System.Int32)">
      <summary>
            Closes the connection to a remote node after the given timeout has expired
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.UnreliableRPC(System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an unreliable RPC to another peer.
            </summary>
      <param name="rpcName">Name of the RPC to call.</param>
      <param name="target">The peer that we want to send the RPC to.</param>
      <param name="args">The arguments that we want to send to the RPC.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.UnreliableRPC(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPeer},System.Object[])">
      <summary>
            Sends an unreliable RPC to a set of peers.
            </summary>
      <param name="rpcName">Name of the RPC to send.</param>
      <param name="targets">The peers that we want to send the RPC to.</param>
      <param name="args">The arguments that we want to send to the RPC.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.UnreliableRPC(System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an unreliable RPC to peers dictated by <c>mode</c> parameter.
            </summary>
      <param name="rpcName">Name of the RPC to call.</param>
      <param name="mode">This parameter dictates who will receive the RPC.</param>
      <param name="args">The arguments to send to the RPC</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.String,uLink.NetworkPeer,System.Object[])">
      <overloads>Sends an RPC from this P2P connection</overloads>
      <summary>
             Sends a reliable RPC to a remote node.
             </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPeer},System.Object[])">
      <summary>
            Sends a reliable RPC to a set of peers.
            </summary>
      <param name="rpcName">The name of the RPC that we want to call.</param>
      <param name="targets">The peers that we want to send the RPC to them.</param>
      <param name="args">The arguments that we want to send to the RPC.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends a reliable RPC to remote node(s) according to the specified PeerMode.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(uLink.NetworkFlags,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC to one remote node.
            </summary>
      <param name="flags">This parameter dictates the properties of the RPC like reliability, security ...</param>
      <param name="rpcName">Name of the RPC to call.</param>
      <param name="target">The peer that we want to send the RPC to.</param>
      <param name="args">The arguments that we want to send to the RPC.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPeer},System.Object[])">
      <summary>
            Sends an RPC with properties dictated by <c>flags</c> parameter to a set of peers.
            </summary>
      <param name="flags">This parameter determines properties of the RPC like reliability, security and ...</param>
      <param name="rpcName">Name of the RPC to call.</param>
      <param name="targets">The set of peers that we want to send the RPC to them.</param>
      <param name="args">The arguments that we want to send to the RPC.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(uLink.NetworkFlags,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Send an RPC to remote node(s) according to the specified <see cref="T:uLink.PeerMode" /> and with properties dictated by <c>flags</c> parameter..
            </summary>
      <param name="flags">This parameter dictates the properties of the RPC like reliability, security and ...</param>
      <param name="rpcName">Name of the RPC to call.</param>
      <param name="mode">This parameter dictates who will receive the RPC.</param>
      <param name="args">The arguments that we want to send to the RPC</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPeer},System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPeer},System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPeer},System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPeer},System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.HandoverPlayerObjects(uLink.NetworkPlayer,uLink.NetworkPeer)">
      <summary>
            Hands over all objects owned by a player to another peer.
            </summary>
      <param name="owner">The <see cref="T:uLink.NetworkPlayer" /> that you want to move its objects.</param>
      <param name="target">The peer that you want to move objects to it.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.HandoverPlayerObjects(uLink.NetworkPlayer,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
            Hands over all objects owned by a player to another peer and transforms all of them by the provided offset.
            </summary>
      <param name="owner">The <see cref="T:uLink.NetworkPlayer" /> that you want to move its objects.</param>
      <param name="target">The peer that you want to move objects to it.</param>
      <param name="offsetPos">Offset applied to positions of objects.</param>
      <param name="offsetRot">Offset applied to rotation of objects.</param>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkP2PBase.HandoverPlayerObjects(uLink.NetworkPlayer,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkP2PHandoverFlags,System.Object[])" -->
    <member name="M:uLink.NetworkP2PBase.Handover(uLink.NetworkViewBase,uLink.NetworkPeer)">
      <summary>
            Hands over the object which has the provided network view to the <c>target</c> peer.
            </summary>
      <param name="netView">The <see cref="T:uLink.NetworkView" /> which we want to hand over its object.</param>
      <param name="target">The peer that we want to choose as destination of the handover.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.Handover(uLink.NetworkViewBase,uLink.NetworkPeer,uLink.NetworkP2PHandoverFlags,System.Object[])">
      <summary>
            Hands over an object to another peer.
            </summary>
      <param name="netView">NetworkView of the object that you want to handover.</param>
      <param name="target">The receiver peer of the handover</param>
      <param name="flags">properties of the handover</param>
      <param name="handoverData">The additional data that you want to send to the receiver of the handover.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.Handover(uLink.NetworkViewBase,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
            Hand an object over to another peer.
            </summary>
      <param name="netView">NetworkView of the object that you want to handover.</param>
      <param name="target">The receiver peer of the handover</param>
      <param name="relativePos">Position of the object in the receiving side relative to the NetworkP2P object</param>
      <param name="relativeRot">Rotation of the object in the receiving side relative to the NetworkP2P object</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.Handover(uLink.NetworkViewBase,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkP2PHandoverFlags,System.Object[])">
      <summary>
            Hand an object over to another peer.
            </summary>
      <param name="netView">NetworkView of the object that you want to handover.</param>
      <param name="target">The receiver peer of the handover</param>
      <param name="relativePos">Position of the object in the receiving side relative to the NetworkP2P object</param>
      <param name="relativeRot">Rotation of the object in the receiving side relative to the NetworkP2P object</param>
      <param name="flags">Settings of the handover.</param>
      <param name="handoverData">The additional data that you want to send to the receiving side of the handover.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.Handover(uLink.NetworkP2PHandoverInstance[],uLink.NetworkPeer)">
      <summary>
            Hands over a set of <see cref="T:uLink.NetworkP2PHandoverInstance" /> objects to another peer.
            </summary>
      <param name="instances">The array of handoverInstance objects</param>
      <param name="target">The peer which should receive the handovered objects.</param>
      <remarks>
            A <see cref="T:uLink.NetworkP2PHandoverInstance" /> object contains the whole information required for an object to
            be handovered and you can customize them in any way you want as well.
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkP2PBase.Handover(uLink.NetworkP2PHandoverInstance[],uLink.NetworkPeer,uLink.NetworkP2PHandoverFlags,System.Object[])" -->
    <member name="M:uLink.NetworkP2PBase.ClearDiscoveredPeers">
      <summary>
            Clears the list of peers discovered.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollDiscoveredPeers">
      <summary>
            Gets the list of peers discovered by calling <see cref="M:uLink.NetworkP2PBase.DiscoverLocalPeers(System.String,System.Int32)" /></summary>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkP2PBase.DiscoverLocalPeers(System.String,System.Int32)">
      <summary>
            Sends a broadcast message to discover peers on the LAN.
            </summary>
      <param name="filterGameType">The <see cref="!:uLink.NetworkP2P.gameType" /> of the peers that we are interested in.</param>
      <param name="remotePort">The port that the peers are listening to.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.DiscoverLocalPeers(System.String,System.Int32,System.Int32)">
      <summary>
            Sends a broadcast message on multiple ports to discover peers on the LAN.
            </summary>
      <param name="filterGameType">The <see cref="!:uLink.NetworkP2P.gameType" /> of the peers that we are interested in.</param>
      <param name="remoteStartPort">The starting port number.</param>
      <param name="remoteEndPort">The ending port number.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.DiscoverLocalPeers(uLink.PeerDataFilter,System.Int32)">
      <summary>
            Sends a broadcast message to discover peers on the LAN.
            </summary>
      <param name="filter">The filter which we should filter the list based on it.</param>
      <param name="remotePort">The port that peers are listening to.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.DiscoverLocalPeers(uLink.PeerDataFilter,System.Int32,System.Int32)">
      <summary>
            Sends a broadcast message on multiple ports to discover peers on the LAN.
            </summary>
      <param name="filter">The filter which we should filter the list based on it.</param>
      <param name="remoteStartPort">The starting port</param>
      <param name="remoteEndPort">The ending port</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollAndDiscoverLocalPeers(System.String,System.Int32,System.Single)">
      <summary>
            Polls the list of already discovered peers and sends a discovery request if <c>discoverInterval</c> time passed from the previous discovery request.
            </summary>
      <param name="filterGameType">The <see cref="!:uLink.NetworkP2P.gameType" /> tht we are interested in.</param>
      <param name="remotePort">The port that the peers are listening to.</param>
      <param name="discoverInterval">The amount of time which should pass until we can send another discovery request.</param>
      <returns>
      </returns>
      <remarks>
            You can even put this method in Update and set <c>discoverInterval</c> to some time like 2 seconds
            Then each 2 seconds a discovery request will be sent and in each frame you poll for the discovered list.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollAndDiscoverLocalPeers(System.String,System.Int32,System.Int32,System.Single)">
      <summary>
            Polls the list of already discovered peers and sends a discovery request if <c>discoverInterval</c> time passed from the previous discovery request.
            </summary>
      <param name="filterGameType">The <see cref="!:uLink.NetworkP2P.gameType" /> tht we are interested in.</param>
      <param name="remoteStartPort">The starting port of the range which peers are listening to.</param>
      <param name="remoteEndPort">The ending port of the range which peers are listening to.</param>
      <param name="discoverInterval">The amount of time which should pass until we can send another discovery request.</param>
      <returns>
      </returns>
      <remarks>
            You can even put this method in Update and set <c>discoverInterval</c> to some time like 2 seconds
            Then each 2 seconds a discovery request will be sent and in each frame you poll for the discovered list.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollAndDiscoverLocalPeers(uLink.PeerDataFilter,System.Int32,System.Single)">
      <summary>
            It's like <see cref="M:uLink.NetworkP2PBase.PollAndDiscoverLocalPeers(System.String,System.Int32,System.Single)" />, except you can set
            a filter based on many peer properties instead of only game type.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollAndDiscoverLocalPeers(uLink.PeerDataFilter,System.Int32,System.Int32,System.Single)">
      <summary>
            It's just like <see cref="M:uLink.NetworkP2PBase.PollAndDiscoverLocalPeers(System.String,System.Int32,System.Int32,System.Single)" /> except you can choose a more
            advanced filter based on properties other than game type as well.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.ClearKnownPeers">
      <summary>
            Clears the list of known peers choosen as favorite.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollKnownPeerData(System.String,System.Int32)">
      <summary>
            Returns a favorite known peer's data.
            </summary>
      <param name="host">The host address of the peer.</param>
      <param name="remotePort">The port that this peer is listening to.</param>
      <returns>The peer's full data.</returns>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollKnownPeerData(uLink.NetworkEndPoint)">
      <summary>
            Returns the data related to a known peer
            </summary>
      <param name="target">The IP and port of the peer</param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollKnownPeers">
      <summary>
            Returns the list of all known/favorite peers requested before.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkP2PBase.RequestKnownPeerData(System.String,System.Int32)">
      <summary>
            Sends a request to find out the list of known peers.
            </summary>
      <param name="host">Host address of the peers</param>
      <param name="remotePort">Listening port of the peers</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.RequestKnownPeerData(uLink.NetworkEndPoint)">
      <summary>
            Requests a list of known peers.
            </summary>
      <param name="target">IP and port of the peers.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.AddKnownPeerData(System.String,System.Int32)">
      <summary>
            Adds a peer to the likst of known/favorite peers.
            </summary>
      <param name="host">IP address/host name of the peer.</param>
      <param name="remotePort">The port that the peer is listening to.</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.AddKnownPeerData(uLink.NetworkEndPoint)">
      <summary>
            Adds a peer to the list of known/favorite peers.
            </summary>
      <param name="target">IP and port of the peer</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.AddKnownPeerData(uLink.PeerData)">
      <summary>
            Adds a peer to the list of known peers.
            </summary>
      <param name="data">The IP and port of the peer as a PeerData class</param>
    </member>
    <member name="M:uLink.NetworkP2PBase.RemoveKnownPeerData(System.String,System.Int32)">
      <summary>
            Removes a peer from the known/favorite peers list.
            </summary>
      <param name="host">
      </param>
      <param name="remotePort">
      </param>
    </member>
    <member name="M:uLink.NetworkP2PBase.RemoveKnownPeerData(uLink.NetworkEndPoint)">
      <summary>
            Removes a peer from the known/favorite peers list.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.RequestKnownPeers">
      <summary>
            Requests a list of all known/favorite peers.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.PollAndRequestKnownPeers(System.Single)">
      <summary>
            Polls the already received list of known peers and sends another request if <c>requestInterval</c> time passed from the previous request.
            </summary>
      <param name="requestInterval">The time that should pass before we send another request.</param>
      <returns>The list polled from the result of previous requests.</returns>
      <remarks>You can use this method easily in Update.
            The method will poll the list in every frame but only sends the request for new lists each
            <c>requestInterval</c> seconds.</remarks>
    </member>
    <member name="P:uLink.NetworkP2PBase.peerType">
      <summary>
            The type of this peer, This is mainly used when using the discovery feature of 
            the <see cref="T:uLink.NetworkP2P" /> class to find the compatible peers. 
            When you try to discover peers on the network, peers with the same type will be returned.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.peerName">
      <summary>
            Name of this peer/node. Can be used for any purpose. This is accessible in the list of discovered peers.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.isTypeSafeByDefault">
      <summary>
            Whether RPC:s sent over this connection should be type-safe or not by default.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.isListening">
      <summary>
            Whether this P2P node is listening for incoming connections or not.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.listenPort">
      <summary>
            Returns the port that we are listening to.
            If we are not listening to any ports, -1 will be returned.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.maxConnections">
      <summary>
            Maximum number of connections which this peer can have.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.connections">
      <summary>
            Currently connected remote peers.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.allConnections">
      <summary>
            All current remote peers whether connected, connecting, disconnecting or recently disconnected.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.config">
      <summary>
            The <see cref="T:uLink.NetworkP2PConfig" /> instance which can be used to configure this peer's low level settings.
            Be careful, unlike the static <see cref="P:uLink.Network.config" /> this is an instance property and can
            be accessed using a reference to a NetworkP2P object.
            </summary>
    </member>
    <member name="T:uLink.NetworkException">
      <summary>
            Thrown by uLink in error situations.
            </summary>
    </member>
    <member name="T:uLink.NetworkMessageInfo">
      <summary>
            A class containing some extra information about the sender of this network message.
            To get this info, you usually add an extra parameter at the end of the parameter list of the RPC.
            uLink automatically fills the parameter with an appropriate argument of this type.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.sender">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> who sent the message.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.localTimestamp">
      <summary>
            The time (seconds) when the message was sent, according to <see cref="P:uLink.NetworkTime.localTime" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.serverTimestamp">
      <summary>
            The time (seconds) when the message was sent, according to <see cref="P:uLink.NetworkTime.serverTime" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.rawServerTimestamp">
      <summary>
            The time (seconds) when the message was sent, according to <see cref="P:uLink.NetworkTime.rawServerTime" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.networkView">
      <summary>
            The <see cref="T:uLink.NetworkView" /> this message was sent from.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.flags">
      <summary>
            The flags used when sending this message.
            </summary>
    </member>
    <member name="M:uLink.NetworkMessageInfo.#ctor(uLink.NetworkMessageInfo,uLink.NetworkViewBase)">
      <summary>
            Creates a new instance of NetworkMessageInfo using the provided arguments.
            The class is initialized using the info parameter, except the networkview property which is initialized using the nv parameter.
            </summary>
    </member>
    <member name="M:uLink.NetworkMessageInfo.#ctor(uLink.NetworkPlayer,System.Double,System.Double,System.Double,uLink.NetworkFlags,uLink.NetworkViewBase)">
      <summary>
            Creates a new instance of NetworkMessageInfo using the supplied arguments.
            </summary>
    </member>
    <member name="M:uLink.NetworkMessageInfo.#ctor(uLink.NetworkPlayer,System.UInt64,uLink.NetworkFlags,uLink.NetworkViewBase)">
      <summary>
            Creates a new instance of NetworkMessageInfo using the supplied arguments.
            </summary>
      <param name="sender">
      </param>
      <param name="timestampInMillis">
      </param>
      <param name="flags">
      </param>
      <param name="networkView">
      </param>
    </member>
    <member name="P:uLink.NetworkMessageInfo.elapsedTimeSinceSent">
      <summary>
            Calculates the relative time (in seconds) since the message was sent.
            </summary>
    </member>
    <member name="T:uLink.BitStream">
      <summary>
            Represents serialized variables, packed into a stream.
            </summary>
      <remarks>
            Data can be serialized, transmitted, and then received by remote clients by
            using this class. Read about state synchronization and automatic serializations
            of data types in the uLink manual to get the big picture. The code for
            serializing and deserializing objects are usually placed in the callback method
            <see cref="!:uLink.Network.uLink_OnSerializeNetworkView" />.
            Check out the C# and javascript code examples for that callback method. 
            <para> 
            Also see the two other callbacks that are used to serialize and
            deserialize objects in some special situations: 
            <see cref="!:uLink.Network.uLink_OnSerializeNetworkViewOwner" />
            and <see cref="!:uLink.NetworkP2P.uLink_OnHandoverNetworkView" />.
            </para><para> 
            We recommend that C# code and javascript code (also called Unity script)
            uses the methods <see cref="M:uLink.BitStream.Read``1(System.Object[])" /> and 
            <see cref="M:uLink.BitStream.Write``1" />. Yes, it is possible to
            use generic types in javascript in Unity. It is not possible to use generic
            types in javascript outside Unity, this is a feature that has been added by
            Unity since v3.0 of the Editor. 
            </para><para>
            Arrays (only one-dimentional) are handled by uLink. Arrays are no problem for 
            methods like <see cref="M:uLink.BitStream.Read``1(System.Object[])" /> and 
            <see cref="M:uLink.BitStream.Write``1" /></para><para> If you are using an Unity version older than 3.0, or for some other
            reason can't use generics, you can use the <see cref="O:uLink.BitStream.ReadObject" /> and <see cref="O:uLink.BitStream.WriteObject" />
            methods.
            </para><para> There are several methods for reading and writing just one specific
            datatype. These can be used to gain some performance, but the code you have to
            write will usually be a bit longer and not as elegant. Two examples of these
            method pairs are 
            <see cref="M:uLink.BitStream.ReadInt16" />/<see cref="M:uLink.BitStream.WriteInt16(System.Int16)" /> and 
            <see cref="M:uLink.BitStream.ReadString" />/<see cref="M:uLink.BitStream.WriteString(System.String)" />. 
            </para><para> 
            Because uLink is backward compatible with the Unity built-in network the
            method <see cref="O:uLink.BitStream.Serialize" />
            is included in this class and can still be used. It supports a limited set of
            basic datatypes (the same as Unity built-in network). The new method <see cref="M:uLink.BitStream.Serialize``1" /> can be
            used to handle more data types (all data types supported by uLink), but we
            recommend that you use the generic read/write methods whenever possible. </para></remarks>
    </member>
    <member name="M:uLink.BitStream.Read``1(System.Object[])">
      <summary>
            Deserializes different types of variables. Recommended for C# code and javascript code.
            </summary>
      <param name="codecOptions">Optional parameters forwared to the deserializer</param>
      <remarks>
            Use this kind of function when reading from the stream.
            <para>
            The supported data types are documented in the uLink manual in the serialization section.
            </para></remarks>
    </member>
    <member name="M:uLink.BitStream.Write``1(``0,System.Object[])">
      <summary>
            Serializes different types of variables. Recommended for C# code and javascript code.
            </summary>
      <param name="value">The actual data</param>
      <param name="codecOptions">Optional parameters forwared to the serializer</param>
      <remarks>           
            Use this kind of function when writing the stream and the data type is known at design time.
            <para>All supported data types, that uLink serializes automatically, are documented in the uLink 
            manual in the serialization section.
            </para></remarks>
    </member>
    <member name="M:uLink.BitStream.ReadObject(System.RuntimeTypeHandle,System.Object[])">
      <summary>
            Deserializes different types of variables. Recommended for Javascript code in Unity 2.6.
            </summary>
      <param name="typeHandle">The data type for this value that will be serialized</param>
      <param name="codecOptions">Optional parameters forwared to the deserializer</param>
      <remarks>
            Use this function when reading from the stream and the code is javascript in Unity 2.6.
            Use <see cref="M:uLink.BitStream.Read``1(System.Object[])" /> if you can use generics, the code will 
            be easier to debug and maintain.
            <para>
            The supported data types are documented in the uLink manual in the serialization section.
            </para></remarks>
    </member>
    <member name="M:uLink.BitStream.WriteObject(System.RuntimeTypeHandle,System.Object,System.Object[])">
      <summary>
            Serializes different types of variables. Recommended for Javascript code in Unity 2.6.
            </summary>
      <param name="typeHandle">The data type for the value that will be serialized</param>
      <param name="value">The actual data</param>
      <param name="codecOptions">Optional parameters forwared to the serializer</param>
      <remarks>
            Use this function when writing to the stream and the code is javascript in Unity 2.6..
            Use <see cref="M:uLink.BitStream.Write``1" /> if you can use generics, the code will 
            be easier to debug and maintain.
            <para>All supported data types are documented in the uLink manual in the serialization section.
            </para></remarks>
    </member>
    <member name="M:uLink.BitStream.Serialize``1(``0@,System.Object[])">
      <summary>
            Serializes if <see cref="P:uLink.BitStream.isWriting" />, otherwise deserializes.
            </summary>
      <param name="value">Be aware this function can only handle a
            reference to a value. It can not be used for getting or setting properties
            therefore.</param>
      <param name="codecOptions">Optional parameters forwared to the serializer/deserializer</param>
      <remarks>
        <para>The supported data types are documented in the uLink manual in the serialization section.
            </para>
      </remarks>
    </member>
    <member name="M:uLink.BitStream.Serialize(System.Boolean@,System.Object[])">
      <summary>
            Serializes if <see cref="P:uLink.BitStream.isWriting" />, otherwise deserializes. 
            </summary>
      <param name="value">Be aware this function can only handle a
            reference to a value. Therefore it can not be used for getting or setting 
            properties.</param>
      <param name="codecOptions">Optional parameters forwarded to the serializer/deserializer</param>
      <remarks>
            This method for serializiation is included in uLink only because uLink is backward 
            compatible with Unity bilt-in network. The recommended uLink alternative is 
            <see cref="M:uLink.BitStream.Read``1(System.Object[])" /> and <see cref="M:uLink.BitStream.Write``1" />. 
            </remarks>
    </member>
    <member name="M:uLink.BitStream.GetRemainingBytes">
      <summary>
            Returns the remaining bytes in a byte array. 
            </summary>
    </member>
    <member name="M:uLink.BitStream.GetRemainingBitStream">
      <summary>
            Copies the remaining bytes in a newly instantiated BitStream. 
            </summary>
      <remarks>
            Keeps the value if isWriting and isTypeSafe of the original Bitstream.
            </remarks>
    </member>
    <member name="M:uLink.BitStream.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that shows a list of all bytes in the BitStream.
            </summary>
    </member>
    <member name="P:uLink.BitStream.isWriting">
      <summary>
            Gets a value indicating whether the BitStream is currently being written to.
            </summary>
    </member>
    <member name="P:uLink.BitStream.isReading">
      <summary>
            Gets a value indicating whether the BitStream is currently being read.
            </summary>
    </member>
    <member name="P:uLink.BitStream.isEOF">
      <summary>
            Gets a value indicating whether there are any more bits to be read in the BitStream.
            </summary>
    </member>
    <member name="T:uLink.BitStreamCodec">
      <summary>
            Used to build custom handling for serializing and deserializing of your game objects.
            </summary>
      <remarks>
            It is possible to build custom serialization and deserialization for any data type. Replace the uLink default 
            serializer and deserializer for any data type, or make a new data type and register it in uLink.
            </remarks>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeNullableAndArray``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Add codec for specified type, including support for null values and arrays
            </summary>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeNullableAndArray``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Add codec for specified type, including support for null values and arrays
            </summary>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeNullable``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Add codec for specified type, including support for null values
            </summary>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeNullable``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Add codec for specified type, including support for null values
            </summary>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeArray``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Add codec for specified type, including support for arrays.
            </summary>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeArray``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Add codec for specified type, including support for arrays.
            </summary>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.Add``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Adds a serialization codec for the specified user-defined type.
            </summary>
      <parameter name="T">The type that should be serialized using this codec.</parameter>
      <parameter name="deserializer">The deserializer function. Based on the uLink.BitStreamCodec.Deserializer delegate.</parameter>
      <parameter name="serializer">The serializer function. Based on the uLink.BitStreamCodec.Serializer delegate.</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.Add``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Adds a serialization codec for the specified user-defined type.
            </summary>
      <parameter name="T">The type that should be serialized using this codec.</parameter>
      <parameter name="deserializer">The deserializer function. Based on the uLink.BitStreamCodec.Deserializer delegate.</parameter>
      <parameter name="serializer">The serializer function. Based on the uLink.BitStreamCodec.Serializer delegate.</parameter>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.Add(System.RuntimeTypeHandle,uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Add codec for specified type
            </summary>
    </member>
    <member name="M:uLink.BitStreamCodec.Add(System.RuntimeTypeHandle,uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Add codec for specified type
            </summary>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.Remove(System.RuntimeTypeHandle)">
      <summary>
            Removes codec for specified type
            </summary>
    </member>
    <member name="T:uLink.BitStreamCodec.Deserializer">
      <summary>
            Signature for deserializing (reader) methods
            </summary>
    </member>
    <member name="T:uLink.BitStreamCodec.Serializer">
      <summary>
            Signature for serializing (writer) methods
            </summary>
    </member>
    <member name="T:uLinkExtensions">
      <summary>
            Special class to make some uLink features available in all GameObjects in Unity. Do not use this class directly.
            </summary>
      <remarks>
            This class uses new .Net features to add static methods to other classes. Therefore this feature is only available
            in Unity 3.0 and newer versions of Unity. The static methods this class adds are uLinkNetworkView() and 
            uLinkNetworkP2P() that can be accessed from 
            ALL GameObjects and Components in your code. The property will be <c>null</c> if no component of that type is
            attached to the GameObject. Do not use this class directly, see example below instead.
            </remarks>
      <example>
            This code works in C# only, in a script component.
            <code>
            //Using the game object
            Debug.Log("View ID = " + gameObject.uLinkNetworkView().viewID);
            //Using the component via 'this'
            Debug.Log("View ID = " + this.uLinkNetworkView().viewID);
            </code></example>
    </member>
    <member name="M:uLinkExtensions.uLinkNetworkView(UnityEngine.GameObject)">
      <summary>
            Returns the <see cref="T:uLink.NetworkView" /> component attached to the Game Object.
            </summary>
      <param name="gameObject">
      </param>
      <returns>The NetworkView component if attached, null otherwise.</returns>
    </member>
    <member name="M:uLinkExtensions.uLinkNetworkView(UnityEngine.Component)">
      <summary>
            Returns the <see cref="T:uLink.NetworkView" /> component attached to the Game Object which this component is attached to.
            </summary>
      <param name="component">
      </param>
      <returns>The NetworkView component attached to the GameObject which we are attached to (if exists), otherwise null</returns>
    </member>
    <member name="M:uLinkExtensions.uLinkNetworkP2P(UnityEngine.GameObject)">
      <summary>
            Returns the <see cref="T:uLink.NetworkP2P" /> component attached to the Game Object.
            </summary>
      <param name="gameObject">
      </param>
      <returns>The NetworkP2P component if attached, null otherwise.</returns>
    </member>
    <member name="M:uLinkExtensions.uLinkNetworkP2P(UnityEngine.Component)">
      <summary>
            Returns the <see cref="T:uLink.NetworkP2P" /> component attached to the Game Object which this component is attached to.
            </summary>
      <param name="component">
      </param>
      <returns>The NetworkP2P component attached to the GameObject which we are attached to (if exists), otherwise null</returns>
    </member>
    <member name="T:uLink.InternalHelper">
      <summary>
            Do not use this class. For internal use only.
            </summary>
    </member>
    <member name="T:uLink.RPCTypeSafe">
      <summary>
            This enum contains the different values which you can set for type safety of RPCs in <see cref="P:uLink.Network.rpcTypeSafe" /></summary>
    </member>
    <member name="F:uLink.RPCTypeSafe.Off">
      <summary>
            Type safety is turned off and you'll not receive any errors/warnings for sending/receiving variables of different types
            </summary>
    </member>
    <member name="F:uLink.RPCTypeSafe.OnlyInEditor">
      <summary>
            Type safety is on in the editor and turned off in built players.
            </summary>
    </member>
    <member name="F:uLink.RPCTypeSafe.Always">
      <summary>
            Type safety is always on (not recommended for releases).
            </summary>
    </member>
    <member name="T:uLink.NetworkObserved">
      <summary>
            Helper class for caching and binding. 
            </summary>
      <remarks>This class is used internally in uLink, but it is made public to be used in some custom cases.</remarks>
    </member>
    <member name="F:uLink.NetworkObserved.defaultBinder">
      <summary>
            Used when no custom binder has been set.
            </summary>
    </member>
    <member name="F:uLink.NetworkObserved.component">
      <summary>
            The component that this observer is observing for serializaton.
            </summary>
    </member>
    <member name="F:uLink.NetworkObserved.serializeProxy">
      <summary>
            Serializer used when serializing proxies.
            this is used both for owners and proxies when <see cref="!:uLink.Network.useDifferentStateSyncForOwner" /> is not set.
            </summary>
    </member>
    <member name="F:uLink.NetworkObserved.serializeOwner">
      <summary>
            Serialization method used for serializing the state for owner when the <see cref="P:uLink.Network.useDifferentStateForOwner" /> is set.
            </summary>
    </member>
    <member name="F:uLink.NetworkObserved.serializeHandover">
      <summary>
            Serialization method used for serialization when handing an object over.
            </summary>
    </member>
    <member name="F:uLink.NetworkObserved.serializeCellProxy">
      <summary>
            Serializer method used in Pikko server for serializing between auth cell and proxies for an object.
            </summary>
    </member>
    <member name="M:uLink.NetworkObserved.#ctor(UnityEngine.Component)">
      <summary>
            Use this constructor. Send your component as argument.
            </summary>
      <param name="component">The component.</param>
    </member>
    <member name="M:uLink.NetworkObserved.UpdateBinding(UnityEngine.Component)">
      <summary>
            Call this if you added a new custom binder for the component which you want to be used from now on.
            </summary>
      <param name="observedComponent">
      </param>
    </member>
    <member name="M:uLink.NetworkObserved.AddBinder``1(uLink.NetworkObserved.Binder)">
      <summary>
            Adds a binder for the type <c>T</c>.
            </summary>
      <typeparam name="T">The type that we want to add a binder for.</typeparam>
      <param name="binder">The binder method for serializing and deserializing the type.</param>
    </member>
    <member name="M:uLink.NetworkObserved.AddBinder(System.RuntimeTypeHandle,uLink.NetworkObserved.Binder)">
      <summary>
            Adds a binder or the type specified by its runtime handle.
            </summary>
      <param name="typeHandle">
      </param>
      <param name="binder">
      </param>
    </member>
    <member name="M:uLink.NetworkObserved.AddBinder(System.RuntimeTypeHandle,uLink.NetworkObserved.Binder,System.Boolean)">
      <summary>
            Adds a binder for the type specified.
            </summary>
      <param name="typeHandle">
      </param>
      <param name="binder">
      </param>
      <param name="replaceIfExists">Indicates if it should replace the custom binder if one already exists or not.</param>
    </member>
    <member name="M:uLink.NetworkObserved.RemoveBinder(System.RuntimeTypeHandle)">
      <summary>
            Removes the custom binder for a type.
            </summary>
      <param name="typeHandle">
      </param>
    </member>
    <member name="M:uLink.NetworkObserved.CreateSerializer(System.Object,System.Type,System.String)">
      <summary>
            This is a help function for creating a custom binder.
            </summary>
      <param name="obj">The obj.</param>
      <param name="type">The type.</param>
      <param name="name">The name.</param>
      <returns>
      </returns>
    </member>
    <member name="T:uLink.NetworkObserved.Binder">
      <summary>
            Has the responsibility to assign each serializer member of NetworkObserved to an appropriate delegate.
            </summary>
    </member>
    <member name="T:uLink.NetworkObserved.Serializer">
      <summary>
            Callback that gets called to serialize a specific state. 
            </summary>
      <remarks>For example uLink_OnSerializeNetworkView, uLink_OnSerializeNetworkViewOwner, uLink_OnHandoverNetworkView.</remarks>
    </member>
    <member name="T:uLink.NetworkP2P">
      <summary>
            Enables peer to peer communication between nodes. Contains implementation for the uLink.NetworkP2P script.
            </summary>
      <remarks>
            This class provides methods for creating and maintaining P2P connections. It enables peers to send
            RPC:s and transfer game objects between them. For more info, see the "P2P" chapter in the uLink manual.
            </remarks>
    </member>
    <member name="F:uLink.NetworkP2P.observed">
      <summary>
            Included here because <see cref="F:uLink.NetworkP2P.rpcReceiver" /> can be 
            set to <see cref="T:uLink.RPCReceiver">RPCReceiver.OnlyObservedComponent</see>. Otherwise this field is not used.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2P.rpcReceiver">
      <summary>
            Gets or sets the receiver(s) for incoming RPCs to this game object.
            </summary>
      <value>Default is <see cref="T:uLink.RPCReceiver">RPCReceiver.ThisGameObject</see></value>
      <remarks>All scripts attached to the same prefab/GameObject as this
            NetworkP2P component will be able to get this RPC and can therefore contain
            code for RPC receiving. If you want to put RPC receiving code in
            scripts attached to a root gameobject or scripts attached to a child
            game object, this can be done, but this property needs to be changed
            then.</remarks>
    </member>
    <member name="M:uLink.NetworkP2P.ClearCachedRPCs">
      <summary>
            Advanced usage only: To increase performance uLink makes a cache of RPC receivers. The cache is populated 
            the first time an RPC is received. All RPC after the first call will be delivered to the same
            RPC receiver (a script component). The cache can be cleared by this method.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2P.InverseTransform(UnityEngine.Vector3@,UnityEngine.Quaternion@)">
      <summary>
            Inverses the transformation provided from world space to the local space of the component which this NetworkP2P
            component is attached to.
            </summary>
      <param name="pos">The position of the transform that you want to apply the transformation on.</param>
      <param name="rot">The rotation of the transform that you want to apply the transformation on.</param>
    </member>
    <member name="M:uLink.NetworkP2P.Transform(UnityEngine.Vector3@,UnityEngine.Quaternion@)">
      <summary>
            Transforms the provided transform position and rotation from local space of the transform that this NetworkP2P is
            attached to, to the world space.
            </summary>
      <param name="pos">The position that you want to transform.</param>
      <param name="rot">The rotation that you want to transform.</param>
    </member>
    <member name="M:uLink.NetworkP2P.Connect(System.String,System.Int32)">
      <summary>
            Creates a P2P connection to another node using its ip address and port number. 
            </summary>
      <param name="host">The ip address of other node</param>
      <param name="remotePort">The port number of other node</param>
      <remarks>
            If the other node requires password to allow connections use <see cref="M:uLink.NetworkP2P.Connect(System.String,System.Int32,System.String)" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Connect(System.String,System.Int32,System.String)">
      <summary>
            Creates a P2P connection to another node using its ip address, port number and also
            password if other node requires password to allow connection.
            </summary>
      <param name="host">The ip address of other node</param>
      <param name="remotePort">The port number of other node</param>
      <param name="incomingPassword">The password which the other node requires to allow connections</param>
    </member>
    <member name="M:uLink.NetworkP2P.Connect(uLink.NetworkPeer)">
      <summary>
            Creates a P2P connection to another node using its <see cref="T:uLink.NetworkPeer" />.
            </summary>
      <param name="target">The <see cref="T:uLink.NetworkPeer" /> of other node</param>
      <remarks>
            If the other node requires password to allow connections use <see cref="M:uLink.NetworkP2P.Connect(uLink.NetworkPeer,System.String)" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Connect(uLink.NetworkPeer,System.String)">
      <summary>
            Creates a P2P connection to another node using its <see cref="T:uLink.NetworkPeer" /> and also a password
            if the other node requires password to allow connection.
            </summary>
      <param name="target">The <see cref="T:uLink.NetworkPeer" /> of other node</param>
      <param name="incomingPassword">The password which the other node requires to allow connections</param>
    </member>
    <member name="M:uLink.NetworkP2P.Replicate(UnityEngine.Object,uLink.NetworkPeer)">
      <summary>
            Moves a network aware object to a remote node.
            </summary>
      <param name="obj">The network aware object which you want to move to another remote node</param>
      <param name="target">The <see cref="T:uLink.NetworkPeer" /> of the remote node which <c>obj</c> should be moved to</param>
      <remarks>
            The object will be instantiated with a new viewID on the receiving end.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Replicate(UnityEngine.Object,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
            Moves a network aware object to a remote node.
            Adjusts the objects position and rotation on the receiving node according to the given relative parameters.
            </summary>
      <param name="obj">The network aware object which you want to move to another remote node</param>
      <param name="target">The <see cref="T:uLink.NetworkPeer" /> of the remote port which <c>obj</c> should be moved to</param>
      <param name="relativePos">The position which the <c>obj</c>'s position should be set to in other node</param>
      <param name="relativeRot">The rotation which the <c>obj</c>'s rotation should be set to in other node</param>
      <remarks>
            The object will be instantiated with a new viewID on the receiving end.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Handover(UnityEngine.Object,uLink.NetworkPeer,uLink.NetworkP2PHandoverFlags,System.Object[])">
      <summary>
            Moves a network aware object to a remote node.
            </summary>
      <param name="obj">The network aware object which you want to move to another remote node</param>
      <param name="target">The <see cref="T:uLink.NetworkPeer" /> which <c>obj</c> should be moved to</param>
      <param name="flags">The <see cref="T:uLink.NetworkP2PHandoverFlags" /> which sets the setting of HandOver</param>
      <param name="handoverData">The data which can be used in <see cref="!:NetworkP2P.uLink_OnHandoverNetworkView" /> in other node</param>
      <remarks>
            Can only be invoked server-side.
            owner redirection and instantiations can be customized
            using the <c>flags</c> argument.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Handover(UnityEngine.Object,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkP2PHandoverFlags,System.Object[])">
      <summary>
            Moves a network aware object to a remote node.
            Adjusts the objects position and rotation on the receiving node according to the given relative parameters.
            </summary>
      <param name="obj">The network aware object which you want to move to another remote node</param>
      <param name="target">The <see cref="T:uLink.NetworkPeer" /> which <c>obj</c> should be moved to</param>
      <param name="relativePos">The position which the <c>obj</c>'s position should be set to in other node</param>
      <param name="relativeRot">The rotation which the <c>obj</c>'s rotation should be set to in other node</param>
      <param name="flags">The <see cref="T:uLink.NetworkP2PHandoverFlags" /> which sets the setting of HandOver</param>
      <param name="handoverData">The data which can be used in <see cref="!:NetworkP2P.uLink_OnHandoverNetworkView" /> in other node</param>
      <remarks>
            Can only be invoked server-side.
            owner redirection and instantiations can be customized
            using the <c>flags</c> argument.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Handover(UnityEngine.Object,uLink.NetworkPeer)">
      <summary>
            Moves a network object and it's owner to another server. 
            </summary>
      <param name="obj">The network aware object which you want to move to another remote node</param>
      <param name="target">The <see cref="T:uLink.NetworkPeer" /> which <c>obj</c> should be moved to</param>
      <remarks>
            Can only be invoked server-side.
            The player's client will automatically be reconnected to the new server and
            the object will be instantiated with a new viewID on the receiving end.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Handover(UnityEngine.Object,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
            Moves a network object and it's owner to another server. 
            Adjusts the players position and rotation on the receiving peer according to the given relative parameters.
            </summary>
      <remarks>
            Can only be invoked server-side.
            The player's client will automatically be reconnected to the new server.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Get(UnityEngine.GameObject)">
      <summary>
            Returns <see cref="T:uLink.NetworkP2P" /> component of <c>gameObject</c> and <c>null</c> 
            if there's no <see cref="T:uLink.NetworkP2P" /> component attached to <c>gameObject</c>.
            </summary>
      <param name="gameObject">The GameObject which you want its <see cref="T:uLink.NetworkP2P" /></param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkP2P.Get(UnityEngine.Component)">
      <summary>
            Returns <see cref="T:uLink.NetworkP2P" /> of the first GameObject it find which has <c>component</c> and also a <see cref="T:uLink.NetworkP2P" />,
            if there's no GameObject with <c>component</c> or none of the GameObjects with <c>component</c> have <see cref="T:uLink.NetworkP2P" />, returns <c>null</c>.
            </summary>
      <param name="component">The component which you want its GameObject's <see cref="T:uLink.NetworkP2P" /></param>
      <returns>
      </returns>
    </member>
    <member name="P:uLink.NetworkP2P.rpcReceiverGameObjects">
      <summary>
            The GameObject's which receive RPCs send to this node using the <see cref="T:uLink.NetworkP2P" /> API. 
            This is only important if <see cref="F:uLink.NetworkP2P.rpcReceiver" /> is set to <see cref="F:uLink.RPCReceiver.GameObjects" /></summary>
    </member>
    <member name="P:uLink.NetworkP2P.listenPort">
      <summary>
            The listen port for this P2P node.
            </summary>
      <remarks>You can set it to 0 to be set by the OS to an empty port.</remarks>
    </member>
    <member name="P:uLink.NetworkP2P.maxConnections">
      <summary>
            Maximum allowed incoming connections for this node.
            </summary>
    </member>
    <member name="T:uLink.MasterServer">
      <summary>
            Use methods in this class to communicate with a stand alone uLink Master Server. 
            </summary>
      <remarks> The Master 
            Server can be used as a listing server (lobby) for game servers. 
            You can advertise game
            hosts or fetch host lists for your specific game type using this class. The
            methods here are used to communicate with the Master Server itself
            which is hosted separately without the need of the Unity editor. 
            For an overview of the Master Server as well as
            usage introduction see the section Master Server in the manual.
            <para>
            Some of the methods are used for local discovery of servers in LAN
            and things regarding that and don't require the standalone master server to exist.
            </para></remarks>
    </member>
    <member name="M:uLink.MasterServer.GetPrefs">
      <summary>
            Load preferences for master server from the previously stored PlayerPrefs.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.SetPrefs">
      <summary>
            Save preferences for master server in PlayerPrefs.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.ClearHostList">
      <summary>
            Clear the host list which was received from the stand alone master server. See <see cref="M:uLink.MasterServer.PollHostList" />. 
            </summary>
      <remarks>See the code example in <see cref="M:uLink.MasterServer.RequestHostList(System.String)" /></remarks>
    </member>
    <member name="M:uLink.MasterServer.PollHostList">
      <summary>
            Returns the latest host list received from the MasterServer. See <see cref="M:uLink.MasterServer.RequestHostList(System.String)" />.
            </summary>
      <remarks>You can clear the current host list with <see cref="M:uLink.MasterServer.ClearHostList" />. 
            Then way you can be sure that the next list returned is up to date.
            See the code example in <see cref="M:uLink.MasterServer.RequestHostList(System.String)" /></remarks>
    </member>
    <member name="M:uLink.MasterServer.RegisterHost(System.String,System.String)">
      <summary>
            Register this game server on the master server. 
            </summary>
      <param name="gameType">Game type for this game server</param>
      <param name="gameName">Game name for this game server</param>
      <remarks>
            This method will also set the values for, <see cref="P:uLink.MasterServer.gameType" /> 
            and <see cref="P:uLink.MasterServer.gameName" />.
            Remember to set the master server ip and port before calling this function.
            see the code example in <see cref="!:RegisterHost(string gameType, string gameName, string comment, string gameMode, string gameLevel)" /></remarks>
    </member>
    <member name="M:uLink.MasterServer.RegisterHost(System.String,System.String,System.String)">
      <summary>
            Register this game server on the master server. 
            </summary>
      <param name="gameType">Game type for this game server</param>
      <param name="gameName">Game name for this game server</param>
      <param name="comment">Comment for this game server</param>
      <remarks>
            This method will also set the values for, <see cref="P:uLink.MasterServer.gameType" />, 
            <see cref="P:uLink.MasterServer.gameName" /> and <see cref="P:uLink.MasterServer.comment" />.
            Remember to set the master server ip and port before calling this function.
            see the code example in <see cref="!:RegisterHost(string gameType, string gameName, string comment, string gameMode, string gameLevel)" /></remarks>
    </member>
    <member name="M:uLink.MasterServer.RegisterHost(System.String,System.String,System.String,System.String,System.String)">
      <summary>
            Register this game server on the master server. 
            </summary>
      <param name="gameType">Game type for this game server</param>
      <param name="gameName">Game name for this game server</param>
      <param name="comment">Comment for this game server</param>
      <param name="gameMode">Game mode of this game server</param>
      <param name="gameLevel">Game level of this game server</param>
      <remarks>
            This method will also set the values for, <see cref="P:uLink.MasterServer.gameType" />, 
            <see cref="P:uLink.MasterServer.gameName" />, <see cref="P:uLink.MasterServer.comment" />, <see cref="P:uLink.MasterServer.gameMode" /> and <see cref="P:uLink.MasterServer.gameLevel" />.
            Remember to set the master server ip and port before calling this function.
            <para>
            Parameters other than game type are not used exclusively by master server, you can let the user set
            them to desired values and show them in the UI for other users or do whatever you want with them.
            Be careful to don't use the values that you get directly in your game with reflection or in any other way
            that potentially can make security risks.
            </para></remarks>
      <example>
        <code>
            void uLink_OnServerInitialized()
            {
            	uLink.MasterServer.ipAddress = "127.0.0.1";
            	uLink.MasterServer.port = 23466;
            	uLink.MasterServer.RegisterHost("Fighting", "uLinkGame", "Awesome Game", "Versus Mode", "Normal");
            }
            </code>
      </example>
    </member>
    <member name="M:uLink.MasterServer.RegisterHost">
      <summary>
            Register this game server on the master server. 
            </summary>
      <remarks>
            You have to set <see cref="P:uLink.MasterServer.gameType" /> and <see cref="P:uLink.MasterServer.gameName" /> before calling this method.
            Also, remember to set the master server ip and port before calling this function.
            You can also use <see cref="!:RegisterHost(string gameType, string gameName)" />, so you can set
            values for <see cref="P:uLink.MasterServer.gameType" /> and <see cref="P:uLink.MasterServer.gameName" /> while registering server.
            </remarks>
      <example>
        <code>
            void uLink_OnServerInitialized()
            {
            	uLink.MasterServer.ipAddress = "127.0.0.1";
            	uLink.MasterServer.port = 23466;
            	uLink.MasterServer.gameType = "unique type";
            	uLink.MasterServer.RegisterHost();
            }
            </code>
      </example>
    </member>
    <member name="M:uLink.MasterServer.UnregisterHost">
      <summary>
            Unregister this game server on the master server. 
            </summary>
      <remarks>
            Does nothing if the server is not registered or has already unregistered.
            You usually call this when you want to shutdown/update a server.
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.MasterServer.RequestHostList(System.String)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.MasterServer.RequestHostList(uLink.HostDataFilter)" -->
    <member name="M:uLink.MasterServer.PollAndRequestHostList(System.String,System.Single)">
      <summary>
            Returns the latest host list received from the MasterServer and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <param name="gameType">Game type for game servers</param>
      <param name="requestInterval">The minimum time between host list request</param>
      <remarks>
            This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.
            If you request host list sooner than specified interval, no request will be sent.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndRequestHostList(uLink.HostDataFilter,System.Single)">
      <summary>
            Returns the latest host list received from the MasterServer and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <param name="filter">The <see cref="T:uLink.HostDataFilter" /> of game servers</param>
      <param name="requestInterval">The minimum time between host list request</param>
      <remarks>
            This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.
            If you request host list sooner than specified interval, no request will be sent.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.ClearDiscoveredHosts">
      <summary>
            Clear the host list of discovered game servers in the LAN. See <see cref="M:uLink.MasterServer.PollDiscoveredHosts" />. 
            </summary>
    </member>
    <member name="M:uLink.MasterServer.PollDiscoveredHosts">
      <summary>
            Returns the latest host list of all discovered host in the LAN. See <see cref="O:DiscoverLocalHosts" />.
            </summary>
      <remarks>You can clear the current host list with <see cref="M:uLink.MasterServer.ClearDiscoveredHosts" />. 
            That way you can be sure that the next list returned 
            (after calling <see cref="O:DiscoverLocalHosts" />) is up to date.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.DiscoverLocalHosts(System.String,System.Int32)">
      <summary>
            Request a host list of all available game servers in the LAN for a specific game type.
            </summary>
      <param name="gameType">The game type of the game server(s)</param>
      <param name="remotePort">The port number of the game server(s)</param>
      <remarks>
            This request is asynchronous and it is sent to the IPAdress <see cref="F:System.Net.IPAddress.Broadcast" />.
            uLink collects all the answers from running game servers in the LAN and stores the result internally.
            This method does not return the result. Instead, the result 
            list is populated when results come in one by one, and the result is available through 
            uLink.MasterServer.<see cref="M:uLink.MasterServer.PollDiscoveredHosts" />.  
            </remarks>
      <seealso cref="M:uLink.MasterServer.PollDiscoveredHosts" />
      <seealso cref="M:uLink.MasterServer.PollAndDiscoverLocalHosts(System.String,System.Int32,System.Single)" />
    </member>
    <member name="M:uLink.MasterServer.DiscoverLocalHosts(uLink.HostDataFilter,System.Int32)">
      <summary>
            Request a host list of all available game servers in the LAN using a filter.
            </summary>
      <param name="filter">The filter for finding only specific game servers.</param>
      <param name="remotePort">The port number of the game server(s)</param>
      <remarks>
            This request is asynchronous and it is sent to the IPAdress <see cref="F:System.Net.IPAddress.Broadcast" />.
            uLink collects all the answers from running game servers in the LAN and stores the result internally.
            This method does not return the result. Instead, the result 
            list is populated when results come in one by one, and the result is available through 
            uLink.MasterServer.<see cref="M:uLink.MasterServer.PollDiscoveredHosts" />.  
            </remarks>
      <seealso cref="M:uLink.MasterServer.PollDiscoveredHosts" />
      <seealso cref="M:uLink.MasterServer.PollAndDiscoverLocalHosts(System.String,System.Int32,System.Single)" />
    </member>
    <member name="M:uLink.MasterServer.DiscoverLocalHosts(System.String,System.Int32,System.Int32)">
      <summary>
            Request a host list of all available game servers in the LAN for a specific game type.
            </summary>
      <param name="gameType">The <see cref="P:uLink.MasterServer.gameType" /> of the game server(s)</param>
      <param name="remoteStartPort">The lowest port number of the game servers</param>
      <param name="remoteEndPort">The highest port number of the game servers</param>
      <remarks>
            This request is asynchronous and it is sent to the IPAdress <see cref="F:System.Net.IPAddress.Broadcast" />.
            uLink collects all the answers from running game servers in the LAN and stores the result internally.
            The request will be sent to all UDP ports beginning with remoteStartPort and ending with remoteEndPort.
            The usage of several ports is necessary when there are several game servers hosted on a single machine, 
            since the game servers on one machine need one unique port each.
            This method does not return the result. Instead, the result 
            list is populated when results come in one by one, and the result is available through 
            uLink.MasterServer.<see cref="M:uLink.MasterServer.PollDiscoveredHosts" />.  
            </remarks>
      <seealso cref="M:uLink.MasterServer.PollDiscoveredHosts" />
      <seealso cref="M:uLink.MasterServer.PollAndDiscoverLocalHosts(System.String,System.Int32,System.Single)" />
    </member>
    <member name="M:uLink.MasterServer.DiscoverLocalHosts(uLink.HostDataFilter,System.Int32,System.Int32)">
      <summary>
            Request a host list of all available game servers in the LAN using a filter.
            </summary>
      <param name="filter">The <see cref="T:uLink.HostDataFilter" /> for finding only specific game servers</param>
      <param name="remoteStartPort">The lowest port number of the game servers</param>
      <param name="remoteEndPort">The highest port number of the game servers</param>
      <remarks>
            This request is asynchronous and it is sent to the IPAdress <see cref="F:System.Net.IPAddress.Broadcast" />.
            uLink collects all the answers from running game servers in the LAN and stores the result internally.
            The request will be sent to all UDP ports beginning with remoteStartPort and ending with remoteEndPort.
            The usage of several ports is necessary when there are several game servers hosted on a single machine, 
            since the game servers on one machine need one unique port each.
            This method does not return the result. Instead, the result 
            list is populated when results come in one by one, and the result is available through 
            uLink.MasterServer.<see cref="M:uLink.MasterServer.PollDiscoveredHosts" />.  
            </remarks>
      <seealso cref="M:uLink.MasterServer.PollDiscoveredHosts" />
      <seealso cref="M:uLink.MasterServer.PollAndDiscoverLocalHosts(System.String,System.Int32,System.Single)" />
    </member>
    <member name="M:uLink.MasterServer.PollAndDiscoverLocalHosts(System.String,System.Int32,System.Single)">
      <summary>
            Returns the latest host list discovered on the LAN and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <param name="gameType">The <see cref="!:gameType&gt;" /> of the game servers</param>
      <param name="remotePort">The port number of the game servers</param>
      <param name="discoverInterval">The minimum time between message broadcastings</param>
      <remarks>
            This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.
            If you try to discover hosts sooner than specified interval, no message will be broadcasted.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndDiscoverLocalHosts(uLink.HostDataFilter,System.Int32,System.Single)">
      <summary>
            Returns the latest host list discovered on the LAN and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <param name="filter">The <see cref="T:uLink.HostDataFilter" /> for finding only specific game servers</param>
      <param name="remotePort">The port number of game servers</param>
      <param name="discoverInterval">The minimum time between message broadcastings</param>
      <remarks>
            This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.
            If you try to discover hosts sooner than specified interval, no message will be broadcasted.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndDiscoverLocalHosts(System.String,System.Int32,System.Int32,System.Single)">
      <summary>
            Returns the latest host list discovered on the LAN and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <param name="gameType">The <see cref="P:uLink.MasterServer.gameType" /> of the game servers</param>
      <param name="remoteStartPort">The lowest port number of the game servers</param>
      <param name="remoteEndPort">The highest port number of the game servers</param>
      <param name="discoverInterval">The minimum time between message broadcastings</param>
      <remarks>
            This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.
            If you try to discover hosts sooner than specified interval, no message will be broadcasted.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndDiscoverLocalHosts(uLink.HostDataFilter,System.Int32,System.Int32,System.Single)">
      <summary>
            Returns the latest host list discovered on the LAN and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <param name="filter">The <see cref="T:uLink.HostDataFilter" /> for finding only specific game servers</param>
      <param name="remoteStartPort">The lowest port number of the game servers</param>
      <param name="remoteEndPort">The highest port number of the game servers</param>
      <param name="discoverInterval">The minimum time between message broadcastings</param>
      <remarks>
            This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.
            If you try to discover hosts sooner than specified interval, no message will be broadcasted.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)">
      <summary>
            Gets the HostData info for one favorite servers (Known Hosts) stored in the client.
            </summary>
      <param name="host">The ip address of favorite server</param>
      <param name="remotePort">The port number of favorite server</param>
      <returns>
        <see cref="T:uLink.HostData" /> of polled favorite hosts.
            </returns>
    </member>
    <member name="M:uLink.MasterServer.PollKnownHostData(uLink.NetworkEndPoint)">
      <summary>
            Gets the HostData info for one favorite servers (Known Hosts) stored in the client.
            </summary>
      <param name="endpoint">The <see cref="!:System.Net.NetworkEndPoint" /> of the favorite server</param>
      <returns>
        <see cref="T:uLink.HostData" /> of polled favorite hosts.
            </returns>
    </member>
    <member name="M:uLink.MasterServer.RequestKnownHostData(System.String,System.Int32)">
      <summary>
            Requests the HostData info for one favorite servers (Known Hosts) stored in the client. Answer can be read with <see cref="O:PollKnownHostData" /></summary>
      <param name="host">The ip address of favorite server</param>
      <param name="remotePort">The port number of favorite server</param>
      <seealso cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.AddKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RemoveKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.ClearKnownHosts" />
    </member>
    <member name="M:uLink.MasterServer.RequestKnownHostData(uLink.NetworkEndPoint)">
      <summary>
            Requests the HostData info for one favorite servers (Known Hosts) stored in the client
            using server's <see cref="!:System.Net.NetworkEndPoint" />. Answer can be read with <see cref="O:PollKnownHostData" /></summary>
      <param name="endpoint">The <see cref="!:System.Net.NetworkEndPoint" /> of the favorite server</param>
      <seealso cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.AddKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RemoveKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.ClearKnownHosts" />
    </member>
    <member name="M:uLink.MasterServer.AddKnownHostData(System.String,System.Int32)">
      <summary>
            Store location info for a favorite server (Known Host) in the client.
            </summary>
      <param name="host">The ip address of favorite server</param>
      <param name="remotePort">The port number of favorite server</param>
      <remarks>
            It is possible to store a separate list of known hosts (favorite servers) in the local uLink client.
            Use the API for Known Host Data in this class to build a feature for your users to 
            store their favorite servers and access them easily
            when they try to reconnect to play the game again on the same server as before.
            </remarks>
      <seealso cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RequestKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RemoveKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.ClearKnownHosts" />
    </member>
    <member name="M:uLink.MasterServer.AddKnownHostData(uLink.NetworkEndPoint)">
      <summary>
            Store location info for a favorite server (Known Host) in the client.
            </summary>
      <param name="endpoint">The <see cref="!:System.Net.NetworkEndPoint" /> of favorite server</param>
      <remarks>
            It is possible to store a separate list of known hosts (favorite servers) in the local uLink client.
            Use the API for Known Host Data in this class to build a feature for your users to 
            store their favorite servers and access them easily
            when they try to reconnect to play the game again on the same server as before.
            </remarks>
      <seealso cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RequestKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RemoveKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.ClearKnownHosts" />
    </member>
    <member name="M:uLink.MasterServer.AddKnownHostData(uLink.HostData)">
      <summary>
            Store location info for a favorite server (Known Host) in the client.
            </summary>
      <param name="data">The <see cref="T:uLink.HostData" /> of favorite server</param>
      <remarks>
            It is possible to store a separate list of known hosts (favorite servers) in the local uLink client.
            Use the API for Known Host Data in this class to build a feature for your users to 
            store their favorite servers and access them easily
            when they try to reconnect to play the game again on the same server as before.
            </remarks>
      <seealso cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RequestKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RemoveKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.ClearKnownHosts" />
    </member>
    <member name="M:uLink.MasterServer.RemoveKnownHostData(System.String,System.Int32)">
      <summary>
            Remove location info for a favorite server (Known Host) in the client using server's ip address and port number.
            </summary>
      <param name="host">The ip address of favorite server</param>
      <param name="remotePort">The port of favorite server</param>
      <seealso cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RequestKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.AddKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.ClearKnownHosts" />
    </member>
    <member name="M:uLink.MasterServer.RemoveKnownHostData(uLink.NetworkEndPoint)">
      <summary>
            Remove location info for a favorite server (Known Host) in the client using server's <see cref="!:System.Net.NetworkEndPoint" />.
            </summary>
      <param name="endpoint">The <see cref="!:System.Net.NetworkEndPoint" /> of favorite server.</param>
      <seealso cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RequestKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.AddKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.ClearKnownHosts" />
    </member>
    <member name="M:uLink.MasterServer.ClearKnownHosts">
      <summary>
            Clear all location info for all favorite servers (Known Hosts) in the client.
            </summary>
      <seealso cref="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RequestKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.AddKnownHostData(System.String,System.Int32)" />
      <seealso cref="M:uLink.MasterServer.RemoveKnownHostData(System.String,System.Int32)" />
    </member>
    <member name="M:uLink.MasterServer.PollKnownHosts">
      <summary>
            Gets the list with the most recent update of HostData information for all favorite servers (Known Hosts) stored in the client.
            </summary>
      <seealso cref="M:uLink.MasterServer.RequestKnownHosts" />
      <seealso cref="M:uLink.MasterServer.PollAndRequestKnownHosts(System.Single)" />
    </member>
    <member name="M:uLink.MasterServer.RequestKnownHosts">
      <summary>
            Request to make the complete list of Known Hosts available. 
            </summary>
      <remarks>
            The answer will be available via <see cref="M:uLink.MasterServer.PollKnownHosts" />.
            </remarks>
      <seealso cref="M:uLink.MasterServer.PollKnownHosts" />
      <seealso cref="M:uLink.MasterServer.PollAndRequestKnownHosts(System.Single)" />
    </member>
    <member name="M:uLink.MasterServer.PollAndRequestKnownHosts(System.Single)">
      <summary>
            Gets the list with fresh HostData info for all favorite servers (Known Hosts) stored in the client.
            </summary>
      <remarks>This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest known host list and also make sure the list is refreshed with a specified interval.
            Values like <see cref="F:uLink.HostData.ping" /> and <see cref="F:uLink.LocalHostData.connectedPlayers" /> are refreshed.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.lastError">
      <summary>
            The last <see cref="T:uLink.NetworkConnectionError" /> returned by the master server. 
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkConnectionError.NoError" /></value>
    </member>
    <member name="P:uLink.MasterServer.dedicatedServer">
      <summary>
            Mark this server as a dedicated server (it is running without a human player). 
            </summary>
      <value>Default value is <c>false</c></value>
      <remarks>
            If running as a server, the connection count defines the player count
            and this is reported when registering on the master server. By
            default the master server assumes this server instance is not a dedicated
            server and thus the player count is incremented by one (to account
            for the "player" running the game server). If this is not desired, 
            for example when hosting servers in a data center,
            this variable can be set to <c>true</c> before registering game servers 
            and then only the client connection count
            is reported in the host data as the player count.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.ipAddress">
      <summary>
            The IP address of the master server. Can be the domain name or the IP number.
            </summary>
      <value>Default value is <c>"unityparkdemo.muchdifferent.com"</c></value>
      <remarks>
            MuchDifferents master server is for testing purposes only and shouldn't be used
            for deployment. It's not guaranteed to be always available and we usually only host the latest master server.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.port">
      <summary>
            The connection port of the master server.
            </summary>
      <value>Default value is <c>23466</c></value>
    </member>
    <member name="P:uLink.MasterServer.ping">
      <summary>
            Gets a rolling average roundtrip ping time, measured between this client and the master server. 
            Returns 0 if there is no connection to the master server.
            </summary>
    </member>
    <member name="P:uLink.MasterServer.password">
      <summary>
            The password required to make a connection to the master server.
            </summary>
      <remarks>
            This password value, in a running master server, is set by the operator as 
            a start argument when starting the master server.
            See the manual page for master server for more information.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.isRegistered">
      <summary>
            Is this game server registered in the master server?
            </summary>
      <remarks>
            Use this in the game server, not in a client. Default value is <c>false</c>.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.updateRate">
      <summary>
            The minimum update rate for master server host information update. 
            </summary>
      <remarks>
            Normally host updates are only sent if something in the host
            information has changed (like connected players). The update rate
            defines the minimum amount of time which may elapse between host
            updates. The default value is 80 seconds minimum update rate (where
            a check is made for changes). So if one host update is sent and then
            some field changes 10 seconds later then the update will possibly be
            sent 70 seconds later (at the next change check). If this is set to
            0 then no updates are sent, only initial registration information. 
            </remarks>
      <example>
        <code>
            void StartServer()
            {
               Network.InitializeServer(32, 25002);
               // No host information updates after initial registration
               MasterServer.updateRate = 0;
               MasterServer.RegisterHost("MyUniqueGameType", "JohnDoes game", "l33t game for all");
            }
            </code>
      </example>
    </member>
    <member name="P:uLink.MasterServer.gameType">
      <summary>
            Gets or sets the gameType string for this game server.
            </summary>
      <remarks>
            When you request a game server list from master server, it will find server using its gameType
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.gameName">
      <summary>
            Gets or sets the gameName string for this game server.
            </summary>
      <remarks>
            Name of the game server which you can let the user set. This is not used internally but you can use
            it in any way you see fit (i.e. Name of the user which is hosting a game). 
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.gameMode">
      <summary>
            Gets or sets the gameMode string for this game server.
            </summary>
      <remarks>
            Just like the game name you can let the user set it, i.e. Death Match.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.gameLevel">
      <summary>
            Gets or sets the gameLevel string for this game server.
            </summary>
      <remarks>
            Level of the game server which you can let the user set.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.comment">
      <summary>
            Gets or sets the comment string for this game server.
            </summary>
      <remarks>
            Just like <see cref="P:uLink.MasterServer.gameName" /> and <see cref="P:uLink.MasterServer.gameMode" /> its not used internally. It's a Comment for the game server.
            you can use it for generic data, slogans ...
            </remarks>
    </member>
    <member name="T:uLink.Network">
      <summary>
            The central class in uLink. Contains core functionality in uLink.
            </summary>
      <remarks>
            This class enables several core uLink features such as: starting servers,
            connecting clients, dynamically instantiating network aware objects and
            security/encryption features. Functions marked as Message callbacks
            are events triggered by uLink, which can be implemented in your scripts to
            handle network events with custom code in a client or a server.
            </remarks>
    </member>
    <member name="M:uLink.Network.GetPrefs">
      <summary>
            Gets the persistent Network properties in <see cref="T:uLink.NetworkPrefs" />.
            </summary>
    </member>
    <member name="M:uLink.Network.SetPrefs">
      <summary>
            Sets the persistent Network properties in <see cref="T:uLink.NetworkPrefs" />.
            </summary>
      <remarks>
            The method can't update the saved values in the persistent <see cref="F:uLink.NetworkPrefs.resourcePath" /> file,
            because that assumes the file is editable (i.e. the running project isn't built) and would require file I/O permission.
            Calling this will only update the values in memory.
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.AllocateViewID" -->
    <member name="M:uLink.Network.AllocateViewID(uLink.NetworkPlayer)">
      <summary>
            Allocates one viewID and sets the owner at the same time.
            </summary>
      <param name="owner">The <see cref="T:uLink.NetworkPlayer" /> that you want to be the owner of this ViewID</param>
      <returns>The allocated ID.</returns>
      <remarks>
            Works just like <see cref="O:uLink.Network.AllocateViewID" />.
            </remarks>
    </member>
    <member name="M:uLink.Network.AllocateViewIDs(System.Int32)">
      <summary>
            Allocates an array of viewIDs at once.
            </summary>
      <param name="count">Number of the ViewIDs that you want to allocate.</param>
      <returns>An array of allocated ViewIDs.</returns>
      <remarks>
            Works just like <see cref="O:uLink.Network.AllocateViewID" />.
            <para>
            The owner of this array of viewIDs will become the local <see cref="T:uLink.NetworkPlayer" /></para></remarks>
    </member>
    <member name="M:uLink.Network.AllocateViewIDs(System.Int32,uLink.NetworkPlayer)">
      <summary>
            Allocates an array of viewIDs at once and sets the owner for all of them.
            </summary>
      <param name="count">Number of ViewIDs that you want to allocate.</param>
      <param name="owner">The NetworkPlayer that you want to be the owner of the allocated ViewIDs.</param>
      <returns>An array of allocated ViewIDs.</returns>
      <remarks>
            Works just like <see cref="O:uLink.Network.AllocateViewID" />.
            </remarks>
    </member>
    <member name="M:uLink.Network.DeallocateViewID(uLink.NetworkViewID)">
      <summary>
            Returns an unused viewID to the pool of unused IDs. 
            </summary>
      <param name="viewID">The ViewID that you want to deallocate.</param>
      <returns>Wether the operation was successful or not.</returns>
      <remarks>
            Can only be called in an authoritative server or in authoritative clients. 
            Can only be called on the same peer as the viewID was allocated.
            </remarks>
    </member>
    <member name="M:uLink.Network.DeallocateViewIDs(uLink.NetworkViewID[])">
      <summary>
            Returns an array of viewIDs to the pool of unused IDs. 
            </summary>
      <param name="viewIDs">The array of ViewIDs which you want to deallocate.</param>
      <returns>Wether the operation was successful or not.</returns>
      <remarks>
            Can only be called in an authoritative server or in authoritative clients. 
            Can only be called on the same peer as the viewIDs was allocated.
            </remarks>
    </member>
    <member name="M:uLink.Network.DeallocateViewIDs(uLink.NetworkPlayer)">
      <summary>
            Returns all viewIDs for one <see cref="T:uLink.NetworkPlayer" /> to the pool of unused IDs. 
            </summary>
      <param name="owner">The NetworkPlayer that you want to deallocate ViewIDs owned by it.</param>
      <returns>Wether the operation was successful or not.</returns>
      <remarks>
            Can only be called in an authoritative server or in authoritative clients. 
            Can only be called on the same peer as the viewIDs was allocated.
            </remarks>
    </member>
    <member name="M:uLink.Network.CloseConnection(uLink.NetworkPlayer,System.Boolean)">
      <summary>
            Close the connection to another system.
            </summary>
      <param name="target">Defines which system to close the connection to</param>
      <param name="sendDisconnectionNotification">if set to <c>true</c> sends a reliable disconnection notification to target.</param>
      <remarks>If we are a client the only possible connection to close is the server connection, 
            if we are a server the target player will be kicked out.  If sendDisconnectionNotification is 
            <c>false</c> the connection is dropped, if <c>true</c> a disconnect notification is reliably 
            sent to the remote peer and thereafter the connection is dropped.
            <para>
            You can use this to kick players which cheat or have slow connections drop from the game.
            </para></remarks>
      <seealso cref="M:uLink.Network.Disconnect" />
      <seealso cref="M:uLink.Network.DisconnectImmediate" />
    </member>
    <member name="M:uLink.Network.CloseConnection(uLink.NetworkPlayer,System.Boolean,System.Int32)">
      <summary>
            Close the connection to another system.
            </summary>
      <param name="target">Defines which system to close the connection to</param>
      <param name="sendDisconnectionNotification">if set to <c>true</c> sends a reliable disconnection notification to target.</param>
      <param name="timeout">Will wait this long (seconds) for the ack of the uLink internal disconnect notification RPC before dropping the client anyway.</param>
      <remarks>If we are a client the only possible connection to close is the server connection, 
            if we are a server the target player will be kicked out.  If sendDisconnectionNotification is 
            <c>false</c> the connection is dropped, if <c>true</c> a disconnect notification is reliably 
            sent to the remote peer and thereafter the connection is dropped.
            <para>
            You can use this to kick players which cheat or have slow connections drop from the game.
            </para></remarks>
      <seealso cref="M:uLink.Network.Disconnect" />
      <seealso cref="M:uLink.Network.DisconnectImmediate" />
    </member>
    <member name="M:uLink.Network.Connect(uLink.HostData)">
      <summary>Connects this client to the specified server, registerd in the master server.</summary>
      <param name="host">This is the <see cref="T:uLink.HostData" /> received from the <see cref="T:uLink.MasterServer" />.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(uLink.NetworkEndPoint)">
      <summary>Connects this client to the specified server.</summary>
      <param name="server">The server (includes host and port)</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(System.String,System.Int32)">
      <summary>Connects this client to the specified server.</summary>
      <param name="host">Hostname as string or IP address as a String (four numbers with dots between)</param>
      <param name="remotePort">Server port number</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(System.String[],System.Int32)">
      <summary>Connects this client to the specified server.</summary>
      <param name="hosts">Try to connect to the servers in this array, one by one, until a 
            connections is established</param>
      <param name="remotePort">Server port number</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(uLink.HostData,System.String,System.Object[])">
      <summary>Connects this client to the specified server, registerd in the master server.</summary>
      <param name="host">This is the <see cref="T:uLink.HostData" /> received from the <see cref="T:uLink.MasterServer" />.</param>
      <param name="password">Sends a password (salted and hashed) inside this connection request. 
            Use this as a game/level/instance password if it suits the needs of the game.</param>
      <param name="loginData">Put any number of arguments here as loginData. The data will be 
            delivered to the server and the server can handle the data as a <see cref="T:uLink.BitStream" /> 
            in the notification <see cref="!:uLink.Network.uLink_OnPlayerApproval" />. The server can use this loginData  
            to make a choice between approving the client or denying the client. Use this feature for 
            things like Avatar name, preferred team membership, username, password, client type, etc. 
            It is possible and recommended to encrypt password and loginData. Set 
            <see cref="P:uLink.Network.publicKey" /> in
            the client to turn on encryption before calling this method.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
      <seealso cref="!:uLink.Network.uLink_OnPlayerApproval" />
    </member>
    <member name="M:uLink.Network.Connect(uLink.NetworkEndPoint,System.String,System.Object[])">
      <summary>Connects this client to the specified server.</summary>
      <param name="server">The server (includes host and port)</param>
      <param name="password">Sends a password (salted and hashed) inside this connection request. 
            Use this as a game/level/instance password if it suits the needs of the game.</param>
      <param name="loginData">Put any number of arguments here as loginData. The data will be 
            delivered to the server and the server can handle the data as a <see cref="T:uLink.BitStream" /> 
            in the notification <see cref="!:uLink.Network.uLink_OnPlayerApproval" />. The server can use this loginData  
            to make a choice between approving the client or denying the client. Use this feature for 
            things like Avatar name, preferred team membership, username, password, client type, etc. 
            It is possible and recommended to encrypt password and loginData. Set 
            <see cref="P:uLink.Network.publicKey" /> in
            the client to turn on encryption before calling this method.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, <see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
      <seealso cref="!:uLink.Network.uLink_OnPlayerApproval" />
    </member>
    <member name="M:uLink.Network.Connect(System.String,System.Int32,System.String,System.Object[])">
      <summary>Connects this client to the specified server.</summary>
      <param name="host">Hostname as string or IP address as a String (four numbers with dots between)</param>
      <param name="remotePort">Server port number</param>
      <param name="password">Sends a password (salted and hashed) inside this connection request. 
            Use this as a game/level/instance password if it suits the needs of the game.</param>
      <param name="loginData">Put any number of arguments here as loginData. The data will be 
            delivered to the server and the server can handle the data as a <see cref="T:uLink.BitStream" /> 
            in the notification <see cref="!:uLink.Network.uLink_OnPlayerApproval" />. The server can use this loginData  
            to make a choice between approving the client or denying the client. Use this feature for 
            things like Avatar name, prefered team membership, username, password, client type, etc. 
            It is possible and recommended to encrypt password and loginData. Set 
            <see cref="P:uLink.Network.publicKey" /> in
            the client to turn on encryption before calling this method.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
      <seealso cref="!:uLink.Network.uLink_OnPlayerApproval" />
    </member>
    <member name="M:uLink.Network.Connect(System.String[],System.Int32,System.String,System.Object[])">
      <summary>Connects this client to the specified server.</summary>
      <param name="hosts">Try to connect to the servers in this array, one by one, until a 
            connections is established</param>
      <param name="remotePort">Server port number</param>
      <param name="password">Sends a password (salted and hashed) inside this connection request. 
            Use this as a game/level/instance password if it suits the needs of the game.</param>
      <param name="loginData">Put any number of arguments here as loginData. The data will be 
            delivered to the server and the server can handle the data as a <see cref="T:uLink.BitStream" /> 
            in the notification <see cref="!:uLink.Network.uLink_OnPlayerApproval" />. The server can use this loginData  
            to make a choice between approving the client or denying the client. Use this feature for 
            things like Avatar name, prefered team membership, username, password, client type, etc. 
            It is possible and recommended to encrypt password and loginData. Set 
            <see cref="P:uLink.Network.publicKey" /> in
            the client to turn on encryption before calling this method.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
      <seealso cref="!:uLink.Network.uLink_OnPlayerApproval" />
    </member>
    <member name="M:uLink.Network.Destroy(uLink.NetworkView)">
      <summary>
             Destroy the game object associated with this <see cref="T:uLink.NetworkView" /> across the 
             network and remove the buffered RPCs for this <see cref="T:uLink.NetworkView" /> from the uLink RPC buffer.
            </summary>
      <remarks>The object is destroyed locally and remotely.</remarks>
      <returns>
        <c>True</c> if the object was successfully destroyed.</returns>
    </member>
    <member name="M:uLink.Network.Destroy(uLink.NetworkViewID)">
      <summary>
             Destroy the game object associated with this <see cref="T:uLink.NetworkViewID" /> across the 
             network and remove the buffered RPCs for this <see cref="T:uLink.NetworkViewID" /> from the uLink RPC buffer.
            </summary>
      <remarks>The object is destroyed locally and remotely.</remarks>
      <returns>
        <c>True</c> if the object was successfully destroyed.</returns>
    </member>
    <member name="M:uLink.Network.Destroy(UnityEngine.GameObject)">
      <summary>
             Destroy this game object across the network and remove the buffered RPCs 
             for the <see cref="T:uLink.NetworkViewID" /> attached to this gameObject from the uLink RPC buffer.
            </summary>
      <remarks>The object is destroyed locally and remotely.</remarks>
      <returns>
        <c>True</c> if the object was successfully destroyed.</returns>
    </member>
    <member name="M:uLink.Network.DestroyPlayerObjects(uLink.NetworkPlayer)">
      <summary>
            Destroy all network aware objects owned by this player across the
            network and remove the buffered RPCs from the uLink RPC buffer.
            </summary>
      <remarks>
        <para>The objects owned by this player are destroyed locally and
            remotely. It is common to call this method in the callback 
            <see cref="!:uLink_OnPlayerDisconnected(uLink.NetworkPlayer)" />.
            </para>
        <para>
            All buffered RPCs (including the instantiating RPCs) for the objects 
            owned by this player are removed from the uLink RPC buffer. This is 
            done by internal calls to <see cref="M:uLink.Network.RemoveInstantiates(uLink.NetworkPlayer)" />
            and <see cref="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer)" />.
            </para>
        <para>
            Who owns a network instantiated object is determined when the 
            <see cref="O:uLink.Network.Instantiate" /> method is used. If the
            owner hasn't been specified in the arguments to Instantiate, it is
            the caller of Instantiate. When you insert objects in scen and assign manual ViewIDs to them, all of them will be owned by server.
            </para>
      </remarks>
    </member>
    <member name="M:uLink.Network.DestroyAll">
      <summary>
            Destroy all dynamically allocated or instantiated network aware objects across the network and remove all buffered RPCs from the uLink RPC buffer.
            </summary>
      <remarks>This won't affect objects assigned manual ViewIDs. To destroy them as well see <see cref="M:uLink.Network.DestroyAll(System.Boolean)" /></remarks>
    </member>
    <member name="M:uLink.Network.DestroyAll(System.Boolean)">
      <summary>
            Destroy all network aware objects across the network and remove all buffered RPCs from the uLink RPC buffer.
            </summary>
      <param name="includeManual">If true, also destroy objects assigned manual ViewIDs; otherwise skip them.</param>
    </member>
    <member name="M:uLink.Network.Disconnect">
      <summary>
            Closes the network connection.
            </summary>
      <remarks>This disconnect function uses a default timeout value of 200 ms. If this is a client, it will send 
            a reliable disconnect message to the server and wait for the ack during the timeout. During the timeout, 
            incoming and outgoing statesync and RPCs will be handled as normal.
            
            The complete network state, like security and password, is reset by this function. 
            
            If this is a server, it will disconnect all clients after sending a disconnect messages to them.</remarks>
      <seealso cref="M:uLink.Network.DisconnectImmediate" />
      <seealso cref="M:uLink.Network.CloseConnection(uLink.NetworkPlayer,System.Boolean)" />
    </member>
    <member name="M:uLink.Network.Disconnect(System.Int32)">
      <summary>
            Closes the network connection.
            </summary>
      <param name="timeout">Indicates how long (in milliseconds) this network connection will wait for an ack message and during that wait time it will continue to receive RPCs and statesyncs.</param>
      <remarks>If this is a client, it will try to send 
            a disconnect message to the server before this timeout. During the timeout, incoming statesync and RPCs will be handled as normal.
            If the timeout passes and the ack has not been received, the client will disconnect and clean up anyway.
            
            The network state, like security and password, is reset by this function. 
            
            If this is a server, it will disconnect all clients after sending a disconnect messages to them.</remarks>
      <seealso cref="M:uLink.Network.DisconnectImmediate" />
      <seealso cref="M:uLink.Network.CloseConnection(uLink.NetworkPlayer,System.Boolean)" />
    </member>
    <member name="M:uLink.Network.DisconnectImmediate">
      <summary>
             Closes the network connection immediately without any notification to others.
             </summary>
      <remarks>The only way others will notice this is by a timeout. Read more about such timeouts 
             in the callback <see cref="!:uLink.Network.uLink_OnPlayerDisconnected" />.</remarks>
      <seealso cref="M:uLink.Network.CloseConnection(uLink.NetworkPlayer,System.Boolean)" />
      <seealso cref="M:uLink.Network.Disconnect" />
    </member>
    <member name="M:uLink.Network.GetAveragePing(uLink.NetworkPlayer)">
      <summary>
            Gets average ping time for a player in milliseconds.
            </summary>
      <param name="target">The NetworkPlayer which you want to get your average ping against.</param>
      <returns>Average ping time for a player in milliseconds. If target is unknown or not connected, then returns -1</returns>
      <remarks>Calculates the average of the last few pings, making this a moving average.
            In the client you should call GetAveragePing(uLink.NetworkPlayer.server) because the only available target is the server. 
            In the server you can check the ping time to any connected player.
            </remarks>
    </member>
    <member name="M:uLink.Network.GetLastPing(uLink.NetworkPlayer)">
      <summary>
            Gets last ping time for a player in milliseconds.
            </summary>
      <param name="target">The NetworkPlayer that you want to know the last ping time for.</param>
      <returns>Last ping time for a player in milliseconds. If target is unknown or not connected, then returns -1</returns>
      <remarks>In the client you should call GetLastPing(uLink.NetworkPlayer.server) because the only available target is the server. 
            In the server you can check the ping time to any connected player.
            </remarks>
    </member>
    <member name="M:uLink.Network.GetStatistics(uLink.NetworkPlayer)">
      <summary>
            Gets a <see cref="T:uLink.NetworkStatistics" /> object for the specified remote player.
            </summary>
      <param name="target">The player at the other end of the connection that you want statistics for.</param>
      <returns>A <see cref="T:uLink.NetworkStatistics" /> object if there is a connection to the player, or null otherwise</returns>
    </member>
    <member name="M:uLink.Network.HavePublicAddress">
      <summary>
            Check if this machine has a public IP address.
            </summary>
      <remarks>
            It checks all the network interfaces for IPv4 public addresses and returns true if one address is found.
            <para>
            If the server does not have any public address, clients outside of the network that it has an address in can not
            access it without using proxy server.
            </para></remarks>
    </member>
    <member name="M:uLink.Network.InitializeServer(System.Int32,System.Int32)">
      <summary>
            Initializes the server.
            </summary>
      <param name="maximumConnections">The maximum number of connections/players.</param>
      <param name="listenPort">The UDP port that server listens to it for client connections.</param>
      <example>
        <code>
            void LaunchServer () {
               uLink.Network.incomingPassword = "uLinkIsAwesome";
               uLink.Network.InitializeServer(32, 25000);
            }
            </code>
      </example>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors <see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
      <remarks>When you want to connect to a server with a password, the client should send the password in <see cref="M:uLink.Network.Connect(uLink.HostData)" /></remarks>
    </member>
    <member name="M:uLink.Network.InitializeServer(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Initializes the server and the bool useProxy indicates if clients must connect via a proxy server.
            </summary>
      <param name="maximumConnections">Maximum number of connections/players</param>
      <param name="listenPort">The UDP port that server listens to it for client connections.</param>
      <param name="useProxy">Indicates wether clients should use a proxy server to connect to this server or not</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors <see cref="F:uLink.NetworkConnectionError.NoError" /> is returned
            </returns>
      <remarks>
            You should use a proxy server if you want to host your game on the internet on a machine which doesn't have a public address.
            See the master server manual page for more information.
            </remarks>
    </member>
    <member name="M:uLink.Network.InitializeServer(System.Int32,System.Int32,System.Int32)">
      <summary>
            Initializes the server and the bool useProxy indicates if clients must connect via a proxy server.
            </summary>
      <param name="maximumConnections">Maximum number of connections which this server accept</param>
      <param name="listenStartPort">The starting port number which server tries to listen to.</param>
      <param name="listenEndPort">The ending port number which the server will try to listen to.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors <see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
      <remarks>
            This specific version of the method is specificly good if you want to start serveres automatically and can not be sure which 
            ports are open and aren't being used by other servers. 
            </remarks>
    </member>
    <member name="M:uLink.Network.InitializeServer(System.Int32,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Initializes the server and the bool useProxy indicates if clients must connect via a proxy server.
            </summary>
      <param name="maximumConnections">Maximum number of connections which this server accept</param>
      <param name="listenStartPort">The starting port number which server tries to listen to.</param>
      <param name="listenEndPort">The ending port number which the server will try to listen to.</param>
      <param name="useProxy">Indicates wether clients should use a proxy server to connect to this server or not</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors <see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
      <remarks>
            This specific version of the method is specificly good if you want to start serveres automatically and can not be sure which 
            ports are open and aren't being used by other servers.
            You should use a proxy server if you want to host your game on the internet on a machine which doesn't have a public address.
            See the master server manual page for more information.
            </remarks>
    </member>
    <member name="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <overloads>The most basic form of all overloaded Instantiate functions is 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            Please read the documentation for that function first.
            </overloads>
      <summary>
            THE MOST BASIC FORM: Creates a network aware object. Instantiates the specified prefab.
            </summary>
      <remarks>
            We recommend registering the prefab with the utility script uLinkRegisterPrefabs before calling
            this method. Read more about this script in the uLink manual chapter about instatiating objects.
            <para>
            The given prefab will be instantiated on all clients and the server in the game.
            State synchronization is automatically set up so there is no extra work involved
            to start that. Internally in uLink, this is a reliable and buffered internal RPC call.
            </para><para>
            All new clients connecting to the server at a later time will get this RPC so
            that the object is automatically instantiated right after the connection has
            been established (at those clients). This call will default to setting the
            caller (<see cref="T:uLink.NetworkPlayer">uLink.NetworkPlayer</see>) as owner and
            creator for this object. Read more about the three object roles in the uLink
            manual. 
            </para><para>
            Be aware that it is possible to remove this buffered RPC by calling
            the <see cref="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer)">uLink.Network.RemoveRPCs</see>
            function.</para></remarks>
      <param name="prefab">The prefab to instantiate in server and all clients regardless of their role.</param>
      <param name="position">The position that the prefab will be instantiated.</param>
      <param name="rotation">The rotation of the object that will be instantiated.</param>
      <param name="group">The group number of the object.</param>
      <param name="initialData">Other initial data for this prefab that is needed
            right at the instantiation. Could be anything beside position and rotation. For
            example color, equipment, buffs, hitpoints, etc.</param>
      <returns>
            The newly instantiated GameObject.
            </returns>
      <example>
        <code>
            // Immediately instantiates a new connected player's character
            // when successfully connected to the server.
            // Note: The server is non-authoritative in this example.
            public Transform playerPrefab;
            
            void uLink_OnConnectedToServer ()
            {
               uLink.Network.Instantiate(playerPrefab, transform.position, transform.rotation, 0); //0 means no group
            }
            </code>
      </example>
    </member>
    <member name="M:uLink.Network.Instantiate``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except the fact that it accepts it's prefab as a component and returns that component of the instantiated GameObject.
            </summary>
      <remarks>When you want to send only one array as initialData, if you don't use the generic overload of Instantaite
            .NET's reflection capability will think that each of the array elements is an argument by itself, so if you send an int[3] it will consider it as (int,int,int)</remarks>
      <returns>The component of the instantiated prefab which has the type of the generic parameter.</returns>
    </member>
    <member name="M:uLink.Network.Instantiate(System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except the prefab is specified as string (name of the prefab).
            </summary>
      <remarks>
            The prefab can be in the resources folder instead of being registered.
            </remarks>
    </member>
    <member name="M:uLink.Network.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab is of type object.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Creates a network aware object. Instantiates one prefab for proxies and another for the creator. Can be used for NPCs which are owned by the server.
            </summary>
      <remarks>This Instatiate is a more advanced form of 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            This Instantiate is perfect for creating NPCs in an authoritative server. 
            <para>
            When called on the server, the server will have two roles for this object, owner and creator. 
            All clients will have the role proxy for this object and they will all get an instantiated 
            prefab dictated by the argument proxyPrefab. The beauty of this is that the server side 
            instantiated GameObject can have more (sensitive and secret) properties that will not 
            be synchronized to clients.
            </para><para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            Read more about the three object roles in the uLink manual. 
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``1(``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
             Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab and ownerPrefab are components and the reutrning value is that component of the instantiated prefab.
             </summary>
      <remarks>When you want to send only one array as initialData, if you don't use the generic overload of Instantaite
             .NET's reflection capability will think that each of the array elements is an argument by itself, so if you send an int[3] it will consider it as (int,int,int)</remarks>
      <returns>The component of the prefab which has the same type of the specified generic type.</returns>
    </member>
    <member name="M:uLink.Network.Instantiate(System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab and ownerPrefabs are passed as strings (GameObject names).
            </summary>
      <remarks>
            You can put the gameObject in the resources folder instead of registering it in the RegisterPrefabs component.
            </remarks>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Creates a network aware object and owner is one the first argument. Instantiates the specified prefab. 
            </summary>
      <remarks>This Instantiate function adds an extra parameter to the basic
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            "owner". This can be used to explicitly set the owner of this object to
            another <see cref="T:uLink.NetworkPlayer" />. This Instantiate is perfect for creating player controlled objects 
            on the server. It can be used in both authoritative servers and non-authoritative servers. 
            <para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            </para><para>Read more about the three object roles in the uLink manual.
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except the fact that the prefab argument should be a component and the same component of the instantiated prefab will be returned.
            </summary>
      <remarks>When you want to send only one array as initialData, if you don't use the generic overload of Instantaite
            .NET's reflection capability will think that each of the array elements is an argument by itself, so if you send an int[3] it will consider it as (int,int,int)</remarks>
      <returns>The component of the instantiated prefab which has the type of the generic parameter.</returns>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab argument is a string.
            </summary>
      <remarks>
            The prefab can be in the resources folder instead of being registered using the RegisterPrefabs component.
            </remarks>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab argument is of type object.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Creates a network aware object. Instantiates three different prefabs, for the owner, for the creator and for the proxies. 
            </summary>
      <remarks>This is a more advanced form of 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            This Instantiate is perfect for creating each player's avatar in an authoritative server. 
            When called on the server, the server will have the "creator" role for this object. The 
            "owner" role is given to the <see cref="T:uLink.NetworkPlayer" /> that will control this avatar. 
            All other clients will have the "proxy" role for this object.
            <para>The beauty of this is that the server side instantiated GameObject, the creator prefab, 
            can have more (sensitive and secret) 
            properties that should never be synchronized to any clients. 
            </para><para>
            Also, if the game uses statesync between the creator and the owner, this statesync can send
            completely different properties compared to the statesync between the creator and the proxies.
            The prefabs need to be registered using the RegisterPrefab component.
            Read more on this topic in the messages <see cref="!:uLink_OnSerializeNetworkView" /> and 
            <see cref="!:uLink_OnSerializeNetworkViewOwner" />. 
            </para><para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            </para><para>
            Read more about the three object roles in the uLink manual. 
            </para><para>
            It is possible to set proxyPrefab and/or ownerPrefab to null to never use that role. 
            One example when it is smart to set
            proxyPrefab no null is a situation when you want to statesync an object between the owner
            (a player) and the creator (the server), but no other clients should be aware this object. 
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,``0,``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab are of type component and the same component of the instantiated prefab will be returned.
            </summary>
      <remarks>When you want to send only one array as initialData, if you don't use the generic overload of Instantaite
            .NET's reflection capability will think that each of the array elements is an argument by itself, so if you send an int[3] it will consider it as (int,int,int)</remarks>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,System.String,System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab are string arguments
            and the prefabs can be in the resources folder.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Advanced form: Should only be used if an allocated <see cref="T:uLink.NetworkViewID" /> is already known. 
            You should only use this in the specific cases which you want to implement specific pooling algorithms for networkviews
            and other places which normal Instantiate calls and the Instantiate poll utility script doesn't work on your case.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkViewID,uLink.NetworkPlayer,``0,``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab are of type component and the same component of the instantiated prefab will be returned.
            </summary>
      <remarks>When you want to send only one array as initialData, if you don't use the generic overload of Instantaite
            .NET's reflection capability will think that each of the array elements is an argument by itself, so if you send an int[3] it will consider it as (int,int,int)</remarks>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,System.String,System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab are strings.
            The prefabs can be in the resources folder as well as being registered using the RegisterPrefab component.
            </summary>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``2(``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``2(``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``2(uLink.NetworkPlayer,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``2(uLink.NetworkPlayer,``0,``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,System.String,System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Advanced form: Should only be used if an allocated <see cref="T:uLink.NetworkViewID" /> is already known. Don't use it
            unless you have some specific need which can not be answered by other overloads
            and the instantiate pool utility script.
            </summary>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``2(uLink.NetworkViewID,uLink.NetworkPlayer,``0,``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.Instantiate``1(uLink.NetworkViewID,uLink.NetworkPlayer,System.String,System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)" -->
    <member name="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer)">
      <overloaded>Remove buffered RPCs</overloaded>
      <summary>
            Remove all buffered RPCs that was sent by target player (argument sender).
            </summary>
      <param name="sender">The NetworkPlayer that you want to remove its RPCs</param>
      <remarks>Does not remove buffered Instantiate RPCs.
            Usually you use it when a player disconnects or when the old RPCs are no longer meaningful (i.e. game level changed).
            </remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer,uLink.NetworkGroup)">
      <summary>
            Remove all buffered RPCs that was sent by target player (argument sender) for just one <see cref="T:uLink.NetworkGroup" />.
            </summary>
      <param name="sender">The NetworkPlayer that you want to remove its RPCs</param>
      <param name="group">The network group that you want to remove its RPCs</param>
      <remarks>Does not remove buffered Instantiate RPCs.
            It's useful for culling and other scenarios which you add and remove players to/from groups much.
            </remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCs(uLink.NetworkViewID)">
      <summary>
            Remove all buffered RPCs which belong to one viewID.
            </summary>
      <param name="viewID">The ViewID of the networked object that you want to remove buffered RPCs for.</param>
      <remarks>Does not remove buffered Instantiate RPCs.
            Usually you use it when your networked object has a state which old RPCs are no longer valid/useful..</remarks>
    </member>
    <member name="M:uLink.Network.RemoveAllRPCs">
      <summary>
            Remove all buffered RPCs (excluding those with manual viewIDs).
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs. Also won't affect objects assigned manual ViewIDs. To remove buffered RPCs for them, see <see cref="M:uLink.Network.DestroyAll(System.Boolean)" /></remarks>
    </member>
    <member name="M:uLink.Network.RemoveAllRPCs(System.Boolean)">
      <summary>
            Remove all buffered RPCs.
            </summary>
      <param name="includeManual">If true, also remove buffered RPCs for objects assigned manual ViewIDs; otherwise skip them.</param>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsInGroup(uLink.NetworkGroup)">
      <summary>
            Remove all RPCs which belongs to one group.
            </summary>
      <param name="group">The network group that you want to remove all of its RPCs for all players.</param>
      <remarks>
            This usually can be used when you want to use the group for something completely different and want to clean it up.
            </remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsByName(uLink.NetworkGroup,System.String)">
      <overloaded>Remove buffered RPCs by RPC name</overloaded>
      <summary>
            Remove all buffered RPCs which belong to viewIDs in the specificed group and has the specified name.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsByName(uLink.NetworkViewID,System.String)">
      <overloaded>Remove buffered RPCs by RPC name</overloaded>
      <summary>
            Remove all buffered RPCs which belong to one viewID and has the specified name.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsByName(uLink.NetworkPlayer,System.String)">
      <summary>
            Remove all buffered RPCs that was sent by target player (argument sender) and has the specified name.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsByName(System.String)">
      <summary>
            Remove all buffered RPCs that has the specified name.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveInstantiate(uLink.NetworkViewID)">
      <summary>
            Remove one instantiating RPC from the RPC buffer.
            </summary>
      <param name="viewID">The ViewID that you want to remove the instantiate calls that are for that network object</param>
    </member>
    <member name="M:uLink.Network.RemoveInstantiates(uLink.NetworkPlayer)">
      <summary>
            Remove all instantiating RPC which has this sender from the RPC buffer.
            </summary>
      <param name="sender">The player that you want to remove all of its Instantiate RPCs</param>
      <remarks>
            The player who sends the RPC matters and not the owner.
            </remarks>
    </member>
    <member name="M:uLink.Network.RemoveInstantiates(uLink.NetworkPlayer,uLink.NetworkGroup)">
      <summary>
            Remove all instantiating RPC from RPC buffer with this sender and this group.
            </summary>
      <param name="sender">The player which you want to remove its instantiate RPCs</param>
      <param name="group">The group that the Instantiate call should be in it, to be removed</param>
    </member>
    <member name="M:uLink.Network.RemoveInstantiatesInGroup(uLink.NetworkGroup)">
      <summary>
            Remove all instantiating RPCs from RPC buffer belonging to the group.
            </summary>
      <param name="group">The group that you want to remove all instantiate RPCs in it</param>
    </member>
    <member name="M:uLink.Network.RemoveInstantiatingRPCs(uLink.NetworkPlayer)">
      <overloaded>Obsolete.</overloaded>
    </member>
    <member name="M:uLink.Network.RemoveAllInstantiates">
      <summary>
            Removes all instantiating RPCs from the RPC buffer regardless of the sender player and group.
            </summary>
    </member>
    <member name="M:uLink.Network.SetGroupFlags(uLink.NetworkGroup,uLink.NetworkGroupFlags)">
      <summary>
            Sets the flags for a network group.
            </summary>
      <param name="group">The group number which you want to change its settings</param>
      <param name="flags">The settings values which you want to set.</param>
      <remarks>
            This can be used to change the settings of the group. Using bitwise operators and the enum values you can
            turn on/off all settings as you do in other enums.
            <para>
            You can automatically add all new players to this group automatically. 
            You can set if you want to Hide gameobjects of the group from those
            who are not in the group or not.
            </para><para>
            See the groups page in manual for more information.
            </para></remarks>
      <example>
        <code>
            void Start()
            {
            	uLink.SetGroupFlags(1,NetworkGroupFlags.AddNewPlayers);
            }
            </code>
      </example>
    </member>
    <member name="M:uLink.Network.GetGroupFlags(uLink.NetworkGroup)">
      <summary>
            Gets the group settings.
            </summary>
      <param name="group">The group that you want to set its settings.</param>
      <returns>The <see cref="T:uLink.NetworkGroupFlags" /> representing the group's settings</returns>
      <remarks>See the groups manual page for more information</remarks>
    </member>
    <member name="M:uLink.Network.AddPlayerToGroup(uLink.NetworkPlayer,uLink.NetworkGroup)">
      <summary>
            Adds a <see cref="T:uLink.NetworkPlayer" /> to a group.
            </summary>
      <param name="target">The player that you want to add to a specific group.</param>
      <param name="group">The group that you want to add a player to.</param>
      <remarks>
            A player is in a group if there is an object in the group which is owned by it or you add it explicitly to the group by this call.
            Usually this can be used to manage game sessions/network culling with groups.
            <para>
            See the manual page related to groups and the example project related to groups feature.
            </para></remarks>
      <seealso cref="M:uLink.Network.RemovePlayerFromGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" />
    </member>
    <member name="M:uLink.Network.RemovePlayerFromGroup(uLink.NetworkPlayer,uLink.NetworkGroup)">
      <summary>
            Removes a <see cref="T:uLink.NetworkPlayer" /> from a group
            </summary>
      <param name="target">The player that you want to remove from a group.</param>
      <param name="group">The group that you want to remove the player from.</param>
      <remarks>
            See the groups manual page for more information. You can check the example project related to groups as well. 
            </remarks>
      <seealso cref="M:uLink.Network.AddPlayerToGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" />
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkViewID,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(System.String,uLink.NetworkPlayer,System.Object[])" />.
            The only difference is that you should pass the ViewID of the object which you want to send the RPC to.
            </remarks>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkViewID,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <param name="viewID">ViewID of the networked object that you want to send the RPC to.</param>
      <param name="rpcName">Name of the RPC that you want to call</param>
      <param name="targets">The <see cref="T:uLink.NetworkPlayer" />s that you want to send the RPC to them.</param>
      <param name="args">The arguments that you want to send to the RPC</param>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])" />.
            The only difference is that you should pass the ViewID of the object which you want to send the RPC to.
            </remarks>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkViewID,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkFlags,uLink.NetworkViewID,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkFlags,uLink.NetworkViewID,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="!:NetworkView.RPC(uLink.NetworkFlags,System.String,IEnumerale&lt;uLink.NetworkPlayer&gt;,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkFlags,uLink.NetworkViewID,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.UnreliableRPC(uLink.NetworkViewID,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC over an unreliable channel in uLink.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.UnreliableRPC(System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.UnreliableRPC(uLink.NetworkViewID,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC over an unreliable channel in uLink.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.UnreliableRPC(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.UnreliableRPC(uLink.NetworkViewID,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC over an unreliable channel in uLink.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.UnreliableRPC(System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.UnencryptedRPC(uLink.NetworkViewID,System.String,uLink.NetworkPlayer,System.Object[])" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.UnencryptedRPC(uLink.NetworkViewID,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])" -->
    <!-- Badly formed XML comment ignored for member "M:uLink.Network.UnencryptedRPC(uLink.NetworkViewID,System.String,uLink.RPCMode,System.Object[])" -->
    <member name="M:uLink.Network.SetLevelPrefix(System.Int32)">
      <summary>
            Sets the level prefix. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="M:uLink.Network.SetReceivingEnabled(uLink.NetworkPlayer,uLink.NetworkGroup,System.Boolean)">
      <summary>
            Turn on or off the receiving of network traffic. Deprecated.
            </summary>
      <remarks>SetReceivingEnabled is deprecated, please use <see cref="M:uLink.Network.AddPlayerToGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> or <see cref="M:uLink.Network.RemovePlayerFromGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> instead.</remarks>
    </member>
    <member name="M:uLink.Network.SetSendingEnabled(uLink.NetworkGroup,System.Boolean)">
      <summary>
            Turn on or off the sending of network traffic for one group only. Deprecated.
            </summary>
      <remarks>SetSendingEnabled is deprecated, please use <see cref="M:uLink.Network.AddPlayerToGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> or <see cref="M:uLink.Network.RemovePlayerFromGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> instead.</remarks>
    </member>
    <member name="M:uLink.Network.SetSendingEnabled(uLink.NetworkPlayer,uLink.NetworkGroup,System.Boolean)">
      <summary>
            Turn on or off the sending of network traffic. Deprecated.
            </summary>
      <remarks>SetSendingEnabled is deprecated, please use <see cref="M:uLink.Network.AddPlayerToGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> or <see cref="M:uLink.Network.RemovePlayerFromGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> instead.</remarks>
    </member>
    <member name="M:uLink.Network.TestConnection">
      <summary>
            Test this machines network connection. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="M:uLink.Network.TestConnection(System.Boolean)">
      <summary>
            Test this machines network connection. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="M:uLink.Network.TestConnectionNAT">
      <summary>
            Test the connecction specifically for NAT punchthrough connectivity. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.Int32)">
      <overloads>Redirects the client to another server. 
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </overloads>
      <summary>
            Redirects the client to another server on the same host.
            </summary>
      <param name="target">The player that you want to tell him/her to redirect and connect to another server.</param>
      <param name="port">The port that the new server that you want to connect to is listening to.</param>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            <para>
            This can be used for multiple purposes from custom handover logic to upgrading servers.
            </para></remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.Int32,System.String)">
      <summary>
            Redirects the client to another server on the same host.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,uLink.NetworkEndPoint)">
      <summary>
            Redirects the client to another server.
            </summary>
      <param name="target">The player that you want to redirect to another server.</param>
      <param name="redirectTo">The IP adress of the server that you want to connect to.</param>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,uLink.NetworkEndPoint,System.String)">
      <summary>
            Redirects the client to another server.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.String,System.Int32)">
      <summary>
            Redirects the client to another server.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.String,System.Int32,System.String)">
      <summary>
            Redirects the client to another server.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.InitializeSecurity">
      <summary>
            Initializes security for all current and future players on the server.
            </summary>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityInitialized" /> callback is sent as security is turned on for each players session.
            Security in clients can be turned on before connecting by assigning <see cref="P:uLink.Network.publicKey" />.
            <para>
            Keep in mind that you don't have to and should not send everything in secure mode and you can use <see cref="T:uLink.NetworkFlags" /> to send RPCs
            in secure or insecure mode.
            </para></remarks>
      <seealso cref="!:UnInitializeSecurity()" />
    </member>
    <member name="M:uLink.Network.InitializeSecurity(System.Boolean)">
      <summary>
            Initializes security for all future players and optionally already connected players.
            </summary>
      <param name="includingCurrentPlayers">Whether or not to intialize security for already connected players.</param>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityInitialized" /> callback is sent as security is turned on for each players session.
            Security in clients can be turned on before connecting by assigning <see cref="P:uLink.Network.publicKey" />.
            <para>
            Keep in mind that you don't have to and should not send everything in secure mode and you can use <see cref="T:uLink.NetworkFlags" /> to send RPCs
            in secure or insecure mode.
            </para></remarks>
      <see cref="!:UnInitializeSecurity(bool)" />
    </member>
    <member name="M:uLink.Network.InitializeSecurity(uLink.NetworkPlayer)">
      <summary>
             Initializes security for a specific player.
             </summary>
      <remarks>
             Use this only on the server. <see cref="!:uLink_OnSecurityInitialized" /> callback is sent as security is turned on for each players session.
             Security in clients can be turned on before connecting by assigning <see cref="P:uLink.Network.publicKey" />.
             <para>
             Keep in mind that you don't have to and should not send everything in secure mode and you can use <see cref="T:uLink.NetworkFlags" /> to send RPCs
             in secure or insecure mode.
             </para></remarks>
      <seealso cref="!:UnInitializeSecurity(uLink.NetworkPlayer)" />
    </member>
    <member name="M:uLink.Network.UninitializeSecurity">
      <summary>
            Removes security for all current and future players.
            </summary>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityUninitialized" />
            callbacks are sent as security is removed from each players session.
            </remarks>
      <seealso cref="M:uLink.Network.InitializeSecurity" />
    </member>
    <member name="M:uLink.Network.UninitializeSecurity(System.Boolean)">
      <summary>
            Remove security for all future players and optionally already connected players.
            </summary>
      <param name="includingCurrentPlayers">Whether or not to remove security for already connected players.</param>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityUninitialized" /> callback is sent as security is removed from each players session.
            </remarks>
      <seealso cref="M:uLink.Network.InitializeSecurity(System.Boolean)" />
    </member>
    <member name="M:uLink.Network.UninitializeSecurity(uLink.NetworkPlayer)">
      <summary>
            Removes security for a specific player.
            </summary>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityUninitialized" /> callback is sent once security is removed from the players session.
            </remarks>
      <seealso cref="M:uLink.Network.InitializeSecurity(uLink.NetworkPlayer)" />
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.String)">
      <summary>
            Starts the server as a cell server and connects it to PikkoServer.
            </summary>
      <remarks>See PikkoServer MMO manual page for more information.</remarks>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.String[])">
      <summary>
            Starts the server as a cell server and connects it to PikkoServer. It tries addresses one by one to see, where it can connect to.
            </summary>
      <remarks>See PikkoServer MMO manual page for more information.</remarks>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,uLink.NetworkEndPoint)">
      <summary>
            Starts the server as a cell server and connects it PikkoServer.
            </summary>
      <remarks>See PikkoServer MMO manual page for more information.</remarks>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.String,System.Int32)">
      <summary>
            Starts the server as a cell server and connects it PikkoServer.
            </summary>
      <remarks>See PikkoServer MMO manual page for more information.</remarks>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.String[],System.Int32)">
      <summary>
            Starts the server as a cell server and connects it PikkoServer.
            </summary>
      <remarks>See PikkoServer MMO manual page for more information.</remarks>
    </member>
    <member name="M:uLink.Network.ResynchronizeClock(System.Double)">
      <summary>
            This method retries to update the Network time of the clients with the server. 
            It only should be called on the client.
            </summary>
      <param name="durationInSeconds">The duration that it can take to synchronize the time.</param>
    </member>
    <member name="P:uLink.Network.requireSecurityForConnecting">
      <summary>
            Gets or sets if a uLink client requires a public key before connecting to the server.
            </summary>
      <remarks>This value is only used in clients. If true, the client can only connect 
            to a server if the public key has been provided with <see cref="P:uLink.Network.publicKey" />. 
            Default value is <c>false</c>.</remarks>
    </member>
    <member name="P:uLink.Network.licenseKey">
      <summary>
            Gets or sets the uLink licenseKey.
            </summary>
      <remarks>
            You can use the <see cref="!:uLinkEnterLicenseKey" /> component to add your license key to your game servers.
            Note that you should not put your license key in your client applications because it will be exposed for piracy.
            You can use defines to only include the string in server version of your code or use the key in editor in a prefab which is only inserted in server scenes.
            </remarks>
    </member>
    <member name="P:uLink.Network.symmetricKeySize">
      <summary>
            Gets or sets the symmetricKeySize.
            </summary>
    </member>
    <member name="P:uLink.Network.lastError">
      <summary>
            Gets the last returned <see cref="T:uLink.NetworkConnectionError" />.
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkConnectionError.NoError" /></value>
    </member>
    <member name="P:uLink.Network.networkViews">
      <summary>
            Gets an array of all instantiated networkViews.
            </summary>
    </member>
    <member name="P:uLink.Network.networkViewCount">
      <summary>
            Gets the number of instantiated networkViews.
            </summary>
    </member>
    <member name="P:uLink.Network.connections">
      <summary>
            Gets all connected players.
            </summary>
      <remarks>
            On a client this array contains only the server.
            </remarks>
      <example>
            This C# example can be run on a server with GUI. When you hit the button a player will be disconnected.
            <code>
            void OnGUI() {
               if (GUILayout.Button ("Disconnect first player")) {
                   if (uLink.Network.connections.length &gt; 0) {
                       Debug.Log("Disconnecting: "+
                           uLink.Network.connections[0].ipAddress+":"+uLink.Network.connections[0].port);
                       uLink.Network.CloseConnection(uLink.Network.connections[0], true);
                   } 
               }    
            }
            </code></example>
    </member>
    <member name="P:uLink.Network.connectionTesterIP">
      <summary>
            Gets or sets the connection tester IP. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future.</remarks>
    </member>
    <member name="P:uLink.Network.connectionTesterPort">
      <summary>
            Gets or sets the connection tester port. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future.</remarks>
    </member>
    <member name="P:uLink.Network.incomingPassword">
      <summary>
            Gets or sets the password for the server (for incoming connections).
            </summary>
      <remarks>This must be matched in the 
            clients. Pass "" to specify no password (this is default).</remarks>
      <example>
        <code>
            void ConnectToServer () //On the client
            {
               Network.Connect("127.0.0.1", 25000, "HolyMoly");
            }
            
            void LaunchServer () //On the server
            {
               Network.incomingPassword = "HolyMoly";
               Network.InitializeServer(32, 25000);
            }
            </code>
      </example>
      <seealso cref="M:uLink.Network.Connect(uLink.HostData)" />
    </member>
    <member name="P:uLink.Network.isClient">
      <summary>
            Gets a value indicating whether this instance is a uLink client.
            </summary>
      <value>
        <c>true</c> if this instance is client; otherwise, <c>false</c>. 
            Returns true even if the client's <see cref="P:uLink.Network.status" /> is connecting.</value>
      <seealso cref="P:uLink.Network.isServer" />
    </member>
    <member name="P:uLink.Network.isMessageQueueRunning">
      <summary>
            Enable or disable the processing of incoming network messages. No messages are discarded.
            </summary>
      <remarks>This feature can be used to stop all incoming network traffic in a client, 
            for example when the client is loading a level. The statesync and RPC messages are not discarded by uLink. 
            They are delivered later when this value is set to <c>true</c>.
            There is no limit for the message queue, so please do not turn this off in a client unless you plan 
            to turn it on again, otherwise the client might end up with a memory leak.
            </remarks>
      <value>
        <c>true</c> when incoming network messages are processed; otherwise, <c>false</c>. Default value is true.
            </value>
    </member>
    <member name="P:uLink.Network.isServer">
      <summary>
            Gets a value indicating whether this instance is a server.
            </summary>
      <value>
        <c>true</c> if this instance is server; otherwise, <c>false</c>. 
            Returns true even if the server's <see cref="P:uLink.Network.status" /> is connecting.</value>
      <seealso cref="P:uLink.Network.isClient" />
    </member>
    <member name="P:uLink.Network.maxConnections">
      <summary>
            Gets or sets the maximum number of connections/players allowed on a server.
            </summary>
      <remarks>
            This cannot be set higher than 
            the connection count given in <see cref="O:uLink.Network.InitializeServer" />.
            In addition, there are two special values, 0 and -1. Setting it to 0 means no new connections 
            can be made but the existing ones stay connected. Setting it to -1 means the maximum 
            connection count is set to the number of currently open connections. 
            </remarks>
    </member>
    <member name="P:uLink.Network.maxManualViewIDs">
      <summary>
            Gets or sets the maximum number of manualViewIDs that are available for usage.
            </summary>
      <value>Default value is 1000.</value>
      <remarks>
            Increase this value if there is a need to assign more than 1000 manualViewIDs in the game.
            </remarks>
    </member>
    <member name="P:uLink.Network.minimumAllocatableViewIDs">
      <summary>
            The minimum number of entries in the clients pool of unused ViewIDs.
            </summary>
      <value>Default value is 1000.</value>
      <remarks>
            This value is interesting when creating a game with clients that make lots of Instantiate calls, 
            thus being authoritative clients.
            A ViewID pool is given to each client when it connects. The size of the pool is dictated by this property plus 
            the property <see cref="P:uLink.Network.minimumUsedViewIDs" />. The client starts to allocate these viewIDs 
            one by one for every Instantiate call. When the unused (free) number of viewIDs reach this minimum in the client,
            uLink will make a call to the server to get more (unused) viewIDs.   
            The server and clients should be in sync regarding this value. Setting this higher only on the server has the effect that it sends more 
            view ID numbers to clients, than they really want. Setting this higher only on clients 
            means they request more view IDs more often, for example twice in a row, as the pools 
            received from the server don't contain enough numbers.
            
            </remarks>
      <example>
        <code>
            void Awake () {
               // Use this setting on both client and server.
               Network.minimumAllocatableViewIDs = 500;
            }
            </code>
      </example>
    </member>
    <member name="P:uLink.Network.minimumUsedViewIDs">
      <summary>
            The number of viewIDs each client is supposed to use (allocate) in a normal game session. 
            </summary>
      <value>Default value is 1</value>
      <remarks>
            This value is interesting when creating a game with clients that make lots of Instantiate 
            calls, thus being authoritative clients. A ViewID pool is given to each client when it 
            connects. The size of the pool is dictated by this property plus the property 
            <see cref="P:uLink.Network.minimumAllocatableViewIDs" />. To make the pool size bigger by default just 
            increase this number. The motive for increasing this number is that the clients making 
            many Instantiate calls want to get bigger "chunks" of unused viewIDs when the client connects and 
            also whenever the client reaches its <see cref="P:uLink.Network.minimumAllocatableViewIDs" />. This reduces the 
            amount if uLink internal RPCs to the server to allocate more viewIDs.
            </remarks>
      <example>In an FPS game where players shoot at each other with rockets and the rockets are 
            network aware objects it could be wise to increase this number.</example>
    </member>
    <member name="P:uLink.Network.natFacilitatorIP">
      <summary>
            Gets or sets the NAT facilitator IP. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="P:uLink.Network.natFacilitatorPort">
      <summary>
            Gets or sets the NAT facilitator port. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="P:uLink.Network.status">
      <summary>
            Gets the <see cref="T:uLink.NetworkStatus" /> of this network peer (<see cref="T:uLink.NetworkPeerType" />).
            It shows wether the peer is connected/disconnected/...
            </summary>
    </member>
    <member name="P:uLink.Network.listenPort">
      <summary>
            Gets the UDP port number for the socket uLink has opened.
            </summary>
      <return>0 if the socket is not open.</return>
    </member>
    <member name="P:uLink.Network.peerType">
      <summary>
            Gets the type of this network peer (i.e. server, client, disconnected ...). 
            </summary>
      <seealso cref="P:uLink.Network.isServer" />
      <seealso cref="P:uLink.Network.isClient" />
    </member>
    <member name="P:uLink.Network.player">
      <summary>
            Gets the player at this peer/host.
            </summary>
      <remarks>On the server this get call will return the special 
            <see cref="T:uLink.NetworkPlayer" /> indicating this is a server 
            (uLink.NetworkPlayer.<see cref="F:uLink.NetworkPlayer.server" />).
            </remarks>
      <seealso cref="F:uLink.NetworkPlayer.server" />
      <seealso cref="P:uLink.Network.connections" />
    </member>
    <member name="P:uLink.Network.useProxy">
      <summary>
            Indicates if it is required that clients connect via a proxy
            </summary>
      <remarks>
            Set this value to true in a game server before regestering the server in the master server.
            Read more about the master server and the proxy server in the Master Server and Proxy manual chapter.
            In uLink, master server provides the proxy server functionality as well so the port and ip of the proxy server are the same that you use for master server. 
            </remarks>
    </member>
    <member name="P:uLink.Network.proxyIP">
      <summary>Not in use.</summary>
      <remarks>Read the Master Server and Proxy manual chapter. It explains how to use the Proxy Server.</remarks>
    </member>
    <member name="P:uLink.Network.proxyPassword">
      <summary>Not in use.</summary>
      <remarks>Read the Master Server and Proxy manual chapter. It explains how to use the Proxy Server.</remarks>
    </member>
    <member name="P:uLink.Network.proxyPort">
      <summary>Not in use.</summary>
      <remarks>Read the Master Server and Proxy manual chapter. It explains how to use the Proxy Server.</remarks>
    </member>
    <member name="P:uLink.Network.sendRate">
      <summary>
            Gets or sets the send rate for state synchronizations from this peer/host.
            </summary>
      <value>The default value is 15.</value>
      <remarks>Fast paced games like FPS games should use 15-25. Other games can use any value. This value is the most (server-side) bandwidth 
            sensitive configuration in uLink, at least if the usage of statesync in the game is extensive.
            If you want to send different information with different rates in uLink, then you can use RPCs with coroutines/InvokeRepeating.
            </remarks>
      <example>
        <code>
            void Awake ()
            {
                // Increase default send rate
                uLink.Network.sendRate = 25;
            }
            </code>
      </example>
    </member>
    <member name="P:uLink.Network.trackRate">
      <summary>
            Cell Server only: Gets or sets the send rate for track position messages sent from this cell server.
            </summary>
      <remarks>
            Read pikko server's manual for more information.
            </remarks>
    </member>
    <member name="P:uLink.Network.trackMaxDelta">
      <summary>
            Cell Server only: Gets or sets the max delta distance that an object can move without sending track position messages (from this cell server).
            </summary>
      <remarks>
            Read pikko server's manual for more information.
            </remarks>
    </member>
    <member name="P:uLink.Network.time">
      <summary>
            Gets the current network time in seconds. This is the client's <see cref="P:uLink.Network.localTime" />
            plus the offset of the server's time, compared to its own.
            </summary>
      <remarks>
            This value starts at 0 when the server starts. 
            If a uLink client hasn't yet connected to a server or a server hasn't been initialized, 0 is returned.
            <para>
            The network time on all connected clients is synchronized by uLink. 
            Each client is synchronized just once, during the internal uLink connection sequence.
            The ping time during the client's connection is divided in half to 
            set the time offset for this client, 
            that will be used in the client until it is disconnected.
            </para><para>
            Be aware of the fact that this time value, in the client, is based on the local clock after 
            the initial connection and therefore changes in ping time can make the server time and client 
            time appear to run with fluctuating speeds. Try to compare client time stamps with other client stamps 
            and server time stamps with other server time stamps to avoid subtile bugs that will appear 
            only when the ping time changes. When comparing client time stamps with server time stamps, be careful.
            </para><para>
            uLink uses two separate local CPU clocks to make sure the value for Network.time is always correct 
            and very accurate on several different hardwares.
            </para></remarks>
      <example>This value can, for example, be used to compare with the time 
            returned in <see cref="T:uLink.NetworkMessageInfo" />.
            <code>
            class SomeClass : uLink.MonoBehaviour
            {
            	float something;
            	double transitTime;
            
            	void uLink_OnSerializeNetworkView (uLink.BitStream stream, uLink.NetworkMessageInfo info)
            	{
            		float horizontalInput = 0.0;
            		if (stream.isWriting)
            		{
            			// Sending
            			horizontalInput = transform.position.x;
            			stream.WriteFloat(horizontalInput);
            		} 
            		else
            		{
            			// Receiving
            			transitTime	= Network.time - info.timestamp;
            			horizontalInput = stream.ReadFloat();
            			something = horizontalInput;
            		}
            	}
            
            	void OnGUI()
            	{
            		GUILayout.Label("Last transmission time: " + transitTime.ToString());
            	}
            }
            </code></example>
    </member>
    <member name="P:uLink.Network.timeInMillis">
      <summary>
            Gets the current network time in milliseconds. 
            </summary>
      <remarks>Works just like <see cref="P:uLink.Network.time" />, except the 
            returned value is rounded to the the closest millisecond. 
            </remarks>
      <example>This can, for example, be used to compare with the time 
            returned in <see cref="T:uLink.NetworkMessageInfo" />.
            <code>
            class SomeClass : uLink.MonoBehaviour
            {
            	float something;
            	ulong transitTimeInMillis;
            
            	void uLink_OnSerializeNetworkView (uLink.BitStream stream, uLink.NetworkMessageInfo info)
            	{
            		float horizontalInput = 0.0;
            		if (stream.isWriting)
            		{
            			// Sending
            			horizontalInput = transform.position.x;
            			stream.WriteFloat(horizontalInput);
            		} 
            		else
            		{
            			// Receiving
            			transitTimeInMillis = Network.timeInMillis - info.timestampInMillis;
            			horizontalInput = stream.ReadFloat();
            			something = horizontalInput;
            		}
            	}
            
            	void OnGUI()
            	{
            		GUILayout.Label("Last transmission time: " + timestampInMillis.ToString());
            	}
            }
            </code></example>
    </member>
    <member name="P:uLink.Network.localTime">
      <summary>
            The local time of the player. This timer is started as soon as uLink starts working.
            this is a high precision value calculated using the operating system's high precision timers and is not
            smoothed out for animation or any other purpose like (UnityEngine.Time.time)
            </summary>
    </member>
    <member name="P:uLink.Network.localTimeInMillis">
      <summary>
            Same as <see cref="P:uLink.Network.localTime" /> but in milliseconds.
            </summary>
    </member>
    <member name="P:uLink.Network.useNat">
      <summary>
            Gets or sets a value indicating whether to use NAT punchthrough.
            </summary>
      <value>
        <c>true</c> if using NAT punchthrough; otherwise, <c>false</c>. Default is false.</value>
      <remarks>
            Not Implemented.
            Read more on this subject in the manual and the <see cref="T:uLink.MasterServer" />.
            </remarks>
    </member>
    <member name="P:uLink.Network.rpcTypeSafe">
      <summary>
            Gets or sets a <see cref="T:uLink.RPCTypeSafe" /> value indicating whether the parameters in RPCs will be type
            safe or not.
            </summary>
      <value>Type safety is set to <see cref="F:uLink.RPCTypeSafe.OnlyInEditor" /> by default,
            which means it will only be turned on when running uLink in the Unity editor, so that you can find
            bugs early in development. I.e. if you run uLink outside the editor it will be turned off by default.
            Change this value to overrule the default behavior.
            It is common to run clients outside the editor and the server in the editor,
            and uLink can handle this without problems, but in that case you will only get type saftey
            when sending from the server (in the editor) and not on RPCs that are sent from the clients (outside the editor).</value>
      <remarks>If type safety is turned on it will increase RPC's packet size by
            one extra byte for each RPC parameter, so that it can tell the receiver the
            expected <see cref="T:uLink.BitStreamTypeCode" />. The purpose is to avoid subtile bugs like
            sending an integer but receiving it as a float. When type safety is
            turned on uLink will throw an exception when a RPC parameter
            doesn't match the recievers function declaration. The price for type
            safety is increased bandwidth.</remarks>
    </member>
    <member name="P:uLink.Network.defaultRPCFlags">
      <summary>
            This <see cref="T:uLink.NetworkFlags" /> is the default set of flags which are used whenever you don't send specific flags to your RPC calls. 
            </summary>
    </member>
    <member name="P:uLink.Network.isCellServer">
      <summary>
            Gets a value indicating whether this instance is a cell server.
            </summary>
      <remarks>Cell servers are game servers connected using PikkoServer in a distributed 
            system of game servers to make the virtual world seamless. Read more 
            about this in the PikkoServer MMO manual chapter.</remarks>
    </member>
    <member name="P:uLink.Network.isClientOrCellServer">
      <summary>
            Returns true if this is a uLink client or cell server, otherwise false.
            </summary>
    </member>
    <member name="P:uLink.Network.isServerOrCellServer">
      <summary>
            Returns true if this is a uLink server or cell server, otherwise false.
            </summary>
    </member>
    <member name="P:uLink.Network.isAuthoritativeServer">
      <summary>
            Gets or sets a value indicating whether this instance has an authoritative server.
            </summary>
      <remarks>This is an important strategic choice when building a 
            multiplayer game. By making the server authoritative, clients are prevented from performing dangerous operations 
            such as sending RPC:s to other players (via the server). Authoritative servers will not receive statesync 
            from clients. Most commercial game servers are authoritative for security reasons.
            Keep in mind that when using an authoritative server, both client and server should set this to true.
            Read more in the uLink manual's section on Authoritative server.</remarks>
    </member>
    <member name="P:uLink.Network.useDifferentStateForOwner">
      <summary>
            Dictates if the statesync sent to the owner will be different from proxy statesync and thus handled separately.
            </summary>
      <value>Default is true</value>
      <remarks>This value is only useful in an authoritative server. When <c>true</c>, the statesync to owner 
            will be sent separately and thus can be received separately. 
            Take a look at the callback <see cref="!:uLink_OnSerializeNetworkViewOwner" />, it will be called on the 
            receiver that is the owner for the object and on the server sending this kind of statesync. 
            Statesync to proxy objects will be handled the normal way in <see cref="!:uLink_OnSerializeNetworkView" />. 
            When this value is set to false, the callback <see cref="!:uLink_OnSerializeNetworkView" /> will be used for all statesyncs. 
            </remarks>
    </member>
    <member name="P:uLink.Network.useRedirect">
      <summary>
            Setting this value to true in the server causes all future connection attempts 
            to be automatically redirected.
            </summary>
      <remarks>All connection attempts to this server will be redirected to the server 
            specified by the <see cref="P:uLink.Network.redirectIP" /> and <see cref="P:uLink.Network.redirectPort" /> (and 
            optionally <see cref="P:uLink.Network.redirectPassword" />) properties.
            </remarks>
    </member>
    <member name="P:uLink.Network.redirectIP">
      <summary>
            The host domain name or IP to connect to when the <see cref="P:uLink.Network.useRedirect" /> property is set to true.
            </summary>
      <remarks>
            If the redirect is to a uLink server with the same IP, only the port is different, 
            set this property to <see cref="F:System.Net.IPAddress.Any" />.
            </remarks>
    </member>
    <member name="P:uLink.Network.redirectPassword">
      <summary>
            The password to use (if needed) when the <see cref="P:uLink.Network.useRedirect" /> property is set to true.
            </summary>
    </member>
    <member name="P:uLink.Network.redirectPort">
      <summary>
            The port to connect to when the <see cref="P:uLink.Network.useRedirect" /> property is set to true.
            </summary>
    </member>
    <member name="P:uLink.Network.approvalData">
      <summary>
            Gets the approval data sent from the server, that can be used in the client right after a connection is established
            </summary>
      <remarks>This is the <see cref="T:uLink.BitStream" /> the client can read when the approval data needs to be handled.
            The code for checking approvalData should always be placed in the callback <see cref="!:uLink_OnConnectedToServer" />. 
            If you need to read the approvalData later (again) for some reason, it is available via this propery.
            </remarks>
      <example>ApprovalData can be anything the server sends to a newly connected client. It could be information about 
            which level to load and information about which RPC groups the client should avoid.</example>
    </member>
    <member name="P:uLink.Network.loginData">
      <summary>
            A client can get the loginData via this property, the loginData that 
            was included and sent to the server when Connect was called. 
            </summary>
      <remarks>
            The purpose of this property is that sometimes it is handy to to check 
            what data was sent to the server when the connection was made.</remarks>
    </member>
    <member name="P:uLink.Network.publicKey">
      <summary>
            Specifies a user-defined public RSA key. This method should be used on the client-side only.
            </summary>
      <remarks>
            By setting the public key that corresponds to the server all connection attempts from this 
            client will be encrypted and the connection
            will only be successful to a server with the corresponding private key.
            See the manual page about network security and encryption.
            </remarks>
    </member>
    <member name="P:uLink.Network.privateKey">
      <summary>
            Gets of sets a user-defined private RSA key. This should be set on the server-side only.
            </summary>
      <remarks>
            See manual pages for security and encryption for more information. 
            The key should not be accessible to the clients.
            You should call this in a code which only compiles for the server andthe string containing 
            the key should not be in the files
            which clients can access, otherwise they'll be able to use it on their own cheated servers as well.
            </remarks>
    </member>
    <member name="P:uLink.Network.emulation">
      <summary>
            Gets or sets the emulation of network problems like max bandwidth, packet loss, duplicate packets and latecy fluctuations.
            </summary>
      <remarks>
            Use this to test your game with some network issues that are common in the real world before releasing your game. 
            </remarks>
    </member>
    <member name="P:uLink.Network.config">
      <summary>
            Gets or sets configuration for low-level connection parameters, like timeouts, handshake attempts and ping frequency.
            </summary>
      <remarks>
            Use this to fine-tune the behavior of the underlying uLink protocol for maximum networking performance.
            </remarks>
    </member>
    <member name="P:uLink.Network.logLevel">
      <summary>
            Gets or sets the loglevel for uLink logging.
            </summary>
    </member>
    <member name="T:uLink.RPCReceiver">
      <summary>
            Dictates who will receive RPCs sent to a game Object.
            Read about this enum in <see cref="F:uLink.NetworkView.rpcReceiver" />.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.Off">
      <summary>
            Does not listen for incoming RPCs to this networkView, RPCs will be ignored.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.OnlyObservedComponent">
      <summary>
            Forwards incoming RPCs only to the observed component property, if it is a MonoBehaviour.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.ThisGameObject">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in this gameobject. Default value.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.ThisGameObjectAndChildren">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in this gameobject and also to all 
            MonoBehaviours in all of this GameObject's children.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.RootGameObjectAndChildren">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in the root gameobject, which this
            gameobject belongs to, and also to all MonoBehaviours in all the root's children.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.AllActiveGameObjects">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in all GameObjects activated in the scene.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.GameObjects">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in the GameObjects specified by the rpcReceiverGameObjects property.
            </summary>
    </member>
    <member name="T:uLink.NetworkView">
      <summary>
            Very important class in uLink, contains implementation for the uLink.NetworkView script.
            </summary>
      <remarks>
            By adding the script uLink.NetworkView as a component in your GameObject
            or a prefab in Unity it is ready to be used for sending and receiving
            StateSyncs and RPCs. The networkView is every network aware object's 
            only way to get data from the network and send data over the network.
            That is why you will find methods like 
            <see cref="O:uLink.NetworkView.RPC" /> and 
            <see cref="O:uLink.NetworkView.UnreliableRPC" /> 
            here.
            <para>
            If you have objects which you don't need RPCs and State synch, then there is no need for them to have NetworkViews.
            It's true even if they use Network class to do operations like <see cref="!:uLink..Network.Connect" /></para><para>
            Multiple NetworkViews are supported for compatibility reasons but they are not recommended and RPCs
            will be sent to the first NetworkView. If you want to observe multiple components for State Sync then use the utility component
            ObservedList to achieve what you want.
            </para></remarks>
      <example>
            The common ways of interacting with the NetworkView instance for network aware objects
            in C# is writing classes 
            that extends <see cref="T:uLink.MonoBehaviour" /> and then accessing the networkView
            property available in all subclasses to <see cref="T:uLink.MonoBehaviour" />.
            <code>
            public class Example : uLink.MonoBehaviour {
            
            private int myID = networkView.viewID.id; 
            
            }
            </code>
            The common way of interacting with the NetworkView in a JavaScript is writing
            scripts that retrieves the networkView like in the code below. 
            <code>
            
            private var networkView = uLink.NetworkView.Get(this);
            private var myID = networkView.viewID.id;
            
            </code>    
            
            For this code to work, remember to add the 
            script you write as a script component to the prefab/GameObject.
            </example>
    </member>
    <member name="F:uLink.NetworkView.observed">
      <summary>
            The Component that this networkView should serialize when StateSync is being sent or is received.
            </summary>
      <remarks>
            Note that <see cref="F:uLink.NetworkView.rpcReceiver" /> can be 
            set to <see cref="T:uLink.RPCReceiver">RPCReceiver.OnlyObservedComponent</see>. 
            In that case this field also dictates the rpcReceiver for this NetworkView.
            <para>
            Read more about the Component class in the Unity documentation.
            </para></remarks>
    </member>
    <member name="F:uLink.NetworkView.rpcReceiver">
      <summary>
            Gets or sets the receivers for incoming RPCs to this network view.
            </summary>
      <value>Default is <see cref="F:uLink.RPCReceiver.ThisGameObject" /></value>
      <remarks>All scripts attached to the same prefab/GameObject as this
            NetworkView will be able to get this RPC and can therefore contain
            code for RPC receiving. If you want to put RPC receiving code in
            scripts attached to a root GameObject or scripts attached to a child
            gameobject, this can be done, but this property needs to be changed
            then.</remarks>
    </member>
    <member name="F:uLink.NetworkView.instantiator">
      <summary>
            You can customize the process of instantiation and destruction of this network aware object by assigning
            methods to <see cref="!:uLink.Network.destroyer" /> and <see cref="!:uLink.NetworkInstantiator.instantiator" /> delegates of this field. 
            </summary>
      <remarks>
            For more information <see cref="T:uLink.NetworkInstantiator" /></remarks>
    </member>
    <member name="M:uLink.NetworkView.GetChild(System.Int32)">
      <summary>
            Returns networkView of the specified child.
            </summary>
      <param name="childIndex">Index of this network aware GameObject's child in hierarchy.</param>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkView.ExecuteRPC(System.String,System.Object[])">
      <summary>
            Try to execute the RPC with specified parameters in this network aware gameobject.
            Returns <c>true</c> if executing RPC was successful, else returns <c>false</c></summary>
      <param name="rpcName">Name of the RPC</param>
      <param name="parameters">The parameters which should pass to the RPC</param>
      <remarks>The execution can go wrong for two reasons, The RPC might not exist or an exception
            can be thrown inside the RPC which causes the execution to fail.</remarks>
    </member>
    <member name="M:uLink.NetworkView.ClearCachedRPCs">
      <summary>
            Advanced usage only: To increase performance uLink makes a cache of RPC receivers. The cache is populated 
            the first time an RPC is received. All RPC after the first call will be delivered to the same
            RPC receiver (a script component). The cache can be cleared by this method.
            </summary>
    </member>
    <member name="M:uLink.NetworkView.SetScope(uLink.NetworkPlayer,System.Boolean)">
      <summary>
            Set the scope of the network view in relation to a specific network player.
            This can be used to turn StateSync updates and RPCs temporarily on and off for a specific player, to reduce the 
            network traffic and thus bandwidth demands on the server and player. 
            </summary>
      <remarks>The SetScope function must be called from the server in an authoritative server architecture; it will return an error if called from the client.
            
            This can be used to implement relevant sets. If a player can't see a network view object, then relevancy can be turned off for that player. When the player (or 
            the object) later moves and is able to see the object, the relevancy must be turned on again. Read more in the 
            uLink manual about distance culling and occlusion culling.
            </remarks>
      <param name="target">The player affected by this scope change.</param>
      <param name="relevancy">Set to true or false depending on if you want the player to receive StateSync updates and RPCs from the network view or not.</param>
      <returns>The previous relevancy for the specific player.</returns>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])">
      <summary>
             Sends a reliable RPC. Receivers are dictated by <see cref="T:uLink.RPCMode" />.
             </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
             this RPC should be buffered is also dictated by the 
             <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
             to the RPC method there (as argument).</param>
      <remarks>
             The called method must have the [RPC] attribute for C-Sharp
             code. A NetworkView must be attached to the GameObject where the
             RPC method is being called. It doesn't matter if the NetworkView
             is being used for something else or just for the RPC method. If it
             is just for the RPC method, state synchronization should be turned
             off and the observed property can be set to none. RPC method names
             should be unique across the scene, if two RPC methods in
             different scripts have the same name only one of them is called when
             RPC is invoked. Reliable RPC calls are always guaranteed to be executed in
             the same order as they are sent. The communication group set for the
             network view, with NetworkView.group, is used for the RPC call. To
             get information on the RPC itself, you can add a <see cref="T:uLink.NetworkMessageInfo" />
             parameter to the receiving method's declaration, which will automatically
             contain the information. You don't need to change the way you call
             the RPC method when you do this. For more information see the RPC
             section of the uLink manual. 
             </remarks>
      <example>
        <code>
             public Transform cubePrefab;
             void OnGUI ()
             {
                if (GUILayout.Button("SendMessage"))
                {
                   networkView.RPC("TransferStrings",
                   RPCMode.All, "uLink ", "makes ", "me " "happy.");
                }
             }
            
             [RPC]
             void TransferStrings (String s1, String s2 , String s3, String s4) 
             {
                 Debug.Log("Got: " s1 + s2 + s3 + s4); 
             }
             </code>
      </example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(System.String,uLink.RPCMode,``0)">
      <summary>
            Sends a reliable RPC. Receivers are dictated by <see cref="T:uLink.RPCMode" />.
            </summary>
      <typeparam name="T">Type of the argument you want to pass to the RPC</typeparam>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="arg">The arguments from type <c>T</c> that the remote receiver will send
            to the RPC method executed there (as argument)</param>
      <remarks>
            If you want to send only one argument which is an array type, you should use this generic RPC overload, because
            the reflection functionality in .Net can only understand the method signature correctly in this way.
            For more information see <see cref="!:RPC(string rpcName, RPCMode mode, params object[] args)" /></remarks>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends a reliable RPC to the specified <see cref="T:uLink.NetworkPlayer" />.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <member name="M:uLink.NetworkView.RPC``1(System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends a reliable RPC to the specified <see cref="T:uLink.NetworkPlayer" />.
            </summary>
      <typeparam name="T">Type of the argument you want to pass to the RPC</typeparam>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="arg">The arguments from type <c>T</c> that the remote receiver will send
            to the RPC method executed there (as argument)</param>
      <remarks>
            If you want to send only one argument as an array, you should use this generic RPC overload, because
            the reflection functionality in .Net can only understand the method signature correctly in this way.
            </remarks>
      <seealso cref="!:RPC(string rpcName, RPCMode mode, params object[] args)" />
    </member>
    <member name="M:uLink.NetworkView.RPC(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends a reliable RPC to several NetworkPlayers.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
      <remarks>This can be used to send something to team mates, private chat ...</remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},``0)" -->
    <member name="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC. Receivers are dictated by <see cref="T:uLink.RPCMode" />.
            The <c>flags</c> parameter can be used to customize the way that the RPC is sent.
            </summary>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to specify optional <see cref="T:uLink.NetworkFlags" />
            . By setting the flags you have the power to control the handling of
            this RPC in uLink. Primarily you should use 
            <see cref="O:uLink.NetworkView.RPC" /> or 
            <see cref="O:uLink.NetworkView.UnreliableRPC" /> or 
            <see cref="O:uLink.NetworkView.UnencryptedRPC" /> (without NetworkFlags parameter). But
            sometimes those three methods are not enough,  then it is OK to
            use this method. Note that the buffer flag will override the buffer setting you can control
            via the <see cref="T:uLink.RPCMode" /> argument.
            </remarks>
      <example>
            If you want to send an RPC that is encrypted AND unreliable you can
            do that. Or if you want to send an RPC that has no timestamp, to
            save bandwidth, it is possible by setting the correct flag.
            </example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(uLink.NetworkFlags,System.String,uLink.RPCMode,``0)" -->
    <member name="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" />.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <member name="M:uLink.NetworkView.RPC``1(uLink.NetworkFlags,System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" /></summary>
      <typeparam name="T">Type of the argument you want to pass to the RPC</typeparam>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="args">
      </param>
      <remarks>
            If you want to send only one argument as an array, you should use this generic RPC overload, because
            the reflection functionality in .Net can only understand the method signature correctly in this way.
            For more information see <see cref="!:RPC(NetworkFlags flags, string rpcName, NetworkPlayer target, params object[] args)" /></remarks>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <member name="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC to several network players. 
            </summary>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">Use this to control exactly how uLink will
            handle this RPC.</param>
      <remarks>
            Use this RPC method to specify optional <see cref="T:uLink.NetworkFlags" />
            . By setting the flags you have the power to control the handling of
            this RPC in uLink. Primarily you should use 
            <see cref="O:uLink.NetworkView.RPC" /> or 
            <see cref="O:uLink.NetworkView.UnreliableRPC" /> or 
            <see cref="O:uLink.NetworkView.UnencryptedRPC" /> (without NetworkFlags parameter). But
            sometimes those three methods are not enough,  then it is OK to
            use this method. Note that the buffer flag will override the buffer setting you can control
            via the <see cref="T:uLink.RPCMode" /> argument.
            </remarks>
      <example>
            If you want to send an RPC that is encrypted AND unreliable you can
            do that. Or if you want to send an RPC that has no timestamp, to
            save bandwidth, it is possible by setting the correct flag.
            </example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},``0)" -->
    <member name="M:uLink.NetworkView.UnreliableRPC(System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an unreliable RPC.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Works exactly like <see cref="O:uLink.NetworkView.RPC" />, except that it is sent over an unreliable channel in uLink. This saves resources on the server and the client because there is no need to handle resends in uLink.
            Unreliable RPCs can be used for everything which if they are not received, the information will be soon replaced
            by something else and the failure of receiving it can be tolerated.
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.UnreliableRPC``1(System.String,uLink.RPCMode,``0)" -->
    <member name="M:uLink.NetworkView.UnreliableRPC(System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an unreliable RPC to the specified <see cref="T:uLink.NetworkPlayer" />.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Works exactly like <see cref="O:uLink.NetworkView.RPC" />, except that it is sent over an unreliable channel in uLink. This saves resources on the server and the client because there is no need to handle resends in uLink.
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.UnreliableRPC``1(System.String,uLink.NetworkPlayer,``0)" -->
    <member name="M:uLink.NetworkView.UnreliableRPC(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an unreliable RPC to several network players.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Works exactly like <see cref="O:uLink.NetworkView.RPC" />, except that it is sent over an unreliable channel in uLink. This saves resources on the server and the client because there is no need to handle resends in uLink.
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.UnreliableRPC``1(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},``0)" -->
    <member name="M:uLink.NetworkView.UnencryptedRPC(System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC without encryption.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            This method makes it possible
            to send unencrypted RPCs even when security has been turned on.
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.UnencryptedRPC``1(System.String,uLink.RPCMode,``0)" -->
    <member name="M:uLink.NetworkView.UnencryptedRPC(System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC the specified <see cref="T:uLink.NetworkPlayer" /> without encryption.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            This method makes it possible
            to send unencrypted RPCs even when security has been turned on.
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.UnencryptedRPC``1(System.String,uLink.NetworkPlayer,``0)" -->
    <member name="M:uLink.NetworkView.UnencryptedRPC(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC to several NetworkPlayers without encryption.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">
      </param>
      <remarks>
            This method makes it possible
            to send unencrypted RPCs even when security has been turned on.
            </remarks>
    </member>
    <member name="M:uLink.NetworkView.UnencryptedRPC``1(System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},``0)">
      <summary>
            Sends an RPC to several NetworkPlayers without encryption.
            </summary>
      <typeparam name="T">Type of the argument you want to pass to the RPC</typeparam>
      <param name="rpcName">Name of the RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">
      </param>
      <remarks>
            This method makes it possible
            to send unencrypted RPCs even when security has been turned on.
            If you want to send only one argument as an array, you should use this generic RPC overload, because
            the reflection functionality in .Net can only understand the method signature correctly in this way.
            </remarks>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="!:RPC(string rpcName, RPCMode mode, params object[] args)" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(System.Type,System.String,uLink.RPCMode,``0)" -->
    <member name="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" /> and it is also restricted to the specified Type (parameter type).
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(System.Type,System.String,uLink.NetworkPlayer,``0)" -->
    <member name="M:uLink.NetworkView.RPC(System.Type,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC to several NetworkPlayers and it is also restricted to the specified Type (parameter type).
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(System.Type,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},``0)" -->
    <member name="M:uLink.NetworkView.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type).
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(System.Type,uLink.NetworkFlags,System.String,uLink.RPCMode,``0)" -->
    <member name="M:uLink.NetworkView.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" /> and it is also restricted to the specified Type (parameter type).
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(System.Type,uLink.NetworkFlags,System.String,uLink.NetworkPlayer,``0)" -->
    <member name="M:uLink.NetworkView.RPC(System.Type,uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC to several NetworkPlayers and it is also restricted to the specified Type (parameter type).
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(System.Type,uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},``0)" -->
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script. 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,System.String,uLink.RPCMode,``0)" -->
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" /> restricted to the specified MonoBehavior (parameter type).
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script. 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,``0)" -->
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC to several NetworkPlayers and also restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <seealso cref="!:RPC(System.string, uLink.RPCMode, System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},``0)" -->
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script. 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.RPCMode,``0)" -->
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script. 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambiguous which script should receive the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the receiver to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.NetworkPlayer,``0)" -->
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},System.Object[])">
      <summary>
            Sends an RPC to several NetworkPlayers and also restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="targets">An IEnumerable which contains all of the players that this RPC should sends to.
            The targets can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer).</param>
      <param name="args">
      </param>
      <seealso cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,System.Collections.Generic.IEnumerable{uLink.NetworkPlayer},``0)" -->
    <member name="M:uLink.NetworkView.RemoveRPCs">
      <summary>
            Removed all custom buffered RPCs for this network view.
            </summary>
      <remarks>
            If any buffered RPCs has been sent via this network view, they can be removed using this method.
            </remarks>
    </member>
    <member name="M:uLink.NetworkView.ToString">
      <summary>
            Returns this network aware gameobject's place in hierarchy and its <see cref="!:viewID" /> in string.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkView.ToPrefabString">
      <summary>
            Returns name of the prefab used to instantiate this local object
            or name of the object if the prefab name doesn't exist.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:uLink.NetworkView.Find(uLink.NetworkViewID)">
      <summary>
            Returns the NetworkView instance that has the specified viewID.
            </summary>
      <returns>Returns a NetworkView instance or <c>null</c> if nothing was found</returns>
    </member>
    <member name="M:uLink.NetworkView.FindByOwner(uLink.NetworkPlayer)">
      <summary>
            Returns an array of NetworkView instances, that all have the specified owner.
            </summary>
      <returns>Returns an array of NetworkView instance. If nothing was found, the array will be empty. Never returns null.</returns>
    </member>
    <member name="M:uLink.NetworkView.AnyByOwner(uLink.NetworkPlayer)">
      <summary>
            Determines if any NetworkView has the specified owner.
            </summary>
      <returns>Returns true if there are any enabled NetworkView instances owned by specified player. Returns false if no such NetworkView exists.</returns>
    </member>
    <member name="M:uLink.NetworkView.AnyInGroup(uLink.NetworkGroup)">
      <summary>
            Determines if any NetworkView is part of the specified group.
            </summary>
      <returns>Returns true if there are any enabled NetworkView instances inside the specified group. Returns false if no such NetworkView exists.</returns>
    </member>
    <member name="M:uLink.NetworkView.FindInGroup(uLink.NetworkGroup)">
      <summary>
            Returns an array of NetworkView instances, that all belong to specified group.
            </summary>
      <returns>Returns an array of NetworkView instance. If nothing was found, the array length is 0. Never returns null.</returns>
    </member>
    <member name="M:uLink.NetworkView.Get(UnityEngine.GameObject)">
      <summary>
            Gets the NetworkView instance from the specified GameObject.
            </summary>
      <param name="gameObject">Read about the gameobject class in the Unity documentation.</param>
    </member>
    <member name="M:uLink.NetworkView.Get(UnityEngine.Component)">
      <summary>
            Gets the NetworkView instance from the gameObject which specified Component is attached to.
            </summary>
      <param name="component">Read about the Component class in the Unity documentation.</param>
    </member>
    <member name="P:uLink.NetworkView.rpcReceiverGameObjects">
      <summary>
            The GameObject's which receive RPCs send to this network aware object.
            This is only valid if <see cref="F:uLink.NetworkView.rpcReceiver" /> is set to <see cref="!:RPCReceiver.Gameobjects" /></summary>
    </member>
    <member name="P:uLink.NetworkView.prefabRoot">
      <summary>
            Gets or sets the root gameobject of the gameobject that this networkView is attached to.
            </summary>
    </member>
    <member name="P:uLink.NetworkView.parent">
      <summary>
            Returns networkView of this networkView's parent.
            </summary>
    </member>
    <member name="P:uLink.NetworkView.root">
      <summary>
            Returns networkView of this networkView's root.
            </summary>
    </member>
    <member name="P:uLink.NetworkView.position">
      <summary>
            Gets the position of this network aware object.
            </summary>
      <remarks>This is the position of the root of the gameObject hierarchy so if the networkview is attached to a child GameObject
            then it will retun the root's position.
            You might for example group all of your NPCs as children of a NPCRoot GameObject,
            then that NPCRoot's position will be returned.
            </remarks>
    </member>
    <member name="P:uLink.NetworkView.rotation">
      <summary>
            Gets the rotation of this network aware object.
            </summary>
    </member>
    <member name="T:uLink.RegisterPrefabs">
      <summary>
             Use this script component to register the prefabs that will be
             used in <see cref="O:uLink.Network.Instantiate" />. 
            
             If all your prefabs are placed in the Resources folder, there is no need to use this
             utility script. 
            
             If you want to register prefabs at run-time, for example after downloading an asset 
             bundle in a client, check out <see cref="T:uLink.NetworkInstantiator" /> in the API doc.
            
             Read more about registering prefabs in the manual chapter about Instantiating Objects.
             </summary>
    </member>
  </members>
</doc>